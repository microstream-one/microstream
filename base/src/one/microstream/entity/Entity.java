
package one.microstream.entity;

import one.microstream.chars.XChars;
import one.microstream.collections.BulkList;
import one.microstream.collections.types.XCollection;

/*
 * Concept to separate the basic aspects of what defines an entity into separate instances of different layers:
 * - identity (a never to be replaced instance representing an entity in terms of references to it)
 * - logic (nestable in an arbitrary number of dynamically created logic layers, e.g. logging, locking, versioning, etc.)
 * - data (always immutable)
 * 
 * Entity graphs are constructed by stricly only referencing identity instances (the "outer shell" of an entity),
 * while every inner layer instance is unshared. This also allows the actual data instance to be immutable, while
 * at the same time leaving referencial integrity of an entity graph intact.
 * 
 * Everything starting with a _ could be synthetic, meaning generated by an IDE plugin.
 * The "_" is just an arbitrary prefix, of course and could be replaced by anything else or simple be configurable.
 * 
 * The concept could even be used to manage concurrency:
 * Multiple currently reading threads would query and use the current data instance of an entity.
 * A modification would replace the data instance with a new one without immediate effect to the other threads.
 * Version meta values (like a sequence number or a timestamp) could even be kept and checked in an intermediate
 * layer without poluting the business entity with technical values.
 * 
 * While the layers admittedly introduce considerable technical complexity and runtime overhead,
 * this concept might be the holy grail of entity handling for nearly all requirements regarding
 * cross cutting concerns / aspects.
 *
 */


/**
 * A mutable entity. Mutations of the entity's data only happen by providing another instance of that entity
 * that contains the desired new data.
 * 
 * @author TM
 */
public interface Entity
{
	@SuppressWarnings("unchecked")
	public static <E extends Entity> E identity(final E instance)
	{
		if(instance instanceof Entity.AbstractAccessible)
		{
			return (E)((Entity.AbstractAccessible)instance).$entityIdentity();
		}
		
		if(instance instanceof Entity.Accessible)
		{
			return (E)((Entity.Accessible)instance).$entityIdentity();
		}
		
		if(instance == null)
		{
			// null is consistently its own identity
			return null;
		}
		
		throw new EntityException("Unaccessable entity type: " + XChars.systemString(instance));
	}
	
	@SuppressWarnings("unchecked")
	public static <E extends Entity> E data(final E instance)
	{
		if(instance instanceof Entity.AbstractAccessible)
		{
			return (E)((Entity.AbstractAccessible)instance).$entityData();
		}
		
		// tiny redundancy as a tiny price for convenient visibility magic plus still possible multiple inheritance
		if(instance instanceof Entity.Accessible)
		{
			return (E)((Entity.Accessible)instance).$entityData();
		}
		
		if(instance == null)
		{
			// null is consistently its own data
			return null;
		}
		
		throw new EntityException("Unaccessable entity type: " + XChars.systemString(instance));
	}
	
	public static <E extends Entity> boolean updateData(final E entity, final E data)
	{
		if(entity instanceof Entity.AbstractAccessible)
		{
			// data instance validation is done inside (has to be, anyway)
			return ((Entity.Accessible)entity).$updateEntityData(data);
		}
		
		// tiny redundancy as a tiny price for convenient visibility magic plus still possible multiple inheritance
		if(entity instanceof Entity.Accessible)
		{
			// data instance validation is done inside (has to be, anyway)
			return ((Entity.Accessible)entity).$updateEntityData(data);
		}
		
		throw new EntityException("Unaccessable entity type: " + XChars.systemString(entity));
	}
	
	public default boolean isSameIdentity(final Entity other)
	{
		return identity(this) == identity(other);
	}
	
	public default void validateIdentity(final Entity newData)
	{
		if(this.isSameIdentity(newData))
		{
			return;
		}
		
		throw new EntityException("Entity identity mismatch.");
	}
	
	/**
	 * Primary means to convenience-hide framework-internal methods from the user entity's public API
	 * 
	 * @author TM
	 */
	public abstract class AbstractAccessible implements Entity
	{
		protected abstract Entity $entityIdentity();
		
		protected abstract Entity $entityData();
		
		protected abstract boolean $updateEntityData(Entity data);
	}
	
	/**
	 * Fallback means to convenience-hide framework-internal methods from the user entity's public API
	 * for classes that cannot extend {@link AbstractAccessible} for whatever reason
	 * 
	 * @author TM
	 */
	public interface Accessible extends Entity
	{
		public Entity $entityIdentity();
		
		public Entity $entityData();
		
		public boolean $updateEntityData(Entity data);
	}
	
	public interface Creator<E extends Entity, C extends Creator<E, C>>
	{
		public E create();
		
		public E createData(E identityInstance);
		
		public E createData();
		
		public C entity(E identity);
		
		public C copy(E other);
		
		@SuppressWarnings("unchecked")
		public default C addLayer(final EntityLayerProvider layerProvider)
		{
			synchronized(this)
			{
				final XCollection<EntityLayerProvider> layerProviders = this.layers();
				synchronized(layerProviders)
				{
					layerProviders.add(layerProvider);
				}
			}
			
			return (C)this;
		}
		
		public default C addLayer(final EntityLayerProviderProvider layerProviderProvider)
		{
			return this.addLayer(layerProviderProvider.provideEntityLayerProvider());
		}
		
		public XCollection<EntityLayerProvider> layers();
		
		public abstract class Abstract<E extends Entity, C extends Creator<E, C>>
			implements Entity.Creator<E, C>
		{
			///////////////////////////////////////////////////////////////////////////
			// instance fields //
			////////////////////
			
			private final BulkList<EntityLayerProvider> layerProviders = BulkList.New();
			private E                                   entityIdentity;
			
			///////////////////////////////////////////////////////////////////////////
			// methods //
			////////////
			
			@Override
			public XCollection<EntityLayerProvider> layers()
			{
				return this.layerProviders;
			}
			
			protected Entity dispatchDataInstance(final Entity dataInstance)
			{
				Entity innerLayer = dataInstance;
				for(final EntityLayerProvider lp : this.layerProviders)
				{
					innerLayer = lp.provideEntityLayer(innerLayer);
				}
				
				return innerLayer;
			}
			
			@SuppressWarnings("unchecked")
			@Override
			public E create()
			{
				final EntityLayerIdentity entity        = this.createEntityInstance();
				
				final Entity              data          = this.createData((E)entity.$entityIdentity());
				final Entity              innerInstance = this.dispatchDataInstance(data);
				
				entity.$setInner(innerInstance);
				
				return (E)entity.$entityIdentity();
			}
			
			@SuppressWarnings("unchecked")
			@Override
			public C entity(final E entity)
			{
				this.entityIdentity = entity;
				return (C)this;
			}
			
			@Override
			public E createData()
			{
				return this.createData(Entity.identity(this.entityIdentity));
			}
			
			protected abstract EntityLayerIdentity createEntityInstance();
			
		}
		
	}
	
}
