{\rtf1\ansi\ansicpg1252\deff0\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\lang7\b\f0\fs28 Jetstream JET-55 On-The-Fly-Backupfunktion Entwicklertagebuch\par
\b0\par
2019-02-13\par
\par
Brainstorming:\par
- Kennt ein Zielverzeichnis, in das die Storage Dateien kopiert werden.\par
- Nach dem erfolgreichen Initialisieren der prim\'e4ren Storage Dateien wird abgeglichen, bis wie weit die Storage Dateien schon im Zielverzeichnis sind und ob die vorhandenen konsistent sind. Nur das Head File darf unvollst\'e4ndig im Backup vorhanden sein.\par
- In der prim\'e4ren Storage vorhandene Dateien bzw. Teile des Head Files, die noch nicht im Backup Verzeichnis vorhanden sind, werden in die Backup Queue (siehe unten) eingereiht. \par
- Write Listener umbauen zu Write Wrapper\par
- BackuppingWriteWrapper registriert jeden Write in einer Backup Queue.\par
- wichtig: jedes dabei beteiligte file bekommt seinen use count inkrementiert, damit es nicht vor dem backup schreiben weggel\'f6scht wird.\par
- Die backup Queue wird von einem dedizierten Backup Thread (einer f\'fcr alle Channels) abgearbeitet.\par
- Direktes Backupping im Channel Thread wird erst mal nicht implementiert.\par
- Ein backup Item abzuarbeiten dekrementiert den use count des betreffenden Files.\par
- Transaction Eintr\'e4ge m\'fcssen genauso gebackupt werden\par
- Das TypeDictionary muss unabh\'e4ngig von den Daten gebackupt werden. Das w\'e4re dann nur "zuf\'e4llig" das selbe Verzeichnis.\par
\par
- Jeder zu kopierende Bereich wird optional (!) vom Backup Thread durchiteriert (nur entity zu entity, nicht die inhalte), um sicherzugehen, dass wirklich ein konsistentes backup raus kommt.\par
\par
\par
Jetzt einlesen in bestehenden Code. Das mit dem Umbau zum Wrapper k\'f6nnte gar nicht so einfach sein, weil die Aktionen verteilt sind \'fcber mehrere Methoden f\'fcr eigentliche Ausf\'fchrung und f\'fcr Commit.\par
Oder evtl. muss ja dann das mit ge\'e4ndert werden.\par
\par
Es m\'fcsste eigentlich reichen, einen Wrapper f\'fcr StorageFileWriter zu bauen. Dazu bissl konsolidieren.\par
\par
Wrapper bauen. Sieht gut aus.\par
Gut w\'e4r, wenn die write Methode gleich die neue L\'e4nge zur\'fcckgeben w\'fcrde.\par
Dann ist aber die Frage, warum das .force() im write auskommentiert ist und in die Aufrufersteller verschoben worden ist. Das passt doch da hin.\par
Seltsam. Muss ich recherchieren.\par
Hm. Es werden head file und transaction file auf einmal geflusht. Aber warum? In der Zwischenzeit k\'f6nnten einwandfrei vollst\'e4ndig geschriebene Daten verloren gehen.\par
Naja gut: Die Daten sind eh erst gesichert, wenn auch das transaction file sicher geschrieben worden ist. Vorher werden die beim Neustart verworfen.\par
\par
Andererseits: Mittelfristig wird das transaction file eh raus fliegen und durch inlined chunk headers ersetzt werden. Dann ist es eh nur noch ein monolithischer write.\par
Also den Flush wieder da rein ziehen.\par
\par
Der WriteListener kann dann ganz raus.\par
Hm, aber die folgenden Methoden als Varianten in den WriteWrapper zu \'fcbernehmen w\'e4r sinnvoll:\par
\par
public void registerStore(StorageDataFile<?> dataFile, long offset, long length);\par
public void registerTransfer(StorageDataFile<?> dataFile, long offset, long length);\par
public void registerDelete(StorageDataFile<?> dataFile);\par
public void registerCreate(StorageDataFile<?> dataFile);\par
public void registerTruncate(int channelIndex);\par
\par
plus eigentlich auch einen import. Das ist weder ein store aus der Anwendung noch ein housekeeping transfer, sondern was eigenes\par
\par
\par
2019-02-14\par
\par
Varianten einbauen.\par
\par
Oh, dabei interessanten Sonderfall entdeckt:\par
Es gibt die M\'f6glichkeit, eine Datenbank komplett zu l\'f6schen. Also ein "truncate" f\'fcr den ganzen Channel (und das in jedem Channel).\par
Im bisherien Write Listener war das die Methode "registerTruncate".\par
Im Writer gabs das bisher nicht bzw. nur eine truncate Methode f\'fcr eine Datei, die f\'fcr mehrere aufgerufen wurde.\par
Wenn jetzt der WriteListener raus fliegt und dessen Aufgabe vom Writer mit \'fcbernommen wird, braucht der so einen anonsten effektlose "registerChannelTruncation" Methode (bissl besser benannt).\par
Das ist schon mal ein Sonderfall.\par
Aber das wirklich interessante ist:\line Was soll eine Backup Logik in so einem Fall machen?\par
Das Backup l\'f6schen? Wohl kaum. Das ist ja ein Backup.\par
Wenn es aber nicht gel\'f6scht wird, dann w\'fcrden ab da Original und Backup zueinander inkonsistente Dateinamen usw. haben. Das geht auch nicht.\par
Hm...\par
\par
Ich hab das mal durchgedacht und sehe nur folgende zwei M\'f6glichkeiten:\par
1.) Als Konsequenz aus dem Konflikt die truncate Funktionalit\'e4t entfernen\par
2.) Bei einem Truncate alle Backup Dateien in einen speziall benannten Order (etwa "Truncation_2019-02-14") verschieben.\par
\par
F\'fcr #1 spricht:\par
- Es ist kein nennenswerter Aufwand, vermeidet sogar Programmieraufwand und zuk\'fcnftig Wartung von Code.\par
- So ein special Ordner f\'fcr #2 w\'fcrde evtl. unerwartete Probleme erzeugen.\par
- Aber vor allem: Diese Funktion wird, soweit absehbar, eh nicht benutzt und wenn man wirklich seine ganze Datenbank truncaten will, dann nullt man die Root Referenz aus und speichert einmal ab.\par
\par
F\'fcr #2 spricht:\par
- Naja, das es schon ein cooles Feature w\'e4re, wenn man mal in die Situation k\'e4me, dass man genau das br\'e4uchte. Aber siehe oben. \'c4u\'dferst unwahrscheinlich und sehr leicht implizit nachbildbar.\par
\par
Also hier keine sinnlose Flei\'dfarbeit anfangen, sondern die truncation einfach l\'f6schen. Fertig.\par
\par
Hm. Es gibt ein Argument daf\'fcr: Testing.\par
Aber andererseits: man m\'fcsste sich f\'fcr das Resetten von State auf eine komplexe interne Methode verlassen.\par
Wenn man einfach nur die Storage stopt, alle Dateien l\'f6sche und die Storage wieder startet, hat man genau den gleichen Effekt, nur ohne komplexe Logik.\par
Also ich lass die entscheidende Methode mit der Logik mal auskommentiert mit einem Kommentar daneben drin. Die restlichen Methoden zum Task erzeugen usw. l\'f6sch ich mal.\par
\par
\par
Weiter mit der Implementierung der eigentlichen Backup Logik:\par
Wrapping Provider bauen.\par
\par
Interessant: Die Backup Logik braucht ja bei Transfers 2 Files: source und target.\par
Mal sehen, ob das trotzdem mit einer einheitlichen Logik gemacht werden kann...\par
Hm...\par
\par
Also bei Transfer ist es einfach: SourceFile und TargetFile. F\'fcr beide wird das \'c4quivalent im Backup Verzeichnis gesucht und dann die Aktion repliziert.\par
Bei Store wird das storage-TargetFile zum backup-SourceFile. Das wird zu dem gleichnamigen im Backup aufgel\'f6st und dann die Aktion repliziert. Ein TargetFile gibt es beim storen nicht.\par
\par
Am Rande f\'e4llt mir wieder mal auf: es w\'e4re alles so viel einfacher, wenn es die Transfers nicht mehr g\'e4be. Achja und die Transaction Files auch nicht mehr.\par
\par
A propos: Writes in das Transaction File m\'fcssen ja auch noch enqueuet werden.\par
\par
\par
2019-02-15\par
\par
Weitermachen:\par
Transaction File Eintr\'e4ge auch noch in Backupping FileWriter.\par
Hm. Truncate von Datei ist wieder Sonderfall. Aber der muss diesmal mit rein. Zweite Methode machen, hilft nix.\par
\par
Bissl aufr\'e4umen.\par
\par
Jetzt StorageBackupHandler und die Queue, Items, daf\'fcr usw. bauen.\par
\par
Hm, knifflig:\par
F\'fcr jeden Channel eine Queue machen ist problematisch, weil dann der BackupHandler Thread nicht mehr einfach auf das n\'e4chste Item warten kann.\par
Da m\'fcsste ultra kompliziert ein bisschen gewartet und dann die anderen channels gecheckt werden.\par
Viel besser w\'e4re, wenn alle Channels in dieselbe Queue reinenqueuen. Dann ist blo\'df wieder das Problem, dass der Channelkontext fehlt.\par
Der Channelkontext k\'f6nnte implizit mit\'fcbergeben werden, wenn jedes File mindestens StorageLockedChannelFile w\'e4re. Dann kann man sich den channel rausziehen.\par
Das trifft aber bei imports nicht zu.\par
Hm. Oder eigentlich muss man bei einem Import das Quellfile gar nicht \'fcbergeben, sondern nur das Storage-Zielfile als Quellfile f\'fcr das Backup.\par
Auf jeden Fall ist das Quellfile f\'fcr die Backup-Kopieraktion IMMER ein ChannelFile. Das w\'fcrde passen. Mal so umbauen.\par
\par
\par
\par
2019-02-16\par
\par
Initialisierungsmethode bauen.\par
Hm. F\'fcr die Initialisierung brauch ich sowieso eine Inventar-Map. Dann kann ich die gleich mitpflegen und damit die st\'e4ndigen (teuren) File Instanzierungen sparen.\par
Also Inventarmethode bauen. Bzw. erst mal in Storage Initialisierung reinschauen, weil die dort auch schon drin sein muss.\par
Hm. Und dann k\'f6nnt ich gleich eine Channel-Verwaltungsklasse bauen, bevor ich tausend sachen in einzelnen redundanten Channel-Arrays halte.\par
Hm... sollten backup files gelockt sein, oder nicht?\par
\par
Ne. Extra BackupFile machen. Daf\'fcr Interfaces bissl umbauen.\par
Dass es neben nummerierten Files auch noch das Transaction File gibt ist nervig ...\par
\par
\par
2019-02-17\par
\par
Angefangene Baustellen implementieren ...\par
\par
Der StorageFileProvider providet nat\'fcrlich LockedFiles f\'fcr die Verwendung im Storage Verzeichnis, die ich f\'fcr das Backup Verzeichnis aber nicht brauchen kann.\par
Aber von der Logik her sollte es durchaus ein StorageFileProvider sein.\par
\par
Hm.\par
Also muss ich das zerlegen:\par
Entweder der Provider liefert ein schlichteres, f\'fcr beide F\'e4lle kompatibleres File und das wird dann f\'fcr die Storage-Verwendung nochmal gewrappt, oder es gibt einen wrappenden FileProvider, der den schlichteren wrappt.\par
Ersteres w\'e4r mir lieber, mal recherchieren ...\par
\par
Das extern wrappen nicht, weil der provider direkt die FileTyp-Instanz zur\'fcckgibt, die gebraucht wird.\par
Aber ich kann eine Implementierung ohne Lock machen, die dann mit einer lock() Methode eine Instanz einer Implementierung mit Lock zur\'fcckgibt.\par
So gehts!\par
\par
\par
Durch ein paar Umstrukturierungen ist StorageInventoryFile jetzt das gleiche wie StorageLockedChannelFile nur mit einem anderen Namen.\par
Und der andere Name st\'f6rt bei den Methodensignaturen.\par
Also muss ich das noch konsolidieren.\par
\par
So. Jetzt sieht das alles schon recht ordentlich aus. Noch ein paar TODOs in den neuen Backup-Klassen, und dann gehts an die eigentliche Backup-Logik.\par
\par
\par
\par
2018-02-18\par
\par
Ich hab die Eintr\'e4ge f\'fcr diesen Tag ganz vergessen.\par
War aber nicht so viel.\par
Neben Timeline nachtragen, Bonus Standup Meeting, Brainstorming zu Produktnamen und -logo und Besprechung mit MK dazu hab ich halt die JET-55 TODOs bissl weitergemacht und Methoden konsolidiert.\par
\par
\par
\par
2018-02-19\par
\par
Weitermachen:\par
#fillEmptyBackup konsolidieren mit FileManager#readStorage\par
Achso, das geht nicht, wegen unterschiedlichen File Typen. Dann redundant bauen, macht ja nix.\par
\par
\par
\par
16:30\par
So, nach Glasschiebet\'fcr, Griffe der anderen T\'fcren durchgehen, Wasserwart, Rumtesten zu M\'e4ngeln der Glasschiebet\'fcr, Mangelmeldung Mail an Bautr\'e4ger, mach ich jetzt, 6 Stunden sp\'e4ter, wieder weiter.\par
\par
So ein BackupFile braucht irgendwoher ja dann auch mal einen Channel.\par
Aber die deswegen jetzt doch wieder auf die normale StorageFile Implementierung mit permanent gelocktem und offenem Channel \'e4ndern, w\'e4r doof.\par
Besser: FileChannel, bzw. FileLock, wird on demand ge\'f6ffnet und nach dem kopieren wieder geschlossen.\par
Implementieren. Konsolidieren mit bisherigen File Implementierungen.\par
\par
Initialisierung bauen.\par
API verbessern.\par
FIXMEs aufr\'e4umen.\par
Problem handling an allen Stellen einbauen.\par
\par
\par
2018-02-20\par
\par
Jetzt bau ich mal so einen Problemhandler, damit die ganzen TODOs verschwinden.\par
\par
Hm. Eigentlich ist es ungeschickt bzw. sogar logisch falsch. so einen problem handler tief in die Logik reinzuweben.\par
Beispiel:\par
\par
- \'e4u\'dferster Methodenaufruf (1)\par
-- enthaltener Methodenaufruf (2)\par
--- enthaltener Methodenaufruf (3)\par
\par
In (3) wird auf ein spezifisches Problem gepr\'fcft und an den Problemhandler gemeldet. Der oder sp\'e4testens eine Fallback-Logik danach muss eine Exception werfen, damit der Vorgang sauber abgebrochen wird.\par
In 1, 2 und 3 k\'f6nnen aber auch noch andere Probleme auftreten. Also muss ganz au\'dfen in (1) sowieso ein allgemeines try-catch rein, das im catch jegliche Exception an den Problem Handler reportet.\par
F\'fcr den beschriebenen spezifischen Fall hei\'dft das aber: Der Problem handler kriegt dasselbe Problem zweimal reportet, sogar seine eigene Exception.\par
Das ist mindestens ungeschickt, streng genommen sogar logisch falsch.\par
\par
Die richtige L\'f6sung ist:\par
- Problem Reporting nur in den "\'e4u\'dfersten" Methoden, die ansonsten m\'f6glichst klein ist und an innere Methoden delegiert.\par
- Innere Methoden werfen bei Problemen Exceptions, in denen der relevante State (meist Refrenzen auf die problemausl\'f6senden Instanzen) vermerkt wird.\par
- Das Problem Reporting zieht sich dann aus den Exceptions den n\'f6tigen state f\'fcr bestimmte Reporting-Methoden raus.\par
\par
Hm. Oder sollte einfach die blanke Exception weitergereicht werden? Der State ist ja mit drin. Dann m\'fcsste halt in der Empf\'e4nger-Logik ein instanceof-Baum oder ein Type-Mapping drin sein.\par
Jup. So mach ich das.\par
Entsprechend umbauen.\par
\par
\par
\par
2018-02-21\par
\par
Jetzt fehlen noch:\par
1.) ProblemHandler Implementierung bauen und entsprechend auf die Channel-Threads r\'fcckwirken lassen.\par
2.) Foundation Klasse erweitern.\par
3.) copy und truncate Methode implementieren.\par
4.) Testen, nat\'fcrlich, wie \'fcblich.\par
5.) Evtl. gleich so eine Validierungslogik bauen, die die frisch geschriebenen Teile der Backup Dateien validiert.\par
\par
Punkt #1 planen und implementieren.\par
\par
Daf\'fcr muss der StorageChannelController erweitert werden um eine Funktionalit\'e4t, fatale Exceptions zu registrieren und sobald die nicht leer sind, wirft der die in den ChannelThreads weiter.\par
\par
Achja und den Thread an sich muss ich ja auch noch irgendwo starten.\par
Das ist der BackupHandler. Der muss dann aber noch anhand des ChannelControllers checken, ob er laufen soll.\par
Hm... braucht es dann \'fcberhaupt den eingeschobene Mini-Typ ExceptionHandler? Der BackupHandler kann ja eigentlich gleich direkt dem ChannelController auftretende exceptions \'fcbergeben...\par
Rausschmeissen.\par
Passt.\par
\par
Jetzt mal zur Verkabelung des ganzen:\par
Foundaten Erweiterung bauen.\par
Es reicht eigentlich, einen StorageFileProvider backupFileProvider dort zu setzen. Wenn es einen gibt, werden die restlichen Teile referenziert bzw. bei Bedarf erstellt.\par
So bau ich das mal.\par
\par
Paar Details:\par
Der StorageBackupHandler braucht noch einen Threadnamen, nat\'fcrlich mit einem Defaultwert.\par
Und es muss auch noch so einen "gravedigger" Mechanismus f\'fcr gel\'f6schte Dateien geben.\par
Denn es muss doch m\'f6glich sein, im Backupverzeichnis Dateien zu l\'f6schen, sonst w\'fcrde eine kleine Datenbasis mit vielen stores eine gigantische Menge an Backupplatz belegen.\par
Darum steuerbar \'fcber ein Verzeichnis:\par
Selbes Verzeichnis -> lassen.\par
Andere Verzeichnis -> verschieben.\par
Kein Verzeichnis -> l\'f6schen.\par
\par
Bl\'f6d ist nur, dass ich das wieder direkt als File machen m\'fcsste, aber eigentlich will ich das ja abstrahieren.\par
Hm, oder ich mach einen String Verzeichnisnamen f\'fcr das Unterverzeichnis.\par
\par
Mit den zus\'e4tzlichen Variablen muss aber ein neuer Typ "StorageBackupConfiguration" her, der das alles h\'e4lt.\par
Dann f\'e4llt immerhin gleich die Zweideutigkeit mit dem normalen StorageFileProvider weg, nice.\par
\par
So. BackupConfiguration gebaut. Foundation erweitert. FIXMEs zum integrieren ins Starten der Storage Threads geschrieben, usw.\par
\par
Das w\'e4rs mal f\'fcr den Moment...\par
\par
\par
2019-02-22\par
\par
Besser als ein plain ThreadName mit hardgecodeter Thread Instanzierung w\'e4re ein ThreadProvider.\par
Genauso l\'e4uft das ja bei den ChannelThreads auch.\par
Also aktuellen ThreadProvider umbenennen zu ChannelThreadProvider und per copy&paste einen BackupThreadProvider bauen.\par
Hm. Und damit die Zahl der Felder im StorageManager nicht unn\'f6tig explodiert wrap ich beides jetzt wieder in einem allgemeinen ThreadProvider.\par
Hehe.\par
\par
Storage-Konstrukturmethoden f\'fcr BackupConfiguration bauen.\par
\par
BackupHandler Erstellung bauen.\par
\par
Einbauen in Storage Start.\par
\par
Das war jetzt alles bissl knifflig durch die verschiedenen Methoden und Instanzen, \'fcber die das verteilt ist.\par
StorageBackupConfiguration umbenannt zu StorageBackupSetup und um ein paar entsprechende setup~ Methoden erweitert, um das sauber zu l\'f6sen.\par
\par
Damit w\'e4ren jetzt nur noch die drei Item-Handling-Logik Methoden \'fcbrig, dann ist das Backup (ohne Validierung) fertig zum testen.\par
\par
\par
2019-02-23\par
\par
Item-Handling-Logik Methoden implementieren.\par
\par
Und gleich wieder was aufgefallen:\par
Eigentlich ist es Quatsch, die Information f\'fcr das Deleted-Verzeichnis au\'dferhalb zum FileProvider zu halten und durch die Abstraktion st\'e4ndig Probleme zu haben.\par
Viel simplere und elegantere L\'f6sung:\par
Der FileProvider providet auch die DeletedFiles und dort kann man dann hin moven. Da Waaahnsinn. D\'e4mlich, dass ich da nicht gleich drauf gekommen bin.\par
Mal so umbauen ...\par
}
 