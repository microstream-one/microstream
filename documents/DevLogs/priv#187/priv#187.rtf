{\rtf1\ansi\ansicpg1252\deff0\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\lang7\f0\fs28 2020-03-30\par
\par
Jetzt komm ich endlich mal dazu, mich \'fcber wieder-einlesen (und dann wieder-wieder-einlesen) hinaus mit dieser Thematik zu befassen.\par
Also die Issues #185, #186, #187 sind letztendlich das gleiche. Ich f\'fcr das mal alles unter #187.\par
\par
Also eigentlich sollte es reichen, bei dem priv#186 marker noch einen lookup auf eine Table zu machen.\par
\par
Hm. Die Frage ist aber, in welcher Reihenfolge.\par
Wenn man einfach nur eine Table von vorne bis hinten durchl\'e4uft, k\'f6nnen sich unl\'f6sbare Reihenfolgekonflikte von interfaces in der multiple-inheritence Hierarchie ergeben.\par
Besser w\'e4re wohl: Die Interfaces der Klasse geben lassen und dann von vorne bis hinten durchlaufen und einen konkreten Lookup in die Table machen.\par
Falls nicht gefunden wird, dann die erste hierarchiestufe aller implementierten Interfaces, dann die zweite, usw.\par
Das ist nicht schlecht. Das mach ich so.\par
\par
Dann muss es daf\'fcr nat\'fcrlich noch eine neue TypeHandler-Mapping- und -Registrierungs-Infrastruktur geben.\par
Das sollte dann eigentlich schon alles sein.\par
\par
Dann bau ich noch das aktuell hardgecodete Collection handling auf dieses Mapping um.\par
\par
Und dann schlie\'dflich noch den BinaryTypeHandlerPath fertig.\par
\par
Dann sollten die drei Issues erledigt sein.\par
\par
\par
Ah, knifflig k\'f6nnte noch der Lookup aus dem TypeDictionary werden. Oder evtl. l\'e4uft das ganz nat\'fcrlich dahin oder evtl. nur mit 1 internem lookup mehr in der entsprechenden Methode, mal sehen.\par
\par
Also mal implementieren ...\par
\par
Erst mal einen PersistenceAbstractTypeHandlerLookup<D, T> typ definieren und in den TypeHandlerCreator reinh\'e4ngen.\par
Warum in den Creator? Weil der TypeHandlers f\'fcr konkrete Typen erzeugt.\par
Hm... Moment ... ne ... Wenn der f\'fcr konkrete Klassen TypeHandlers erzeugt, dann werden ja wieder Instanzen von konkreten Klassen erzeugt ...\par
Also ne, das darf tats\'e4chlich nur ein Lookup sein, den den TypeHandler f\'fcr den abstrakten Typ rausgibt.\par
Toll, dann revert ich die \'c4nderung am Creator gleich wieder ... :[\par
\par
Aber Moment:\par
Dann geht ".getClass()" f\'fcr den Lookup der TypeId nicht mehr. Wenn man die TypeId des abstrakten Handlers f\'fcr die konkrete Klasse registriert, dann h\'e4tten mehrere konkrete Klassen dieselbe TypeId, was nicht sein darf.\par
*kopfkratz*\par
Geht das dann \'fcberhaupt?\par
\par
Mal genauer \'fcberlegen:\par
\par
Class -> TypeId\par
TypeId -> Class\par
Class -> TypeHandler\{Class, TypeId\}\par
TypeId -> TypeHandler\{Class, TypeId\}\par
\par
bisher sind die alle ein-eindeutig.\par
\par
Ne, genau, jetzt wei\'df ichs: Es muss ZWEI lookup f\'fcr bereits BEKANNTE Types geben:\par
1.) Ein-eindeutiger Lookup f\'fcr die konkrete Klasse f\'fcr den TypeHandler\par
2.) Wenn nichts gefunden, dann zweiter (neuer) Lookup: Klasse-zu-abstraktem-TypeHandler\par
\par
Aber ist das dann nicht wieder der gleiche Konflikt?\par
Hm.\par
Ich glaub der Trick m\'fcsste sein: Es gibt f\'fcr eine Klasse von #2 einen TypeHandler, aber es gibt keinen TypeId-Mapping-Eintrag.\par
\par
Das klappt dann von der TypeHandler-Managing-Logik her, aber klappt es auch von der Type-Handling Logik her?\par
Nicht dass es dann irgendwo beim Datensatz-TypeId-Validieren oder beim TypeDictionary einlesen oder sowas einen fehlenden Type-Eintrag gibt.\par
Hm, aber Moment: In BEIDEN F\'e4lle (bzw. allen) w\'e4re das ja dann nur der abstrakte Typ und f\'fcr den gibt es sehr wohl einen Eintrag.\par
\par
Achja: Es gibt auch noch abstrakte Klassen. Wie sollten die iteriert werden im Vergleich zu interfaces?\par
Ich denke:\par
- erst die direkt abgeleitete abstrakte Klasse\par
- dann alle direkt implementierten interfaces\par
- dann Ebene f\'fcr Ebene erst Klasse, dann interfaces\par
\par
\par
2020-03-31\par
\par
Also mal schauen, ob ich das direkt in die PersistenceCustomTypeHandlerRegistry reinbau, oder ob das zweite Mapping ein extra Typ sein muss.\par
\par
\cf1 UFF... da f\'e4llt mir gerade ein: Legacy Type Mapping br\'e4uchte ja dann auch eine entsprechende Behandlung daf\'fcr.\par
Also ich glaub das mach ich erst mal wie collections: Explizite Exception, dass der Fall noch nicht unterst\'fctzt wird.\cf0\par
\par
\par
Bei der Orientierung zur Implementierung im Code (PersistenceCustomTypeHandlerRegistry) ist mir aufgefallen:\par
"registerTypeHandler(Class<T> type, PersistenceTypeHandler<D, T> typeHandler)" ist mit der Erweiterung nicht mehr richtig. Das muss jetzt <D, ? super T> sein.\par
Mal ausprobieren per Code.\par
Jup, klar, Compilerfehler.\par
\par
Uff, das gilt dann auch f\'fcr "PersistenceTypeHandler<D, T> lookupTypeHandler(Class<T> type)".\par
Das f\'fchrt dann wieder zu Folge-Typisierungsproblemen bei der Handler Verwendung.\par
Wobei ... irgendwo ist mal ein "harter" Cast drin, der das auf "Object" umbiegt, weil es durch die Generizit\'e4t der Logik nicht anders geht. Evtl. verl\'e4uft sich das Problem dort dann.\par
Muss ich dann testen und schauen, wie es wird...\par
\par
Und mir ist aufgefallen: da das registerTypeHandler Teil der public API ist, sollte vielleicht noch eine validierung rein, ob der TypeHandler wirklich zu dem Typ passt.\par
Sp\'e4testens mit der Erweiterung aber mit "isAssignableFrom".\par
\par
Also erst mal die API \'fcberall durch\'e4ndern in Interfaces und Klassen.\par
Hm, hat ganz gut geklappt.\par
\par
Validierung mach ich gleich als Methode von PersistenceTypeHandler, nicht als lokal hardgecodete Logik. Mit defaultimplementierung Class#isAssignableFrom.\par
Mit bissl aufr\'e4umen, ordentlichen Kommentaren und entsprechendem \'dcberlegen dazu hat das jetzt ewig gedauert, lol.\par
\par
\par
N\'e4chster Schritt: Schauen, wo ich die Registrierung reinbauen muss.\par
Mir ist n\'e4mlich aufgefallen: PersistenceCustomTypeHandlerRegistry#registerTypeHandler mit Class wird gar nicht aufgerufen.\par
Okay, das ist nat\'fcrlich nur optional f\'fcr eben custom Implementierungen. Aber nicht nur. Es gibt ja auch die vordefinierten Custom Handlers. Aber die benutzen dann die andere Variante ohne Class.\par
Aber mal anders rum:\par
Was ruft der TypeHandlerManager zum registrieren auf? Die Variante mit oder ohne Class?\par
\par
Antwort: #registerTypeHandler ohne Class.\par
Es, \'e4h, gibt n\'e4mlich die Variante mit Class gar nicht. Das ist ja n\'e4mlich nicht eine custom registry, sondern PersistenceTypeHandlerRegistry.\par
Die hat nur die Variante ohne Class. Das ist normal auch ganz richtig so. Der TypeHandler bringt ja seinen EntityType mit und wieso sollte man da nochmal was anders machen?\par
Das macht intern nat\'fcrlich erst mal die Registrierung von Type<->TypeId bei der TypeRegistry.\par
Und genau hier ist der Punkt, wo es f\'fcr das neue Konzept anders werden muss:\par
Es gibt dann ein bis mehrere Klassen, die auf denselben TypeHandler gemappt werden, auch wenn der vielleicht schon registriert ist.\par
Warum muss das da rein und nicht als extra Map in den TypeHandlerManager?\par
Antwort: Damit es weiterhin nur 1 Lookup ist. Nach dem einen Lookup muss feststehen: Gibts schon, weiter oder gibts noch nicht, also zur Verf\'fcgung stellen (custom lookup oder dynamisch erzeugen).\par
\par
Es muss dann also eine zus\'e4tzliche Methode geben mit Class Parameter. Und die registriert dann erst mal den \'fcbergebenen TypeHandler inklusive Type<->Id mapping und dann, sozusagen "One-Way" auch noch den TypeHandler f\'fcr den explizit \'fcbergebenen Type.\par
Achso, aber dann wieder mit Validierung durch den TypeHandler.\par
Oder... Moment ... sollte der TypeHandler an sich \'fcberhaupt registriert werden? Also soll der Typ Path an sich auch auf den TypeHandlerPath gemappt werden?\par
Hm. Von der Verwendung her nicht. Aber vom TypeDictionary her schon. Also ja, doch, muss schon sein.\par
\par
Eigentlich braucht es echt nur eine neue Methode mit Class Parameter sein, Validierung, die bisherige aufrufen und dann den TypeHandler f\'fcr die \'fcbergebene Class auch nochmal registrieren.\par
Dann werden aber halt nat\'fcrlich "this.handlersByType" und "this.handlersByTypeId" zueinander inkonsistent. Es gibt einen Type Eintrag, aber keinen TypeId eintrag. Denn der Type hat gar keine TypeId, weil das die des abstrakten Typs wird.\par
Uiuiui. hoffentlich macht das wirklich nirgens ein Problem.\par
\par
Achja und vorher noch eine Validierung, ob es f\'fcr den \'fcbergebenen Typ nicht schon eine Registrierung gibt.\par
\par
Jup, das m\'fcsste dann passen.\par
\par
\par
2020-04-01\par
\par
Also schnell die zweite Methoden implementieren, dann ist das fertig.\par
April april!\par
Oder vielleicht auch nicht. Na gut: Den Algorithmus zum durchlaufen der Supertyp-Hierarchien brauch ich noch, aber das wird nicht so der gro\'dfe Akt. Das ist eine triviale Methode ohne Design-Auswirkungen.\par
\par
Paar Umstrukturierungen:\par
- #putMapping -> #synchPutFullMapping & #synchPutTypeMapping\par
- Validierungslogik auslagern in #validateAlreadyRegisteredTypeHandler und in beiden Methoden verwenden.\par
\par
Oh ... in PersistenceTypeHandlerManager fehlt in #unvalidatedRegisterTypeHandler das lock ...\par
\'c4h ... nachtragen. Ganze Klasse durchchecken, ob/wo es noch fehlt.\par
\par
\par
\par
}
 