{\rtf1\ansi\ansicpg1252\deff0\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\lang7\f0\fs28 2020-03-30\par
\par
Jetzt komm ich endlich mal dazu, mich \'fcber wieder-einlesen (und dann wieder-wieder-einlesen) hinaus mit dieser Thematik zu befassen.\par
Also die Issues #185, #186, #187 sind letztendlich das gleiche. Ich f\'fcr das mal alles unter #187.\par
\par
Also eigentlich sollte es reichen, bei dem priv#186 marker noch einen lookup auf eine Table zu machen.\par
\par
Hm. Die Frage ist aber, in welcher Reihenfolge.\par
Wenn man einfach nur eine Table von vorne bis hinten durchl\'e4uft, k\'f6nnen sich unl\'f6sbare Reihenfolgekonflikte von interfaces in der multiple-inheritence Hierarchie ergeben.\par
Besser w\'e4re wohl: Die Interfaces der Klasse geben lassen und dann von vorne bis hinten durchlaufen und einen konkreten Lookup in die Table machen.\par
Falls nicht gefunden wird, dann die erste hierarchiestufe aller implementierten Interfaces, dann die zweite, usw.\par
Das ist nicht schlecht. Das mach ich so.\par
\par
Dann muss es daf\'fcr nat\'fcrlich noch eine neue TypeHandler-Mapping- und -Registrierungs-Infrastruktur geben.\par
Das sollte dann eigentlich schon alles sein.\par
\par
Dann bau ich noch das aktuell hardgecodete Collection handling auf dieses Mapping um.\par
\par
Und dann schlie\'dflich noch den BinaryTypeHandlerPath fertig.\par
\par
Dann sollten die drei Issues erledigt sein.\par
\par
\par
Ah, knifflig k\'f6nnte noch der Lookup aus dem TypeDictionary werden. Oder evtl. l\'e4uft das ganz nat\'fcrlich dahin oder evtl. nur mit 1 internem lookup mehr in der entsprechenden Methode, mal sehen.\par
\par
Also mal implementieren ...\par
\par
Erst mal einen PersistenceAbstractTypeHandlerLookup<D, T> typ definieren und in den TypeHandlerCreator reinh\'e4ngen.\par
Warum in den Creator? Weil der TypeHandlers f\'fcr konkrete Typen erzeugt.\par
Hm... Moment ... ne ... Wenn der f\'fcr konkrete Klassen TypeHandlers erzeugt, dann werden ja wieder Instanzen von konkreten Klassen erzeugt ...\par
Also ne, das darf tats\'e4chlich nur ein Lookup sein, den den TypeHandler f\'fcr den abstrakten Typ rausgibt.\par
Toll, dann revert ich die \'c4nderung am Creator gleich wieder ... :[\par
\par
Aber Moment:\par
Dann geht ".getClass()" f\'fcr den Lookup der TypeId nicht mehr. Wenn man die TypeId des abstrakten Handlers f\'fcr die konkrete Klasse registriert, dann h\'e4tten mehrere konkrete Klassen dieselbe TypeId, was nicht sein darf.\par
*kopfkratz*\par
Geht das dann \'fcberhaupt?\par
\par
Mal genauer \'fcberlegen:\par
\par
Class -> TypeId\par
TypeId -> Class\par
Class -> TypeHandler\{Class, TypeId\}\par
TypeId -> TypeHandler\{Class, TypeId\}\par
\par
bisher sind die alle ein-eindeutig.\par
\par
Ne, genau, jetzt wei\'df ichs: Es muss ZWEI lookup f\'fcr bereits BEKANNTE Types geben:\par
1.) Ein-eindeutiger Lookup f\'fcr die konkrete Klasse f\'fcr den TypeHandler\par
2.) Wenn nichts gefunden, dann zweiter (neuer) Lookup: Klasse-zu-abstraktem-TypeHandler\par
\par
Aber ist das dann nicht wieder der gleiche Konflikt?\par
Hm.\par
Ich glaub der Trick m\'fcsste sein: Es gibt f\'fcr eine Klasse von #2 einen TypeHandler, aber es gibt keinen TypeId-Mapping-Eintrag.\par
\par
Das klappt dann von der TypeHandler-Managing-Logik her, aber klappt es auch von der Type-Handling Logik her?\par
Nicht dass es dann irgendwo beim Datensatz-TypeId-Validieren oder beim TypeDictionary einlesen oder sowas einen fehlenden Type-Eintrag gibt.\par
Hm, aber Moment: In BEIDEN F\'e4lle (bzw. allen) w\'e4re das ja dann nur der abstrakte Typ und f\'fcr den gibt es sehr wohl einen Eintrag.\par
\par
Achja: Es gibt auch noch abstrakte Klassen. Wie sollten die iteriert werden im Vergleich zu interfaces?\par
Ich denke:\par
- erst die direkt abgeleitete abstrakte Klasse\par
- dann alle direkt implementierten interfaces\par
- dann Ebene f\'fcr Ebene erst Klasse, dann interfaces\par
\par
\par
2020-03-31\par
\par
Also mal schauen, ob ich das direkt in die PersistenceCustomTypeHandlerRegistry reinbau, oder ob das zweite Mapping ein extra Typ sein muss.\par
\par
\cf1 UFF... da f\'e4llt mir gerade ein: Legacy Type Mapping br\'e4uchte ja dann auch eine entsprechende Behandlung daf\'fcr.\par
Also ich glaub das mach ich erst mal wie collections: Explizite Exception, dass der Fall noch nicht unterst\'fctzt wird.\cf0\par
\par
\par
Bei der Orientierung zur Implementierung im Code (PersistenceCustomTypeHandlerRegistry) ist mir aufgefallen:\par
"registerTypeHandler(Class<T> type, PersistenceTypeHandler<D, T> typeHandler)" ist mit der Erweiterung nicht mehr richtig. Das muss jetzt <D, ? super T> sein.\par
Mal ausprobieren per Code.\par
Jup, klar, Compilerfehler.\par
\par
Uff, das gilt dann auch f\'fcr "PersistenceTypeHandler<D, T> lookupTypeHandler(Class<T> type)".\par
Das f\'fchrt dann wieder zu Folge-Typisierungsproblemen bei der Handler Verwendung.\par
Wobei ... irgendwo ist mal ein "harter" Cast drin, der das auf "Object" umbiegt, weil es durch die Generizit\'e4t der Logik nicht anders geht. Evtl. verl\'e4uft sich das Problem dort dann.\par
Muss ich dann testen und schauen, wie es wird...\par
\par
Und mir ist aufgefallen: da das registerTypeHandler Teil der public API ist, sollte vielleicht noch eine validierung rein, ob der TypeHandler wirklich zu dem Typ passt.\par
Sp\'e4testens mit der Erweiterung aber mit "isAssignableFrom".\par
\par
Also erst mal die API \'fcberall durch\'e4ndern in Interfaces und Klassen.\par
Hm, hat ganz gut geklappt.\par
\par
Validierung mach ich gleich als Methode von PersistenceTypeHandler, nicht als lokal hardgecodete Logik. Mit defaultimplementierung Class#isAssignableFrom.\par
Mit bissl aufr\'e4umen, ordentlichen Kommentaren und entsprechendem \'dcberlegen dazu hat das jetzt ewig gedauert, lol.\par
\par
\par
N\'e4chster Schritt: Schauen, wo ich die Registrierung reinbauen muss.\par
Mir ist n\'e4mlich aufgefallen: PersistenceCustomTypeHandlerRegistry#registerTypeHandler mit Class wird gar nicht aufgerufen.\par
Okay, das ist nat\'fcrlich nur optional f\'fcr eben custom Implementierungen. Aber nicht nur. Es gibt ja auch die vordefinierten Custom Handlers. Aber die benutzen dann die andere Variante ohne Class.\par
Aber mal anders rum:\par
Was ruft der TypeHandlerManager zum registrieren auf? Die Variante mit oder ohne Class?\par
\par
Antwort: #registerTypeHandler ohne Class.\par
Es, \'e4h, gibt n\'e4mlich die Variante mit Class gar nicht. Das ist ja n\'e4mlich nicht eine custom registry, sondern PersistenceTypeHandlerRegistry.\par
Die hat nur die Variante ohne Class. Das ist normal auch ganz richtig so. Der TypeHandler bringt ja seinen EntityType mit und wieso sollte man da nochmal was anders machen?\par
Das macht intern nat\'fcrlich erst mal die Registrierung von Type<->TypeId bei der TypeRegistry.\par
Und genau hier ist der Punkt, wo es f\'fcr das neue Konzept anders werden muss:\par
Es gibt dann ein bis mehrere Klassen, die auf denselben TypeHandler gemappt werden, auch wenn der vielleicht schon registriert ist.\par
Warum muss das da rein und nicht als extra Map in den TypeHandlerManager?\par
Antwort: Damit es weiterhin nur 1 Lookup ist. Nach dem einen Lookup muss feststehen: Gibts schon, weiter oder gibts noch nicht, also zur Verf\'fcgung stellen (custom lookup oder dynamisch erzeugen).\par
\par
Es muss dann also eine zus\'e4tzliche Methode geben mit Class Parameter. Und die registriert dann erst mal den \'fcbergebenen TypeHandler inklusive Type<->Id mapping und dann, sozusagen "One-Way" auch noch den TypeHandler f\'fcr den explizit \'fcbergebenen Type.\par
Achso, aber dann wieder mit Validierung durch den TypeHandler.\par
Oder... Moment ... sollte der TypeHandler an sich \'fcberhaupt registriert werden? Also soll der Typ Path an sich auch auf den TypeHandlerPath gemappt werden?\par
Hm. Von der Verwendung her nicht. Aber vom TypeDictionary her schon. Also ja, doch, muss schon sein.\par
\par
Eigentlich braucht es echt nur eine neue Methode mit Class Parameter sein, Validierung, die bisherige aufrufen und dann den TypeHandler f\'fcr die \'fcbergebene Class auch nochmal registrieren.\par
Dann werden aber halt nat\'fcrlich "this.handlersByType" und "this.handlersByTypeId" zueinander inkonsistent. Es gibt einen Type Eintrag, aber keinen TypeId eintrag. Denn der Type hat gar keine TypeId, weil das die des abstrakten Typs wird.\par
Uiuiui. hoffentlich macht das wirklich nirgens ein Problem.\par
\par
Achja und vorher noch eine Validierung, ob es f\'fcr den \'fcbergebenen Typ nicht schon eine Registrierung gibt.\par
\par
Jup, das m\'fcsste dann passen.\par
\par
\par
2020-04-01\par
\par
Also schnell die zweite Methoden implementieren, dann ist das fertig.\par
April april!\par
Oder vielleicht auch nicht. Na gut: Den Algorithmus zum durchlaufen der Supertyp-Hierarchien brauch ich noch, aber das wird nicht so der gro\'dfe Akt. Das ist eine triviale Methode ohne Design-Auswirkungen.\par
\par
Paar Umstrukturierungen:\par
- #putMapping -> #synchPutFullMapping & #synchPutTypeMapping\par
- Validierungslogik auslagern in #validateAlreadyRegisteredTypeHandler und in beiden Methoden verwenden.\par
\par
Oh ... in PersistenceTypeHandlerManager fehlt in #unvalidatedRegisterTypeHandler das lock ...\par
\'c4h ... nachtragen. Ganze Klasse durchchecken, ob/wo es noch fehlt.\par
Paar Stellen nachgetragen.\par
\par
Zur\'fcck zu TypeHandlerRegistry: Zweite Methode bauen.\par
\par
Dann w\'e4r das grunds\'e4tzliche soweit fertig.\par
Morgen eigentlich nur noch die Hierarchie-Methode bauen und \'fcberlegen, wie und wo ich die abstrakten typen \par
\par
\par
2020-04-02\par
\par
\par
Also, wo muss es rein?\par
TODOs durchsuchen.\par
Im TypeHandlerCreator schon mal nicht. Denn der hat keine Referenz auf die bestehenden TypeHandlers. Denn es werden f\'fcr diesen Fall ja keine neuen TypeHandlers erzeugt, sondern nur bestehende assoziiert.\par
Also dort rausschmeissen bzw. TODO ab\'e4ndern.\par
Hm, Moment:\par
F\'fcr Collections m\'fcssen schon neue TypeHandler erzeugt werden. Aber nur vorgefertigte Allgemeine mit vorgefertigtem Type und TypeId.\par
Soll das f\'fcr F\'e4lle wie WindowsPath auch zutreffen? Nein. "WindowsPath" soll niemald im TypeDictionary erscheinen. Instanzen davon sollen wirklich in abstrakter Form gehandelt werden.\par
Hm. Das sind dann doch zwei unterschiedliche F\'e4lle:\par
F\'e4lle wie Collections kriegen eine spezifische Handler Instanz und TypeDict Eintrag, nur mit allgemeiner Struktur.\par
F\'e4lle wie Path kriegen nur ein Mapping auf einen komplett allgemeinen/abstrakten Handler. Ohne eigenen Eintrag.\par
\par
Trotzdem kann man das alles nicht so einfach aus dem TypeHandlerCreator rausziehen:\par
Da ist z.B. der unpersistable check drin.\par
Oder der Check auf Enums.\par
Oder Proxies.\par
Die m\'fcssen alle weiterhin VOR dem check auf einen passenden gehandelten abstrakten Typ sein.\par
Hm...\par
\par
Vielleicht m\'fcssten die ganzen Checks in den nachtr\'e4glich eingef\'fchrten TypeHandlerEnsurer gehen. Der h\'e4tte sogar die CustomTypeHandlerRegistry, die man braucht.\par
Der k\'f6nnte dann auch die Fallunterscheidungen machen f\'fcr Arrays usw.\par
Der Creator w\'e4re dann rein "stur" ein Creator. Der darf nur noch f\'fcr valide Typen aufgerufen werden.\par
Mal schauen, ob das so ginge...\par
\par
Wenn ich das aber zerleg, dann muss der Creator trotzdem wieder alle m\'f6glichen Checks machen, ob der \'fcbergebene Typ valide ist.\par
Hm. Bissl doof und redundant, aber im Sinne saubererer Struktur vielleicht den Aufwand wert.\par
\par
Also der TypeAnalyzer ist bisher halt nur im Creator und wird dort mehrfach verwendet. Aber der unpersistable Check m\'fcsste halt vor dem abstrakten handler lookup kommen.\par
Also m\'fcsste der ensurer den jetzt auch kennen. Das ist dann aber schon wieder so eine verkomplizierung, die sich wirr anf\'fchlt ...\par
\par
Mal von der anderen Seite her gedacht:\par
Der einzige Nutzen des dazwischengeschobenen "TypeHandlerEnsurer"s ist, dass der vor dem create noch einen Lookup in der custom registry macht.\par
\'c4h ... den ... \'e4h ... k\'f6nnte der creator am Anfang auch einfach machen. Dann w\'fcrde der ensurer komplett entfallen.\par
Na gut, es gibt auch einen strukturellen Grund: Auch wenn jemand einen eigenen creator macht, sollte die lookup logik trotzdem gemacht werden. Das macht Sinn.\par
\par
Dann w\'e4re eine M\'f6glichkeit, dass der Ensurer dem Creator einen Callback \'fcbergibt, um an geeigneter Stelle sp\'e4ter nach einem passenden abstrakten TypeHandler zu suchen.\par
Auch irgendwie bl\'f6d, weil so umst\'e4ndlich.\par
\par
Vielleicht ist es doch folgenderma\'dfen am besten:\par
- Creator interface aufbohren auf die verschiedenen Basistypen, ohne irgendwelche Pr\'fcfungen (wer welche will, kann sich ja einen custom handler schreiben)\par
- Pr\'fcfungen alle im ensurer machen, inklusive redundanter Referenz auf den TypeAnalyzer. So redundant ist die n\'e4mlich gar nicht: Hier gehts erst mal um den Type insgesamt, sp\'e4ter im Creator um seine Feldtypen.\par
- Dann kann man in dieser Reihenfolge ganz einfach den abstract-handling-check reinmachen. Und die custom type handler registry daf\'fcr ist auch schon da.\par
\par
So mach ich das jetzt, sonst philosophier ich nur den ganzen Tag lang \'fcber die Softwarearchitektur f\'fcr eine einzelne Methode ... *h\'fcstel*.\par
\par
Noch eine Idee zwischendurch:\par
Das rausfinden eines anwendbaren abstrakten Supertyps kapsel ich als eigenen Typen.\par
So kann man mit relativ wenig aufwand Sonderfallbehandlungen realisieren.\par
Abgesehen davon, dass man sich f\'fcr bestimmte Typen einfach einen CustomTypeHandler registriert (oder so ein derivable Type dings), um der Analyse zuvor zu kommen.\par
Aber trotzdem, dieser Weg mag evtl. nicht dynamisch/flexibel genug sein, darum die Kapselung.\par
\par
\par
In der "Abendpause" ist mir eingefallen: Ne, das geht nicht, weil man ja Typ f\'fcr Typ in der Hierarchie pr\'fcfen muss, ob ein Handler vorhanden ist und wenn ja abbrechen und den nehmen.\par
Man kann eben nicht einfach nur "riechen", welcher abstrakte Supertyp "der richtige" ist und dann f\'fcr den einmal einen Lookup machen.\par
Also die Methode muss in den ensurer rein.\par
\par
Jetzt ist noch die Frage ob vor den Collection check oder danach.\par
Ich denk danach, denn Collections sind so fundamental, die sollte nicht durch irgendwas anderes overridet werden.\par
\par
Jetzt ist nur DARAN wieder das Problem, dass der collection check nach wie vor im creator ist, also bin ich wieder genauso weit wie vorhin:\par
Muss es eine extra collection-handling methode in der public API geben?\par
Hmpfl.\par
\par
Oh, das mit dem extra sucher-Typ geht doch, weil man ja die customhandler registry \'fcbergeben kann.\par
Also wieder mal Foundation Erweiterung Schema-F Strafarbeit...\par
\par
Cool. Dann brauch ich jetzt nur noch die Hierarchie-Durchsuch-Methode bauen, dann sollte es fertig zum testen sein.\par
\par
Oh Mann, das ist gar nicht so einfach:\par
Es gibt:\par
- Aktuelle Klasse (entlang der Klassenvererbung). Easy.\par
- Von der aktuellen Klasse direkt implementierte Interfaces. Auch Easy.\par
Aber dann:\par
- Superinterfaces der implementierten Interfaces. Das ist eine zweite Hierarchieebene "neben" den interfaces der n\'e4chsten Superklasse.\par
- Und die haben ja dann AUCH wieder superinterfaces.\par
\par
Das alles einfach rekursiv durchlaufen ist relativ einfach.\par
Aber Hierarchieebene f\'fcr Hierarchieebene rekursiv durchlaufen ... das sprengt gerade irgendwie die Algorithmus-Vorstellungskraft.\par
\par
\par
\par
2020-04-03\par
\par
Jetzt endlich Algorithmus fertig implementieren.\par
Also es reicht nicht, nur die Klassen durchzulaufen, denn die Interfacehierarchie kann ja "tiefer/h\'f6her" als die der Klassen sein.\par
D.h. der loop muss so lange laufen, bis nix neues mehr dazukommt.\par
\par
So umbauen.\par
\par
Dabei st\'f6rende Detaillogik in Methoden auslagern.\par
Und dabei mal wieder \'fcber die inkompetent unvollst\'e4ndigen Visibility Regeln f\'fcr interfaces aufregen ... grrr...\par
Damit ist der look-body trotz viel Logik relativ h\'fcbsch kompakt.\par
\par
Au\'dferdem noch erkl\'e4rende Kommentare dazuschreiben.\par
\par
HMPFL!\par
Beim Kommentar schreiben aufgefallen: Das mit den "next level" interfaces reicht so auch nicht, weil ja von denen auch wieder alle interfaces geholt werden m\'fcssen.\par
Mal \'fcberlegen ...\par
\par
Es muss eher sowas sein wie:\par
- "interfacesToAdd" bef\'fcllen mit interfaces der aktuellen klasse und interface-interfaces der letzten "interfacesToAdd".\par
- im n\'e4chsten cycle die "interfacesToAdd" alle adden.\par
- dann die alle durchlaufen, alle deren superinterfaces in eine andere HashEnum packen\par
- Dann "interfacesToAdd" clearen und die aus der anderen HashEnum umkopieren.\par
\par
Aber moment: Punkt 4 ist ein Konflikt mit Punkt 1.\par
Aaaaahh....!!!\par
}
 