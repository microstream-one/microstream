{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-03-28\par
\par
MS-87 einlesen. Varianten \'fcberlegen. \par
\par
----\par
Laut Sprint mach ich dieses Issue als n\'e4chstes.\par
\par
Es gibt verschiedene Varianten, wie man das umsetzen k\'f6nnte.\par
Jede ist mehr oder weniger weitsichtig und entsprechend aufwendig.\par
\par
Urspr\'fcnglich war es ja so:\par
Zum Speichern eines Strings wurde direkt auf dessen internes char[] zugegriffen. Das war sehr schnell, weil die Daten nicht unn\'f6tig umkopiert werden mussten, sondern es wurde direkt der Inhalt des Strings in den IO-Buffer geschrieben, der dann auf die Platte geflusht wird. H\'f6chstm\'f6gliche Geschwindigkeit.\par
\par
Durch die Umstellung geht das nicht mehr, denn es gibt in String kein char[] mehr.\par
Man k\'f6nnte anfangen, in die Low-Level-Memory-Zugriff-Klasse Fallunterscheidungen einzubauen: Wenn Java Version <= 8, dann so, ansonsten anders.\par
Das geht, ist aber eine unn\'f6tige Verkomplizierung und langfristig vergebener Aufwand, weil die alten Java Versionen aus 1000 anderen Gr\'fcnden irgendwann verschwinden werden. Vielleicht k\'f6nnte es sogar gef\'e4hrlich werden. N\'e4mlich dann, wenn es in einer zuk\'fcnftigen Java Version wieder ein char[] mit gleichem Namen geben sollte, aber mit zus\'e4tzlichen Metadaten oder so. Z.B. "char[] value" plus "boolean hasOnlySimpleCodePoints". Dann w\'fcrde der Handler auf "magische" Weise auf einmal Fehler machen, obwohl er vorher ging. Nicht sch\'f6n.\par
\par
Das neue interne Format des JDK ist schwachsinnig. Siehe Ausf\'fchrung oben. Das speicher ich nicht direkt ab, sonst hat man zuk\'fcnftig das gleiche Problem nochmal (Handling von Strings<=8, Handling von zwischenzeitlichen Schwachsinnsstrings, Handling von Schwachsinnsstrings-Nachfolger). Au\'dferdem w\'fcrde das Probleme erzeugen, siehe unten. Dann lieber gleich ordentlich UTF-8, so wie es seit Jahren z.B. >90% der Webseiten machen.\par
Also muss man so oder so einmal umkopieren und dabei herumkonvertieren. Die Frage ist nun, an welcher Stelle und von was nach was.\par
\par
An diesem Punkt gibt es folgende Varianten:\par
\par
1.) "Upgrade Light"\par
Die persistente Repr\'e4sentation von Strings bleibt char[], bzw. in TypeDictionary Syntax "[char]".\par
Zum Speichern und Laden wird der String jeweils in eine char[]-Zwischenform konvertiert.\par
Vorteile:\par
- Das klappt ziemlich sicher mit jeder Version von Java. Von Java 1.0 bis Java 37.\par
- Es erfordert auf Persistence-Ebene keinen "zweiten" String Typ, genauer gesagt keine zweite String TypeId.\par
Nachteile:\par
- Mit MS-57 w\'fcrde dann aber doch ein neuer String Typ bzw. TypeId n\'f6tig werden.\par
- Macht String Handling mit Java <= 8 unn\'f6tig langsam. Aber in die Zukunft gerichtet muss man sagen: Who cares?\par
- Strings als char[] speichern ist eigentlich ziemlich ineffizient. Noch schlechter ist nur die aktuelle JDK-Strategie ab Version 9. Ich hatte das nur gemacht, weil es performancem\'e4\'dfig sehr schnell war bei der gegebenen String Implementierung. Wenn das wegf\'e4llt, weil man eh umkopieren muss, k\'f6nnte man auch gleich UTF-8 nehmen und damit die Speicherbelegung (Platte und RAM) etwas reduzieren. Und damit witzigerweise wieder die Ladezeiten, weil ja weniger Bytes geladen werden m\'fcssen. Aber wird trotzdem langsamer sein als fr\'fcher, wo ein char[] direkt gehandelt worden ist.\par
\par
2.) Schwachsinn\par
Nur der Vollst\'e4ndigkeit halber:\par
Die persistente Repr\'e4sentation von Strings stur angleichen, also auf byte[] + lustigen "coder".\par
Vorteile:\par
- W\'e4re gewohnt schnell mit der aktuellen String Implementierung.\par
Nachhteile:\par
- Br\'e4uchte einen "zweiten" String Typ, genauer gesagt eine zweite String TypeId.\par
- Br\'e4uchte mit MS-57 dann NOCHMAL eine neue String TypeId.\par
- Br\'e4uchte ein Legacy Type Mapping f\'fcr die alten Strings.\par
- Br\'e4uchte f\'fcr den Nachfolger des Schwachsinns (der garantiert kommen wird, hoffentlich wird es UTF-8) DREI Legacy Type Mapper: den erw\'e4hnten JDK8->JDK9, JDK8->JDKx, JDK9->JDKx.\par
- H\'e4tte kaum geringeren Speicherbedarf, weil die Schwachwinnsvariante "normale" Strings nach wie vor als 2 Bytes pro char kodiert, nur eben nicht mehr als chars, sondern als blanke Bytes.\par
\par
3.) "UTF-8 > all"\par
Die persistente Repr\'e4sentation von Strings wird UTF-8. Daf\'fcr w\'e4re Persistence-intern ein neuer Variable-Length-Spezialtyp n\'f6tig "[UTF8]", aber sowas ist schnell programmiert. F\'fcr Kompatibilit\'e4t zu Java <= 8 Versionen w\'fcrde es einen LegacyTypeHandler geben, der vom System aus standardm\'e4\'dfig registriert wird. D.h. man sieht davon nichts und "es geht halt einfach".\par
Vorteile:\par
- Das klappt ziemlich sicher mit jeder Version von Java. Von Java 1.0 bis Java 37.\par
- Der Speicherbedarf f\'fcr Strings w\'fcrde reduziert werden. In den allermeisten F\'e4llen auf ca. 50%.\par
Nachteile:\par
- Br\'e4uchte einen "zweiten" String Typ, genauer gesagt eine zweite String TypeId.\par
- Br\'e4uchte mit MS-57 dann NOCHMAL eine neue String TypeId.\par
- Br\'e4uchte ein Legacy Type Mapping f\'fcr die alten Strings. Aber nur f\'fcr die. Denn ab dann w\'e4re das persistente Format der Strings unabh\'e4ngig von der JDK Implementierung, d.h. der neue String TypeHandler ginge dann f\'fcr "alles"\par
\par
4.) "UTF-8 > all" + MS-57\par
Wie #3, nur dass auch gleich noch der Speicherbedarf f\'fcr den Entity Header verringert werden w\'fcrde.\par
Was hat das mit der JDK \'c4nderung zu tun?\par
Eigentlich nichts, aber man br\'e4uchte nicht mehrere Generationen von String Handlern, sondern es w\'fcrde einmal einen neuen geben und der w\'e4r es dann.\par
- JDK-unabh\'e4ngig\par
- kleinstm\'f6gliche Speicherbelegung f\'fcr den Inhalt.\par
- 0 Overhead f\'fcr Inhalt-Metadaten mehr.\par
Das w\'e4re DAS String Format und es w\'e4re f\'fcr alle Zeiten Ruhe.\par
Hei\'dft:\par
Vorteile:\par
- Das klappt ziemlich sicher mit jeder Version von Java. Von Java 1.0 bis Java 37.\par
- Der Speicherbedarf f\'fcr Strings w\'fcrde reduziert werden. Auf 50% oder sogar weniger.\par
Nachteile:\par
- Br\'e4uchte einen "zweiten" String Typ, genauer gesagt eine zweite String TypeId. Aber immerhin "nur" einen zweiten und nicht auch noch sp\'e4ter mal einen dritten.\par
- Br\'e4uchte ein Legacy Type Mapping f\'fcr die alten Strings.\par
- Mehr Aufwand, weil MS-57 auch gleich noch mit implementiert werden m\'fcsste.\par
\par
----\par
\par
Issue updaten.\par
\par
Ich w\'fcrde pers\'f6nlich nat\'fcrlich #4 bevorzugen, weil das eine "gescheite" L\'f6sung ist und man sich mit dem String Thema dann nicht mehr herumschlagen muss, sondern dann ist Ruhe.\par
Allerdings w\'e4re das auch der gr\'f6\'dfte Aufwand.\par
\par
#2 und #3 find ich bl\'f6d, weil daf\'fcr doppelt rumgebaut werden m\'fcsste. Erst jetzt f\'fcr ein neues String-Inhalt Format und dann sp\'e4ter nochmal f\'fcr ein neues String-Header Format. Bl\'f6d.\par
\par
Ich tendier im Moment durch allerlei vern\'fcnftige Abw\'e4gungen eher zu #1:\par
Es ist sehr schnell umgesetzt und es erlaubt #4 zuk\'fcnftig und zwar ohne Mehraufwand oder Verkomplizierung.\par
Der einzige Preis daf\'fcr ist der "Who cares?" Punkt, aber ... who cares?\par
Falls das wirklich irgendwo man ein Problem werden sollte, k\'f6nnte man den angepassten TypeHandler sogar durch einen Custom TypeHandler ersetzen, der dann wieder so funktioniert wie der jetzige. Bzw. ich lass die alte Implementierung bestehen und nenn sie nur "~Old" oder so. Oder vielleicht besser "~Java8Optimized".\par
\par
Und jetzt muss ich erst mal Java 9 installieren.\par
Und laut Eclipse Fehlermeldung und Recherche brauch ich daf\'fcr auch ein neues Eclipse.\par
*seufz*.\par
\par
Neuestes eclipse recherchiert.\par
Runtergeladen und installiert.\par
Tausend mal licence agreement.\par
Danach auch noch so ein configuration questionnaire. Durchmachen, manches googeln mangels Erkl\'e4rung.\par
Endlich fertig und ...\par
\par
Workspace ist leer. Hmpf.\par
Okay, dann Projekte importieren.\par
Sieht die Projekte, finish und ...\par
nix passiert.\par
\par
Import anders versuchen. Da sieht er nicht mal die Projekte.\par
FH fragen. Der ist in einer Besprechung. Mist. Nochmal rumprobieren.\par
Das geht nicht. So ein Shit.\par
\par
Dann mach ich derweil was anderes.\par
MS-133.\par
\par
Wieder checken. Immer noch in der Besprechung ...\par
Mal im Intranet Team fragen.\par
Alex hat Tip. Import Maven Projekte, nicht Java Projekte.\par
Klappt.\par
\par
Jetzt fehlen nur noch ALLE Eclipse Einstellungen.\par
*seufz*\par
\par
Recherchieren in Confluence. Ich hatte das fr\'fcher ja schon mal alles zusammengesucht.\par
\par
Aaach, jetzt wei\'df ich: Der Workspace war im alten Eclipse ein anderer. Ich hatte da nur die Projekte aus anderen Verzeichnissen reingemappt.\par
Darum ist der microstream workspace ohne Settings.\par
\par
Hm, aber eigentlich k\'f6nnte ich die Settings beim Workspace wechsel kopieren, wie FH das gezeigt hat.\par
Ausprobieren.\par
Hehe, ne: Das neue eclipse w\'fcrde den updaten und falls was sein sollte, kann ich den mit dem alten eclipse nicht mehr \'f6ffnen.\par
Also doch lieber manuell exportieren, importieren und die nicht enthaltenen prefs Eintr\'e4ge wieder mal per hand umkopieren ...\par
\par
Alles exportiert, importiert. Ergebnis:\par
x save actions nicht \'fcbernommen, aber war ja klar.\par
x Syntax color nicht \'fcbernommen, aber war ja klar.\par
x Layout nicht \'fcbernommen\par
x Font Einstellungen nicht \'fcbernommen\par
x package explorer package presentation: nicht \'fcbernommen\par
x Klassennavigation-Key (Alt statt Ctrl, weil man Ctrl st\'e4ndig false-positive-m\'e4\'dfig dr\'fcckt. ich versteh nicht, wie irgendein geistig gesunder Mensch auf der Welt das auf Ctrl lassen kann)\par
x templates und code templates: nicht \'fcbernommen\par
v package explorer file decorations \'fcbernommen (uuh!)\par
v Type Filter \'fcbernommen (uuuh!)\par
v Compiler Settings: sieht gut aus\par
\par
Langsam krieg ich das kotzen. Ich mach doch lieber eine Sicherheitskopie vom alten workspace und versuch das mit dem \'fcbernehmen.\par
Hass.\par
\par
Aber erst mal eine genaue Checkliste zusammenschreiben, was alles da sein muss.\par
Ausprobieren ...\par
\par
Hm. Eigentlich kann ich es doch so machen, dass ich den alten Workspace weiterbenutze, anstatt den microstream Ordner als Workspace zu benutzen. So mach ichs.\par
Alte projekte aufr\'e4umen (l\'f6schen).\par
Alte Workspaces aufr\'e4umen (muss nat\'fcrlich erst gegoogelt werden).\par
Fertig.\par
Die Checkliste ist trotzdem gut, weil man damit pr\'fcfen kann, ob alles geklappt hat.\par
\par
Und jetzt Feierabend. Halben Tag mit Eclipse updaten rumgeschlagen.\par
\par
\par
2019-03-29\par
\par
Jetzt die eigentliche Implementierung machen.\par
Erst mal auf JDK 9 umstellen und anschauen.\par
\par
\par
\par
Oh. Compilerfehler bei Cleaner.\par
\par
Das wird ein neues Issue:\par
\par
Im Rahmen von MS-87 habe ich das JDK 9 installiert und mal im MS Projekt verwendet.\par
\par
\'dcberraschung: Compilerfehler.\par
\par
Und zwar ist die JDK-interne Klasse "Cleaner" umgezogen von "sun.misc.Cleaner" nach "jdk.internal.ref.Cleaner".\par
Das ist halt die Gefahr, wenn man internes Zeug verwendet: es kann sich von einem Release zum anderen ver\'e4ndern.\par
\par
Jetzt ist das Problem:\par
Ich kann den Import einfach per Knopdruck anpassen, aber dann hat MS auf einmal als Mindestanforderung JDK 9.\par
\par
... hm. Mit MK und FH kl\'e4ren.\par
\par
\par
\par
2019-04-02\par
\par
Workaround f\'fcr Cleaner Package\'e4nderung.\par
Ausf\'fchrliche JavaDoc dazuschreiben.\par
\par
Jetzt testen.\par
Ah, na toll: module Exception:\par
java.lang.reflect.InaccessibleObjectException: Unable to make public void jdk.internal.ref.Cleaner.clean() accessible: module java.base does not "exports jdk.internal.ref" to unnamed module @629f0666\par
\par
Zeit f\'fcr eine Fortbildung ...\par
{{\field{\*\fldinst{HYPERLINK https://stackoverflow.com/questions/42538750/unable-to-export-a-package-from-java-base-module }}{\fldrslt{https://stackoverflow.com/questions/42538750/unable-to-export-a-package-from-java-base-module\ul0\cf0}}}}\f0\fs28\par
You will have to do that when compiling (javac) and when running (java) the code.\par
\par
... well, shit ...\par
\par
Mal mit FH besprechen, ob der mehr wei\'df.\par
Leider nein, aber Hinweis auf Klasse ServiceLoader.\par
\par
\par
MS-136 erstellen. Hintergr\'fcnde, Optionen und Hass dokumentieren.\par
Dabei #3 eingefallen. Kurz mit FH besprechen. So implementieren.\par
Issues MS-87 und MS-136 updaten.\par
\par
Und schon kann ich mit der eigentlichen Arbeit anfangen, der Wahnsinn.\par
}
 