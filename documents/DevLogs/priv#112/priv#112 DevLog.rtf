{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-07-05\par
\par
Recherche, Issue update.\par
\par
\par
2019-07-08\par
\par
Jetzt muss ich dazu doch ein DevLog anfangen, weil's schon wieder mal weitere Kreise zieht.\par
\par
Aufrufe suchen von:\par
PersistenceTypeDescriptionMember#equalDescriptions\par
\par
Kommt vor in:\par
PersistenceTypeHandlerManager#deriveRuntimeTypeHandler (zu allen TypeDescriptions mit RuntimeType zu dieser einen TypeHandler sicherstellen und pr\'fcfen, ob dieser zur Description passt)\par
PersistenceTypeHandlerManager#registerTypeHandlers (pr\'fcfen, ob Runtime TypeHandler zu TypeDescription aus dem Dictionary passt und diese ersetzen kann)\par
\par
F\'fcr beide Aufgaben w\'e4re eigentlich equalStructure (siehe Issue) die richtige Wahl.\par
Aber Vorsicht:\par
Wenn nur der normale Name anstatt dem full qualified bzw. unique identifier verglichen wird, dann hei\'dft das, dass das TypeDictionary mit anderen name qualifiern in seinen Members rausgeschrieben wird.\par
Die Frage ist, ob das sein darf.\par
\par
Moment mal... die Frage ist erst mal, ob es einen ordentlichen Check gibt, dass jeder Name nur einmal vorkommen darf.\par
Mal suchen ...\par
PersistenceTypeHandler$Abstract#validateAndImmure:\par
Validiert die Members mit IdentityEquality. WTF?\par
Das test ich jetzt ...\par
Ach! Das ist ja nicht die allgemeine IdentityEquality, sondern PersistenceTypeDescriptionMember.identityHashEqualator(). Und die pr\'fcft auf gleichen unique name.\par
Also passt so.\par
\par
Also wieder zur\'fcck zu der Frage:\line Ist es okay, dass sich mit neuem TypeHandler (z.B. custom) die member qualifier \'e4ndern?\par
Dann d\'fcrfte grunds\'e4tzlich f\'fcr solche Abgleiche nur der normale Name verwendet werden.\par
Dazu ist die Frage: Wenn Reihenfolge, Typ und Name \'fcbereinstimmen, sind dann die qualifier noch relevant?\par
Oder braucht man die Qualifier eigentlich nur, um innerhalb einer Member-Liste die Eindeutigkeit \'fcber Klassenhierarchien hinweg zu gew\'e4hrleisten?\par
Eigentlich schon. D.h. die qualifier d\'fcrften sich beliebig \'e4ndern. Mit CustomHandler (bei Legacy nicht, aber bei normalem schon) zu dem einen String und mit reflective Handler (evtl. einfach dem vorherigen, generischen) wieder auf was anderes.\par
Oder was spricht dagegen?\par
\par
Die Alernative w\'e4re, dass man halt den full qualified bzw. unique namen betrachten muss, d.h. ein custom handler mit pseudo fields muss als field qualifier evtl. typnamen von Superklassen replizieren.\par
Auch m\'f6glich, auch kein Drama, aber l\'e4stig.\par
\par
Dann w\'fcrd ich jetzt mal folgende Definition wagen:\par
\par
PersistenceTypeDescriptionMember#equals := #equalDescription && gleicher Type\par
PersistenceTypeDescriptionMember#equalDescription := #equalStructure && gleicher qualifier\par
PersistenceTypeDescriptionMember#equalStructure := gleicher type name && gleicher name\line\par
Diese Vergleiche kommen an oberste Stelle hin.\par
PseudoField bekommt einen qualifier.\par
Die Vergleichsimplementierungen in FieldMember kommen raus, weil sie durch die abstrakte Variante abgedeckt werden.\par
\par
\cf1 Pr\'fcfen: wird beim dictionary einlesen aus jedem member name ohne "#" automatisch ein PseudoField und aus jedem mit einen automatisch ein reflective field? Das m\'fcsste dann ge\'e4ndert werden.\cf0\par
\par
\par
\par
2019-07-09\par
\par
Das zieht wieder mal etwas weitere Kreise:\par
Wenn PseudoFields nun auch einen Qualifier haben k\'f6nnen, kann man beim Dictionary parsen nicht mehr einfach pr\'fcfen: Wenn qualifier, dann Field Member.\par
Stattdessen m\'fcssen PseudoField und (reflective) Field eigentlich das gleiche werden: Nur "Field".\par
Auf der Ebene der Definition gibts dann aber wieder einen Unterschied: bei dem einen ist der qualifier der declaringClassName, beim anderen ist es nur ein Random String.\par
Dementsprechend muss ich jetzt die beiden Klassenhiararchien anpassen.\par
Dabei sollte ich gleich die doch etwas dusselige Benamung \'e4ndern:\par
- "Field" ist der Basistyp f\'fcr alles au\'dfer PrimitiveDefinition und den kann man auch instanzieren.\par
- "FieldReflective" ist dann die Erweiterung mit Reflection Bezug.\par
- "PseudoField" ist dann f\'fcr so Dinger wie Complex.\par
\par
Ah, moment: es muss aber weiterhin ein PseudoFieldSimple geben, weil Complex PseudoFields nur noch andere pseudofields enthalten k\'f6nnen, kein Reflective mehr.\par
\line Hm, das ist knifflig zweideutig:\par
Ein "normales" qualifier#name Field muss zu einem generischen "Field" aufgel\'f6st werden.\par
Eins ohne qualifier muss ein pseudo field sein.\par
Eins in einem complex muss auch ein pseudo field sein.\par
\par
Dann, beim erzeugen der Definition instanzen:\par
Pseudofields sind eh klar, passt.\par
ABER:\line Wenn ein generisches feld kommt, wie soll man entscheiden, ob das ein pseudo field mit qualifier oder ein reflective field ist?\par
Das kann eigentlich nur an einem festgemacht werden:\line Wenn der qualifier "zuf\'e4llig" zu einem runtime type aufgel\'f6st werden kann, dann FieldReflective, ansonstne muss es zwangsweise ein Pseudofield sein. Selbst dann, wenn es fr\'fcher mal ein reflectiveField war.\par
\par
\par
\par
2019-07-10\par
\par
Refactorings umsetzen.\par
\par
Neuen Zwischentyp "PersistenceTypeDescriptionMemberField" eingef\'fchrt, von dem dann "~Reflective" und "~Generic" ableiten.\par
\par
Erst hab ich rumprobiert, alle Propert au\'dfer identifier() dann in den neuen Typ zu schieben, aber das w\'fcrde im Umkehrschluss haufenweise Fallunterscheidungen erfordern, ob eine TypeDescription eine PrimitiveDefinition oder eine "normale" ist.\par
Das ist die kleine "\'e4sthetische" Strukturs\'e4uberung nicht wert, also wieder zur\'fcck.\par
\par
Das generische Ding zur\'fcckgeben bringt aber nix, weil basierend auf dem ja dann ein "~Reflective" oder "~GenericSimple" erzeugt werden muss.\par
Bevor man erst zu diesem sp\'e4teren Zeitpunkt ein Class.forName() auf den qualifier versucht, kann man das auch gleich im Parser machen. Geh\'f6rt dort zwar irgendwie nicht hin ... aber mei ...\par
\par
\par
\par
2019-07-11\par
\par
MS-156 TODOs aufr\'e4umen.\par
Achja, die eigentliche Arbeit: die Beschreibungsvergleiche umstellen von description auf structure.\par
Hm, das ist f\'fcr PersistenceTypeDescriptionMemberFieldGenericComplex gar nicht so einfach, ordentlich zu machen:\par
Wenn man in equalsDescription()  einfach das superzeug aufruft, wird \'fcber die Vererbung equalsStructure() aufgerufen und die Members werden redundant doppelt iteriert.\par
Rumprobieren.\par
Das kann doch nicht so schwer sein.\par
Beste L\'f6sung:\par
Eine extra statische Methode PersistenceTypeDescriptionMember.equalTypeAndNameAndQualifier(), die aber normalerweise gar nicht aufgerufen wird, weil da ja die Verzahnung mit equalsStructure() ist.\par
Aber beim Complex Type braucht man sie dann.\par
Alles bissl crazy parallel programmiert, aber so m\'fcsse es passen und die sauberste L\'f6sung sein.\par
\par
Alles nochmal durchschauen.\par
Achja: PersistenceTypeDescription#equalDescription gibts ja auch noch. Aufrufe davon suchen.\par
Interessant:\par
Im Immutable Dictionary muss equalDescription verwendet werden, weil es ja exakt stimmen muss.\par
Ansonsten muss es  PersistenceTypeDescription#equalStructure sein.\par
Umbauen.\par
Alles nochmal durchschauen.\par
Letztes TODO damit entfernen.\par
\par
Puh. Jetzt sollte die Kleinigkeit f\'fcr den Bugfix, das dann doch wieder weitere Kreise gezogen und ziemlicher Komplexit\'e4t erzeugt hat, fertig sein.\par
Testen m\'fcsst ich es noch...\par
\par
Exception beim declaredTypeName padden: wenn's keinen gibt, soll hier null gepaddet werden, was Unsinn ist.\par
Stimmt, hatte ich gar nicht bedacht. Fixen.\par
Dabei auf noch was gesto\'dfen: variable length und complex felder m\'fcssen jetzt eigentlich auch mit qualifier assemblet werden.\par
Bzw. anders gesagt: ALLE Field Members m\'fcssen mit derselben Methode assemblet werden, die optional einen qualifier paddet.\par
Hm. Das hat \'fcberraschend viel Code eliminiert. H\'e4tte ich damals gleich so machen sollen. Egal, jetzt passts ja.\par
Testen.\par
Passt.\par
Aber jetzt kleiner Denkfehler beim resolvableDeclaringType aufl\'f6sen. Nullcheck reinmachen.\par
Testen.\par
Passt.\par
Aber NPE in PersistenceTypeDescriptionMemberFieldGenericSimple#New:\par
Das muss mayNull(qualifier) anstatt notNull(qualifier) hei\'dfen. Ist ja optional.\par
\'c4ndern.\par
Testen.\par
Argumentdreher bei ~Complex#New drin. TypeName muss zuerst.\par
\'c4ndern.\par
Testen.\par
Und bei PersistenceTypeDescriptionMemberFieldGenericSimple#New auch noch.\par
\'c4ndern.\par
Testen.\par
PersistenceTypeDescriptionMember#identityHash trifft auf null-member-identifier. Das darf eigentlich nicht sein. Debuggen.\par
Ach, das ist eine primitiveDefinition.\par
Wie war denn das vorher? Seltsam. Ich mach einfach die Definition als identifier.\par
Oh, interessant: das steht da schon. Aber: es gibt MemberDescriptionPrimitiveDefinition und MemberDefinitionPrimitiveDefinition.\par
Die ~Def~ leitet noch von was anderem ab und dadurch gilt anscheinend nicht mehr die bereits definierte delegate-Methode.\par
Naja, dann nochmal overriden und delegaten.\par
Testen.\par
Geht immer noch nicht.\par
Ach, weil es jetzt in der superklasse ein qualifiedFieldName gibt, was bei einer primitiveDefinition null ist und die Implementierung der Klasse hat Vorrang vor interface default methoden.\par
Hm. Der Punkt ist: Die ganzen Felder in PersistenceTypeDescriptionMember#Abstract geh\'f6ren eigentlich dort nicht hin, sondern nach PersistenceTypeDescriptionMemberField#Abstract.\par
Das bau ich so um.\par
Aber morgen, weil's schon 18 Uhr ist ...\par
\par
Das sollte dann aber eins der letzten Test-Problemchen sein, dann ist das Issue fertig.\par
\par
\par
\par
2019-07-11\par
\par
Klassenhierarchie bei PersistenceTypeDescriptionMemberField aufsplitten, bzw. die PersistenceTypeDescriptionMember#Abstract ist dann \'fcberfl\'fcssig, weil alles von Field abweichende gleich in die PrimitiveDefinition rein kommt.\par
Dort dann gleich einzelnen "persistentLength" Wert machen anstatt Minimum und Maximum.\par
Testen.\par
Passt.\par
\par
LegacyTypeHandler mit expliziter TypeId funktioniert.\par
Aber dabei Idee: Es m\'fcsste auch reichen, die TypeId wegzulassen und den nur nach Structure zu matchen.\par
Bzw. anders gesagt: Das matching nach Structure gibt es schon, aber daf\'fcr muss die TypeId 0 sein.\par
Testen.\par
Hm. Ja, geht, aber danach wird der handler nicht mehr mit der betreffenden TypeId initialisiert.\par
Mal schauen, wo ich das einbauen muss.\par
Oh, und: Der TypeHandlerManager pr\'fcft beim registrieren des effektiv zu verwendenden TypeHandlers nach TypeId nicht auf TypeId != 0. Das ist ein Bug, den Check muss ich noch einbauen.\par
\par
So. Beides eingebaut und getestet. Custom LegacyTypeHandler funktioniert. Mit und ohne expliziter TypeId. Sehr sch\'f6n.\par
Fertig.\par
\par
}
 