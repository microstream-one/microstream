OGS-3 Testfälle
2018-10-09, TM


1.) Mapping: expliztes Mapping und implizites Matching

1.1.) Explizites Mapping Varianten:
1.1.1.) Typen
1.1.1.1.) Gelöschter Typ (PersistenceDeletedTypeHandler)
1.1.1.2.) Umbenannter Typ, alter Typname nicht mehr auflösbar
1.1.1.3.) Umbenannter Typ, alter Typname ist gleich zu neu eingeführtem Typ (wäre eine fehlerhafte Auflösung)
1.1.1.4.) Syntax: Nur Typname
1.1.1.5.) Syntax: TypeId und Typname (eindeutige Typidentifizierung, d.h. es gibt eine neuere Version des Typs, die aber vom legacy lookup nicht verwendet werden darf)
1.1.2.) Members
1.1.2.1.) gelöschte Member (mehrere)
1.1.2.2.) verschobene Member (mehrere)
1.1.2.3.) neu dazukommende Member (mehrere)
1.1.2.4.) Member mit geändertem Typ (mehrere)
1.1.2.5.) Member mit geändertem Namen (mehrere)
1.1.2.6.) Syntax: source und target member mit typeId+typeName qualifier
1.1.2.7.) Syntax: source und target member mit nur typeName qualifier
1.1.2.6.) Syntax: source und target member ohne qualifier

1.2.) Implizites Matching
1.2.1.) Members
1.2.1.1.) gelöschte Member (mehrere)
1.2.1.2.) verschobene Member (mehrere)
1.2.1.3.) neu dazukommende Member (mehrere)
1.2.1.4.) Member mit geändertem Typ (mehrere)
1.2.1.5.) Member mit geändertem Namen (mehrere)



2.) Reflective Handling und Custom Handling
2.1.) Reflective Handling mit Vererbung
2.1.1.) Reflective Handling mit Vererbung und gleichen Feldnamen zwischen Klassen



3.) Custom Handling
3.1.) Custom Legacy Handler
3.2.) Custom Value Translators (z.B. von BigDecimal auf String oder sowas)
3.3.) Custom PersistenceRefactoringMemberIdentifierBuilder
3.4.) Custom PersistenceRefactoringTypeIdentifierBuilder


4.) Sonderfälle:
4.1.) unchanged structure (PersistenceLegacyTypeHandler.Wrap)
4.2.) unreachable handler


- References und Primitives.
- Legacy Handling listener
- unreachable Markierung mit erreichbaren Instanzen (muss exception werfen) und ohne (muss ohne exception durchlaufen)
- Instanz mit legacy type mapping laden, abspeichern, wieder laden: diesmal mit aktuellem TypeHandler und aktueller TypeId.




Teilweise multiplizieren sich die Punkte untereindander (darum "Dimensionen"):
Vererbung mit gleichen Feldnamen (d.h. declaring class Zuordnung) mal im expliziten Mapping und mal im impliziten Matching.
