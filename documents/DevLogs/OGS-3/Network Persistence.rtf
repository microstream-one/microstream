{\rtf1\ansi\ansicpg1252\deff0\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\lang7\b\f0\fs28 Jetstream Network Persistence Entwicklertagebuch\par
\b0\par
2018-08-07\par
\par
Erst mal wieder in mehrere Jahre alten Network Code einlesen ...\par
\par
Es gibt einen NetworkConnectionServer.\par
Dazu gibt es zwei Factory Typen: sessionful und sessionless. Beide instanzieren letztendlich dieselbe Server Klasse, nur mit anderer Konfiguration.\par
Es gibt ein "NetworkConnectionServer.Implementation.Setup". Das sollte inzwischen wohl besser "Configuration" hei\'dfen.\par
Und es gibt ein "NetworkSessionServer.Implementation.Setup", das ein ConnectionServer~Setup kapselt und um Sessionanteile erweitert.\par
\par
Erst mal nur Sessionless:\par
\par
NetworkFactoryServerSessionless:\par
Braucht:\par
- NetworkConnectionSocket\par
- NetworkConnectionProcessor\par
Das erste definiert und wrappt einen Java nio ServerSocketChannel, der f\'fcr die Kommunikation verwendet wird. Klar.\par
Das zweite verarbeitet eine reinkommende Connection. Auch klar.\par
Bei Sessionless ist das direkt die custom Serverlogik, d.h. jede Connection l\'f6st die Logik aus und dann ist auch schon wieder Schluss. Code im Beispiel: Nachricht an den Client zur\'fcck-Echoen.\par
Bei Sessionful ist der Processor ein Standard-Bestandteil der API und validiert und erzeugt bei Erfolg eine Session.\par
\par
Der Rest der Factory sind optionale Werte:\par
- connectionListenerMaxThreadCount\par
- connectionListenerCheckInterval\par
- connectionProcessorMaxThreadCount\par
- connectionProcessorThreadTimeout\par
Standardm\'e4\'dfig 1, 1000, 1, 1000.\par
\par
Also es gibt 4 Dinger:\par
- NetworkConnectionSocket    \par
- NetworkConnectionListener\par
- NetworkConnectionHandler\par
- NetworkConnectionProcessor\par
\par
Socket ist klar, low-level Verbindung.\par
ConnectionListener lauscht in eigenen Threads nach neuen Connection\par
Processor ist auch klar, das ist die Logik, bzw. das Sessionregistrieren.\par
Was macht der ConnectionHandler?\par
\par
ConnectionHandler (defaultimplementierung) erzeugt intern einen ThreadManager, der selbst wiederum einen connectionProcessorProvider hat und zwei "Regulator" Instanzen, um Threadcount und Timeout dynamisch abfragen zu k\'f6nnen, d.h. im simpelsten Fall sind das einfach nur gewrappte ints. Der connectionProcessorProvider ist auch klar: Der liefert bei bedarf einen connectionProcessor. Im trivialen Fall (z.B. Sessionless) gibt der einfach nur die Referenz auf eine singleton ConnectionProcessor Logik zur\'fcck. Im Sessionfall einen "NetworkUserSessionConnectionRegisterer", der die Registrierung macht.\par
\par
Ok. Also die Factory erzeugt mit so einem Setup eine Serverinstanz und in der Beispiel Main wird danach active() aufgerufen. Das sollte besser start() hei\'dfen.\par
\par
Das NetworkConnectionServer#activate() macht intern im Wesentlichen:\par
this.connectionManager.activate()\par
Das macht wiederum:\par
ListenerController (extends Thread) instanzieren und starten.\par
Der macht in seinem run() nur:\par
Zahl der Listener via Regulator checken und entsprechend erh\'f6hen oder reduzieren, danach ein Interval lang schlafen.\par
Listener erh\'f6hen:\par
Neue ListenerThread (extends Thread und nested in NetworkConnectionManager) Instanz erzeugen, registrieren und starten.\par
\par
ListenerThread#run macht:\par
vom \'fcbergeordneten NetworkConnectionManager provideConnectionListener() aufrufen.\par
\par
Das macht wiederum:\par
NetworkConnectionListener Instanz (bisher anscheinend immer) erzeugen und dann zur\'fcckgeben.\par
\par
NetworkConnectionListener#run macht (mit Exceptionhandling und blabla au\'dfen rum):\par
SocketChannel newConnection = this.connectionSocket.acceptConnection()\par
this.connectionHandler.handleConnection(newConnection)\par
\par
connectionHandler#handleConnection macht eben wie schon recherchiert:\par
connection an den threadmanager \'fcbergeben, der holt sich intern vom connectionProcessorProvider eine connectionProcessor Instanz. Im trivialen Fall ist das die Logik selbst.\par
\par
Also soweit fertig analysiert:\par
- Server wird zusammengebaut mit custom Socket, custom processing Logik und defaults f\'fcr thread management.\par
- Connection listening erfolgt gemanaget mit einer dynamischen Anzahl an dedicated Threads.\par
- Die Threads lauschen mit acceptConnection nach neuen Verbindungen und leiten eine solche an die processor Logik weiter.\par
- Im einfachsten Fall (Beispiel) echot die die Nachricht an den Client zur\'fcck und die Connection ist erledigt.\par
- Au\'dfen rum viel Threadmanagement und Exception Handling Logik rum, damit man das nicht jedes mal selber bzw neu schreiben muss.\par
\par
\par
Der Sessionless Client ist im Vergleich relativ krude, ohne sch\'f6ne Kapselung:\par
\par
Per LogicSimpleNetwork#openRemoteChannel Utilmethode wird ein SocketChannel ge\'f6ffnet.\par
Per LogicSimpleNetwork#communicate wird ein String geschickt.\par
Die echoRequest Logik im Server ruft LogicSimpleNetwork#readString und danach LogicSimpleNetwork#sendString auf.\par
\par
\par
Jetzt auf zum dar\'fcberliegenden "network.binary.persistence" Framework:\par
\par
BinaryMessageProcessor kennt einen PersistenceBuilder<M>. Das ist die Verbindung zum Persistence Framework.\par
\par
Hm. Aber recht viel mehr ist da nicht.\par
Ein paar Verbindungen zu sessionful network Zeug. Ansonsten nur Utilmethoden, die nie aufgerufen werden und Interfaces, die nirgends implementiert werden.\par
Da ist auch requesthandling mit request IDs und sowas drin.\par
\par
Das ist alles sehr wenig und sehr anf\'e4nglich:\par
- Es hei\'dft binary.persistence, verwendet aber nur Persistence~<M> Code mit beliebigem Medium.\par
- Es ist an sessionful Code gebunden, obwohl die Verwendung eines Persistence Frameworks doch auch ohne Session m\'f6glich sein sollte (oder?)\par
- Code Kommentare sind von 2012. Das ist 6 Jahre her ^^. Da war das Persistence Zeug alles noch extrem in den Kinderschuhen.\par
\par
Hm. Ich h\'e4tte schw\'f6ren k\'f6nnen, schon mal eine Beispiel Main auch mit der Binary Persistence gehabt zu haben, aber davon find ich nix mehr, auch kein Framework.\par
\par
\par
Die Frage ist nun:\par
Zumindest der Network Code sieht schon ganz sinnvoll aus mit dem Wrapping des ganzen Overhead Codes.\par
Aber ist es hilfreich, den f\'fcr eine simple Demo \'fcberhaupt zu verwenden?\par
\par
Eigentlich reicht ja:\par
- Client Main macht einen nio SocketChannel auf.\par
- Client Server listened hardcoded und singlethreaded nach einer Connection.\par
- Wenn eine Connection reinkommt, wird die (irgendwie gewrappt) als PersistenceSource verwendet und ausgelesen.\par
- Der Client verwendet seinen SocketChannel (auch gewrappt) als PersistenceTarget und schreibt da rein.\par
\par
Das ganze muss nat\'fcrlich bidirektional sein: Der Server muss auch senden und der Client auch empfangen k\'f6nnen.\par
Das hei\'dft beide m\'fcssen den SocketChannel eigentlich \'e4hnlich wie bei der Storage als "Connection" wrappen, die Source und Target zugleich ist.\par
In StorageConnection ist das der PersistenceManager, der PersistenceRetrieving und PersistenceStoring ist und entsprechende Source und Target kennt.\par
\par
Das hei\'dft analog wie die StorageConnection m\'fcsste die NetworkConnection ein Wrapper f\'fcr einen PersistenceManager<Binary> sein, der intern den Socket als Source und Target wrappt und drum rum die ganze SwizzlingRegistry und TypeHandling Logik rumbaut.\par
\par
Anmerkung:\par
Ber StorageRequestAcceptor in der StorageConnection ist nur eine parellele Referenz auf ein vom PersistenceManager gerwrapptes Bestandteil, damit die Connection direkt Util-Requests an die Storage schicken kann. Prinzipiell, bzw. ohne Util-Requests, braucht man sowas nicht, also kann das bei der NetworkConnection entfallen.\par
Hm. Oder noch einfach (f\'fcr den Anfang): man braucht nur einen PersistenceManager direkt. Alles, was den von einem File PersistenceManager unterscheidet, ist, dass er statt einem FileChannel einen SocketChannel als Source und Target hat.\par
So sollte/muss das Framework ja auch funktionieren: man schreibt nur eine Anbindung f\'fcr ein Source und Target und der Rest ist sauber wegabstrahiert.\par
\par
Das sollte eigentlich so trivial sein wie die existierenden BinaryFileTarget und BinaryFileSource Implementierungen sein. \par
\par
\par
Ca. 1,0h f\'fcr Network und Network Binary Persistence Recherche, Recherche und Konzept f\'fcr simples Network Target und Source.\par
\par
\par
\par
2018-08-08\par
\par
21:30\par
Erst mal ordentliches Projekt "Jadoth Network Persistence" anlegen.\par
Das "Binary Persistence" kann dann gel\'f6scht bzw. gr\'f6\'dftenteils neu gebaut werden.\par
Und schon gibts das erste Problem: Daraus ein Maven Projekt machen ist alles andere als intuitiv. Nirgends eine Option, ein Java Projekt zu einem Maven Projekt zu konvetieren. Schauen, ob man ein Maven Projekt direkt anlegen kann. Ja, geht. Also l\'f6schen und als Maven Projekt neu anlegen. "Group Id". "Artifact Id". Alles Pflichtfelder, aber keine Ahnung, was da rein muss. Keine Hilfe, Vorschlagswerte sind leer (da k\'f6nnte man ja bestehende anzeigen).\par
=> Wieder mal Dreckskonzept, mit dem ich mich jetzt nicht ewig rumschlage.\par
Also wieder Maven Projekt l\'f6schen und normales Java Projekt mit normalen Projektabh\'e4ngigkeiten anlegen. Soll jemand mit magischem Maven Wissen in der Arbeit dann konvertieren.\par
\par
NetworkPersistenceConnection anlegen.\par
\par
\par
Gleich im Persistence Framework einen neuen Kombi-Typ PersistenceChannel (Target+Source) anlegen. Als Konsequenz bisherige Doppelimplementierungen konsolidieren. Interessant: In den Factories gibt es sowas eh schon, aber implizit definiert \'fcber doppel-Bound-Generics. #setPersistenceStorage. Vereinfachen zu #setPersistenceChannel.\par
\par
NetworkPersistenceConnection umbenennen zu NetworkPersistenceChannel. Das "Channel" hat nichts mit dem zu verwendenden SocketChannel zu tun, sondern ist allgemein gemeint. Siehe oben. Eher im Sinn "Einen Kanal \'f6ffnen", so wie bei Funkkommunikation oder allgemein einfach ein Kanel, durch den hin und zur\'fcck Daten flie\'dfen. Dass der NetworkChannel dann einen SocketChannel wrapt, passt zuf\'e4llig ganz gut.\par
\par
PersistenceSource#readInitial refactoren zu PersistenceSource#read und JavaDoc aktualisieren.\par
\par
Nachdenken \'fcber NetworkPersistenceConnection#readByObjectIds. Macht grunds\'e4tzliuch schon Sinn, aber erstmal weglassen. Entsprechenden Kommentar schreiben.\par
\par
NetworkPersistenceChannel muss abstract werden.\par
Es muss dann noch einen NetworkPersistenceChannelBinary mit konkreter Implementierung geben.\par
\par
Hm.\par
In PersistenceSource fehlt noch ein #prepareSource und #closeSource.\par
Analog in PersistenceTarget.\par
Gut, dass es default methods gibts. Damit ist es ein Klacks, das abw\'e4rtskompatibel zu machen.\par
\par
\par
Jetzt NetworkPersistenceChannelBinary implementieren.\par
Struktur fertig. Jetzt ist die Frage, wie man aus einem SocketChannel ein bis mehrere Binary rauszieht.\par
Das m\'fcsste analog zur simplen File Implementierung gehen. Mal checken.\par
\par
Ca. 1,0h f\'fcr Maven \'c4rger, Projekte und Strukturen anlegen, bestehende Typen leicht refactoren und NetworkPersistenceChannelBinary implementieren. \'dcberlegungen zu Daten lesen mit unbekannter L\'e4nge.\par
\par
\par
\par
2018-08-10 20:15\par
\par
PersistenceSource Implementierung f\'fcr simples File anschauen und f\'fcr SocketChannel \'fcbernehmen.\par
\par
Hm ...\par
Bei einer Netzwerkverbindung wei\'df man vorher nicht, wie viele Bytes der schicken wird. Also m\'fcsste ich entweder die Struktur der persistierten Daten erweitern ("Ein Haufen Bytes muss am Anfang immer eine Angabe \'fcber die L\'e4nge haben") oder eine bissl komplizierte zusammenst\'fcckel-Logik bauen. Aber f\'fcr ein simples Beispiel mach ich jetzt einfach mal einen gro\'dfz\'fcgigen Puffer, in den alle Daten auf einmal reingehen. Plus TODO daneben hin.\par
Etwas weiter daran rum\'fcberlegt: letztendlich muss es die "Zusammenst\'fcckel-Logik" werden, weil das flexibler ist, als zus\'e4tzliche Metadaten zu verlangen, auf die man bei einer anderen Strategie verzichten k\'f6nnte.\par
\par
Das wird aber bissl komplizierter:\par
- Anfangen mit nur einem ChunksBuffer, okay.\par
- Sobald der voll ist, den n\'e4chsten anlegen und immer so weiter, bis keine Bytes mehr \'fcber den Socket reinsprudeln.\par
- Beim durchiterieren der Bytes gibts dann verschiedene eklige Sonderf\'e4lle:\par
1.) am Ende eines Buffers ist ein Entity unvollst\'e4ndig enthalten.\par
2.) am Ende eines Buffers ist das length header field eines Entities unvollst\'e4ndig enthalten.\par
Beide F\'e4lle m\'fcssen so gel\'f6st werden:\par
Falls so ein Fall festgestellt wird, muss ein zus\'e4tzlicher ChunksBuffer erzeugt werden, der "dazwischengeschoben" wird.\par
In den wird der Restteil aus dem aktuellen ChunksBuffer kopiert.\par
Im Fall 1 wird dann der Rest des zerteilten Entities dazukopiert, so dass das Entity wieder komplett ist.\par
Im Fall 2 wird der Rest des Length Headers dazukopiert. Dann kann \'fcberhaupt erst geschaut werden, wie lang das Entity ist. Falls der dazwischengeschobene ChunksBuffer zu klein sein sollte, muss nochmal ein neues angelegt werden und nochmal umkopiert werden, damit das entity letztendlich komplett enthalten sein kann.\par
Der regul\'e4r folgende ChunksBuffer braucht einen Offset, damit die zusammenkopierten Daten an seinem Anfang nicht nochmal gelesen und f\'e4lschlicherweise als ganzes Entity interpretiert werden.\par
\par
Performancetechnisch ist das alles kein Problem: Es geht nur um ein einzelnes Entity und der ganz eklige Fall 2 sollte relativ selten sein. Aber das wird relativ viel Code. Bissl bl\'f6d.\par
\par
Aber erst mal die triviale L\'f6sung mit dem gro\'dfen Puffer und TODO daneben.\par
\par
}
 