{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset128 MS Mincho;}}
{\colortbl ;\red255\green0\blue0;\red0\green176\blue80;\red155\green0\blue211;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17134}\viewkind4\uc1 
\pard\sl276\slmult1\b\f0\fs28\lang7 OGS-3 Type Refactoring Entwicklungstagebuch:\par
\b0\par
2017-08-30\par
Komplexe Sache. Es gibt:\par
- Type<->TypeId Mapping\par
- Type<->TypeHandler Mapping\par
- TypeHandlers, die potenziell ihre eigene TypeId mitbringen\par
- oder Typehandlers, die f\'fcr eine vorgegebene TypeId initialisiert werden m\'fcssen. \par
- Die latest TypeDescription aus dem Dictionary muss Member-m\'e4\'dfig abgeglichen werden mit dem RunTime TypeHandler, ggf. muss dabei eine neue Id vom TypeManager vergeben und im Mapping eingetragen werden.\par
- Das alles muss untereinander validiert werden, damit nicht vorschnell zeug eingetragen wird, obwohl sich sp\'e4ter rausstellt, dass es einen Konflikt gibt.\par
- und schlie\'dflich muss der nach all dem initialisierte TypeHandler im TypeManager registriert werden\par
\par
Daf\'fcr braucht man alle m\'f6glichen Ebenen von Indirektion. Handler. HandlerInitializer. HandlerInitializerLookup. HandlererProvider. HandlerEnsurer. Wrapper f\'fcr den Initializer eines Handlers, damit nach dem Initialisen der callback zum TypeHandlerManager gemacht werden kann ...\par
\par
Das Hirn l\'e4uft auf Hochtouren, aber es dauert leider Stunden, das alles unter einen Hut zu bringen.\par
\par
\par
2017-08-31\par
\par
TypeDictionary soll einerseis aus fertigen immutable PersistenceTypeDescriptionLineage instanzen bestehen, andererseits soll es neue eintr\'e4ge hinzugef\'fcgt bekommen k\'f6nnen.\par
Eigentlich einzig sinnvolle L\'f6sung:\par
TypeDictionary vor dem einlesen erzeugen und die Eintr\'e4ge aus der Datei dort reingestrieren, wie sp\'e4ter zur Laufzeit auch.\par
\par
\par
2018-09-01\par
Ablauf:\par
... umgeschrieben, siehe 09-04\par
\par
2018-09-04\par
\par
Ablauf:\par
- Dictionary Datei parsen zu Entry Zwischeninstanzen\par
- Zwischeninstanzen gruppieren nach TypeName\par
- Dictionary Instanz erzeugen\par
- Lineage Instanz von Dictionary Instanz holen / sicherstellen. Falls neu erzeugen, RuntimeHandler feststellen, falls m\'f6glich.\par
\cf1 /!\\ Verbinden: PersistenceTypeDescriptionLineageProvider <-> PersistenceTypeDescriptionInitializerLookup\cf0\par
- f\'fcr alle Zwischeninstanzen PersistenceTypeDescription instanzen erzeugen und bei Dictionary registrieren\par
- vorhandene RuntimeHandler valideren mit members der typeid-latest Zwischeninstanz und je nach ergebnis initialisieren mit derselben oder einer neuen TypeId.\par
\cf2 /!\\ gekl\'e4rt: man kann die latest TypeId nicht schon aus den sortierten Zwischeninstanzen rauslesen und beim Handler Instanzieren mitgeben, weil der Vergleich der Members  eine Handler Instanz braucht. Man muss nachtr\'e4glich bedingt initialisieren.\cf0\par
/!\\ RuntimeHandler darf erst in den dictionaryEntries der Lineage registriert werden, wenn ein die Gleichheit von Dictionary-basierter und RuntimeHandler-basierter aktueller Description gesichert ist. D.h. NACH erfolgreichreichem TypeRefactoring. Nicht vorher.\par
\par
Nachdem der Runtimehandler seine ID bekommen hat, muss er noch beim TypeManager und beim TypeHandlerManager registriert werden.\par
Das kann aber nicht im builder passieren, weil dort nur noch mit Descriptions gearbeitet wird, nicht mit Handlers.\par
Es w\'e4re eine Art Wrapper-Initializer n\'f6tig mit einem callback zum TypeHandlerManager.\par
\par
Evtl. m\'fcssen die Handler selbst eine R\'fcckreferenz zum TypeHandlerManager haben und in ihrem initialize() sich beim TypeHandlerManager registrieren.\par
Wobei dann bl\'f6d ist, dass Handler Instanzen nicht mehr allgemein verwendbar sind.\par
\par
\par
\par
\par
2017-09-05\par
\par
Implementierung.\par
\par
\par
2017-09-06\par
\par
Compilerfehler beheben, veraltete Implementierungen l\'f6schen.\par
\par
Foundation Implementierung anpassen.\par
\par
Muss nun in PersistenceTypeDescriptionLineageProvider rein:\par
final PersistenceRuntimeTypeDescriptionProvider  runtimeTypeDescriptionProvider;\par
\par
\par
\par
\par
2017-09-25\par
\par
PersistenceTypeDescriptionLineageProvider muss f\'fcr die Instanzierung einer lineage die aktuelle runtime TypeDescription (d.h. einen TypeHandler) vom  PersistenceRuntimeTypeDescriptionProvider holen.\par
Der TypeHandler kann dabei aber noch nicht beim TypeHandlerManager registriert werden, weil die TypeId noch nicht feststeht.\par
Also muss mit dem Liefern der runtime TypeDescription (TypeHandler) auch irgendwie ein TypeHandlerManager Registrierungscallback vermerkt werden.\par
Wenn die ganze TypeId Initialisiererei dann abgeschlossen ist, muss der callback ausgef\'fchrt werden und die Handler beim Manager registrieren.\par
\par
ODER es gibt einen TypeDescription Initializer und der f\'fcr die TypeHandler kennt den Manager und registriert den Handler nach erfolgreicher Initialisierung.\par
Das w\'fcrde aber hei\'dfen, dass nicht eine TypeDescription direkt zur\'fcckgegeben werden dard, sondern ein Initializer. Das w\'e4re dann der "Wrapper" von oben.\par
\par
\par
\par
2017-09-26\par
\par
Es gibt vier Aspekte f\'fcr Type Descriptions:\par
1.) Type Name. Das ist die Identit\'e4t einer Type Lineage und dient zur Aufl\'f6sung zu einem Runtime type.\par
2.) Aufbau der Felder. Wird von Dictionary UND vom Runtime Type vorgegeben.\par
3.) TypeId. Wird vom Dictionary vorgegeben f\'fcr in Name&Feldaufbau matchende Runtime Type Descriptions.\par
4.) Runtime TypeDescriptions k\'f6nnen TypeHandlers sein. Diese m\'fcssen f\'fcr ihre TypeId initialisiert und DANACH beim TypeManager registriert werden.\par
\par
Das erfordert zwangsl\'e4ufig ein Callback-Indirektion: Erst wird die TypeDescription/TypeHandler Instanz geholt bzw. erzeugt, dann wird sie f\'fcr ihre TypeId initialisiert und DANN muss sie beim TypeHandler registriert werden.\par
Das geht nur \'fcber eine Art R\'fcckverbindung zum TypeManager.\par
Wenn man nicht dumm herumcasten will (if TypeDescription instanceof TypeHandler), dann muss das in irgendeiner Form eine Wrapperinstanz mit R\'fcckreferenz auf den TypeManager sein.\par
Also muss der TypeDescription Lookup einen TypeDescriptionInitializer zur\'fcckgeben.\par
Dieser\par
- kennt den Typename\par
- kennt den Feldaufbau\par
- kennt NICHT die TypeId\par
- gibt f\'fcr eine \'fcbergebene TypeId eine fertige TypeDescription zur\'fcck.\par
- kennt eine R\'fcckreferenz auf was auch immer informiert werden muss nach der Initialisierung.\par
\par
Diese Indirekion ist nur beim Dictionary builden n\'f6tig, weil dabei existierende TypeId laut TypeName zugeordnet werden m\'fcssen. Wenn zur Laufzeit ein neuer Typ analysiert und eine neue Description/Handler erzeugt wird, bekommt die immer automatisch die n\'e4chste TypeId vom TypeIdManager.\par
\par
Das hei\'dft, dass die ganze Initializer-ei nicht in der fertigen TypeDictionary Instanz oder in der TypeLineage enthalten sein muss/darf, sondern nur im TypeDictionaryBuilder.\par
Wahrscheinlich muss es daf\'fcr eine erhebliche Hilfsstruktur geben, in der alles zwischengelagert wird, aber das ist dann halt so.\par
\par
Das hei\'dft auch, dass alle TypeDescription Instanzen, die ein TypeDictionary bzw. eine TypeLineage bekommt, fertig sind. Die Logik kann dementsprechend vereinfacht werden.\par
\par
Der Initializer ist aber nur f\'fcr die Runtime TypeDescription n\'f6tig. Alle anderen k\'f6nne direkt aus dem TypeDictionary heraus final instanziert werden.\par
\par
Damit haut das auch endlich hin, dass TypeDescriptions ihre TypeLineage per final Feld kennen m\'fcssen.\par
\par
\par
\par
2017-09-27\par
\par
Viel von der LineageBuilder Logik kann / sollte direkt in Lineage selbst rein. Muss eh mutable sein, weil sie zur Laufzeit erweiterbar sein muss.\par
\par
TypeChangeCallback bauen\par
\par
Gemeinsamen Supertyp "PersistenceTypeStructure" f\'fcr PersistenceTypeDescriptionInitializer und PersistenceTypeDescription bauen.\par
Benamungen verbessern:\par
PersistenceTypeDescription -> PersistenceTypeDefinition\par
PersistenceTypeStructure -> PersistenceTypeDescription\par
\par
TypeChangeCallback erweitern um validation\par
\par
\par
Es m\'fcssen erst alle Typen im Dictionary im SwizzleTypeManager typeId-ensured werden, bevor die erste TypeDefinition initialisiert werden kann, sonst fehlt das Type<->TypeId Mapping und der TypeManager vergibt lauter neue TypeIds.\par
Genauer gesagt m\'fcssen alle Types ohne Konflikt mit der Runtime vorab schon mal registriert werden, danach kann ruminitialisiert werden.\par
\par
Irgendwie bei\'dft sich da die Katze in den Schwanz:\par
Bevor man Typen initialisieren kann, m\'fcssen alle Typen registriert werden, damit die TypeIds nicht neu vergeben werden. Damit man typeIds registrieren kann, muss man aber wissen, welche Typen sich ge\'e4ndert haben, d.h. die Typen m\'fcssen vorher analysiert/initialisiert werden werden.\par
Hmpf.\par
Wahrscheinlich ist die L\'f6sung eine weitere Zweiteilung, und kommt auch die neue Differenzierung zwischen PersistenceTypeDefinition und PersistenceTypeDescription ins Spiel:\par
- Die Typanalyse muss erst mal nur wissen, welche Typen Unpersistable sind. Damit wird dann eine PersistenceTypeDescription erzeugt, noch v\'f6llig unabh\'e4ngig von TypeIds.\par
- Mit Hilfe der TypeDescriptions kann dann entschieden werden, welche TypeIds aus dem Dictionary noch aktuell sind und beim TypeManager registriert werden k\'f6nnen und welche veraltete sind und eine neue TypeId brauchen.\par
- Wenn dann alle TypeIds feststehen, kann man die Initialisierung f\'fcr alle abschlie\'dfen.\par
\par
Hei\'dft konkret:\par
1.) Das Type Analysieren muss komplett losgel\'f6st von TypeIds werden und erst mal nur TypeDescriptions erzeugen.\par
2.) Es m\'fcssen erst alle TypeDescriptions gesammelt werden, basierend darauf dann TypeIds registriert oder neu vergeben werden.\par
3.) Dann k\'f6nnen erst alle TypeDefinitions bzw. TypeHandlers initialisiert werden.\par
\par
\par
Eigentlich brauchen die TypeDefinitions keine R\'fcckreferenze auf ihre Lineage. Umgekehrt nat\'fcrlich schon, die Lineage muss alle Definitions kennen, aber nicht zur\'fcck.\par
Das w\'e4re eine nette convenience Referenz gewesen, aber eigentlich braucht man sie nie und sie verkompliziert nur die Initialisierung und macht Mehrfachverwendung von stateless/threadsafe.\par
\par
BinaryTypeHandlerEnsurerLookup rausrefactoren: Den CustomHandlerRegistry Lookup kann der normale Ensurer auch mitmachen, daf\'fcr muss nicht eine zus\'e4tzliche Indirektion rein.\par
Damit sieht das langsam mal ordentlich aus  ...\par
\par
Aufr\'e4umen, alte Klassen l\'f6schen, Methoden vereinfachen.\par
Dadurch kommen tats\'e4chlich mal einige TODOs weg.\par
\par
\par
\par
2017-09-28\par
\par
TypeDictionary Building so umbauen, dass erst ein komplettes Dictionary mit gef\'fcllten lineages ohne Initialisierungen gebaut wird und danach kann dann eine initialisierungslogik dr\'fcberlaufen und TypeId abchecken usw.\par
TypeDictionary LookupTable rebuildung anpassen. Sinnlose Sortierung auslagern.\par
\par
Jetzt w\'e4r ich dann endlich mal an dem Punkt, wo im TypeHandlerManager die Type Validierung durch die neue, komplexere Logik ersetzt wird.\par
\par
\par
\par
2017-09-29 \par
\par
\cf2 v TODO: es muss noch eine Validierung geben, ob eine TypeId doppelt im Dictionary steht (\'fcber verschiedene TypeNames hinweg)\cf0\par
\par
\cf1 TODO: es muss storage-seitig eine Validierung w\'e4hrend der Initialisierung geben, die erkennt, wenn es f\'fcr eine TypeDefinition keinen Runtime Type gibt, aber Entities.\par
Das kann eine ziemlich winzige Sache sein: Beim StorageEntityType anlegen f\'fcr das erste begegnete Entity im handler checken, ob type == null ist. Wenn ja, Exception, Initialisierung abbrechen.\par
\cf0\par
Neue Implementierungen teilweise aufger\'e4umt und kommentiert.\par
\par
TypeHandlerManager  Typvalidierung:\par
v alle TypeLineages durchlaufen und wo type != null ist, einen runtime TypeHandler (noch uninitialisiert / ohne TypeId) ableiten.\par
- TypeHandler mit latest TypeDefinition abgleichen: Wenn gleiche Struktur, dann ersetzen. Ansonsten wurde ein TypeChange festgestellt.\par
- Alle TypeChanges validieren lassen, bevor irgendwas an TypeIds registriert wird.\par
- F\'fcr alle passenden TypeHandlers bestehende TypeId f\'fcr den Type registrieren.\par
- F\'fcr TypeHandlers mit TypeChange neue TypeId reservieren und damit initialisieren.\par
- TypeDictionary darf erst NACH der Storage Initialisierung (und ggf. Type Conversion von Entities) rausgeschrieben werden.\par
\par
\par
Interessante Frage:\par
Sollte die TypeDictionary Datei nach der Registrierung aller TypeDefinitions f\'fcr die aktuellen Runtime Typen \'fcberschrieben werden [d\'fcrfen|m\'fcssen?], auch wenn die existierenden Entities in der DB noch nicht konvertiert worden sind?\par
Vorteile:\par
- Sobald die Typ-Checks und TypeId-Vergaben einmal erfolgreich aktualisiert worden sind, kann/sollte man diese Beschreibungen auch gleich rauspersistieren.\par
- Die TypeDefinition Initialisierung w\'e4re in sich abgeschlossen und vollst\'e4ndig, ohne darauf angewiesen zu sein, dass ein \'e4u\'dferer Kontext ihre Arbeit (Type Dictionary Datei aktualisieren) irgendwann fertigstellt.\par
Nachteil:\par
Wenn zwischen Schreiben der TD-Datei und dem Konvertieren der Entities abgebrochen wird, haben die Entities beim n\'e4chsten Start einen veralteten Typ, was nicht sein darf.\par
D.h. es m\'fcsste einen allgemeinen Automatismus geben, der Entities jeglicher veralteter Typen (auch schon 2-3 Generation zur\'fcck) auf die aktuelle Struktur konvertiert.\par
Das w\'e4re vielleicht eh gar nicht schlecht. Macht die Datenbank sehr viel robuster gegen \'c4nderungen, anstatt nur die letzte \'c4nderung kompensieren zu k\'f6nnen.\par
Fazit: Der "Nachteil" ist also gar kein Nachteil, sondern nur zus\'e4tzlicher Aufwand, der daf\'fcr aber mehrere zus\'e4tzliche Vorteile bringt.\par
\par
Das hei\'dft dann aber als Konsequenz auch, dass beim Typabgleich \'fcberhaupt kein Refactoringplan erstellt werden muss, sondern der muss allein beim Storage Initialisieren on demand gemacht werden, wannimmer die Initialisierung ein Entity sieht, das einer veralteten TypeDefinition angeh\'f6rt.\par
Die Initialisierung muss also einen "TypeConverterProvider" kennen, der seinerseits das komplette TypeDictionary mit TypeLineages kennt und auf Anfrage passende TypeConverter erzeugt und zur\'fcckgibt.\par
\par
Damit es dann noch trotzdem einen ordentlichen Callback f\'fcr z.B. einen User-Review geben kann, m\'fcsste erst die Initialisierung komplett durchgemacht werden, alle betroffenen Typen gesammelt werden, dann zentral f\'fcr jeden ein TypeConversion Plan erzeugt werden und alle erzeugten TypeConversion Pl\'e4ne dann dem Callback \'fcbergeben werden.\par
Der Callback gibt seinerseits wieder TypeConversion Pl\'e4ne zur\'fcck. Normalerweise genau dieselben oder ver\'e4nderte, falls der User das Mapping umgestellt hat.\par
Aus den effektiven TypeConversion Pl\'e4nen werden dann die tats\'e4chlichen TypeConverter erzeugt und am Ende der Initialisierung angewendet.\par
Erst wenn die alle durchgelaufen sind (d.h. es gibt garantiert kein Entity mehr, das einem veralteten Typ angeh\'f6rt), ist die Initialisierung abgeschlossen.\par
Wenn die Initialisierung auf kein Entity eines veralteten Typs trifft, passiert einfach gar nichts in Sachen TypeConversion.\par
\par
\par
\par
2017-10-06\par
\par
Foundation Klassen an neues TypeHandling anpassen.\par
\par
\par
\par
\par
2017-10-09\par
\par
Testen.\par
Exception by TypeValidation untersuchen.\par
Da hab ich zwischenzeitlich die Validierung von TypeId-Mappings effizienter gemacht, aber daf\'fcr fehlt eine bessere Unterscheidung zwischen ExistingMappings und PossibleMappings.\par
Einbauen.\par
\par
Fehlende Foundation Implementierungen f\'fcr neue Typen (PersistenceTypeLineageBuilder)\par
\par
Bugfix: Fehlenden Bounds-Check bei Performanceoptimierung in X-Collections nachtragen.\par
\par
\par
Leeres TypeDictionary bei Storage Initialisierung. Initialisierung abgleichen mit Version vor der Typsystemerweiterung.\par
\par
\b PersistenceTypeHandlerManager.initialize()\par
\b0\par
\cf2 v PersistenceTypeDictionaryParser vereinfachen, so dass es nur noch einen einzigen Aufruf von PersistenceTypeDictionary#New gibt.\cf0\par
\par
BinaryTypeDictionaryProviderDefaulting.provideDictionary\par
-> BinaryPersistence.createDefaultTypeDictionary()\par
\par
Ah, Fehler gefunden:\par
Es wird eine PersistenceCustomTypeHandlerRegistry Instanz erzeugt, in der alle default Handlers registriert sind, damit ein Lookup (z.B. basierend auf der Dictionary Datei) sie finden kann.\par
Es gibt aber keine Logik mehr, die die custom Type Handlers initial registriert, falls das Type Dictionary leer ist.\par
Sollte nat\'fcrlich so gel\'f6st werden, dass es m\'f6glichst nur einmal an einer Stelle instanziert wird.\par
Also das ist wieder mal knifflig. Es gibt nun ja keine festen TypeIds in diesen Handlern mehr. Flexibler, sauberer, aber auch komplexer.\par
\par
D.h. der Ablauf m\'fcsste eigentlich sein:\par
- Leere SwizzleRegistry wird erzeugt und bef\'fcllt mit JavaConstants, NICHT mit default TypeId-Mappings\par
- Leeres TypeDictionary wird erzeugt und bef\'fcllt mit Eintr\'e4gen aus der TypeDictionary-Datei (falls vorhanden)\par
- PersistenceCustomTypeHandlerRegistry mit allen CustomTypeHandlers wird erzeugt\par
- F\'fcr alle Eintr\'e4ge aus der Datei werden Runtime Type Definitions (= Handlers) ensured (= lookup auf custom handler oder generische Instanzierung).\par
- je nach match wird die TypeId aus der Datei  in der definition initialisiert oder nach einer default TypeId gesucht oder eine neue vergeben. So oder so wird die damit assoziierte TypeId im TypeManager (= letztendlich SwizzleRegistry) registriert.\par
- alle default TypeId<->Type Mappings werden durchlaufen und optional registriert (d.h. falls es noch keinen Eintrag f\'fcr den Type gibt, wird die TypeId aus dem Default benutzt)\par
- alle CustomTypeHandlers werden durchlaufen und falls noch nicht initialisiert entweder mit einer existierenden default-TypeId oder einer neu vergebenen TypeId initialisiert (alle, die mit den dictionary Entries matchen, sind schon initialisiert)\par
Wichtig ist dabei, dass nicht nochmal neue TypeHandler Instanzen erzeugt werden, sondern dass DIESELBEN instanzen einmalig erzeugt und ab dann immer verwendet/initialisiert werden. Siehe PersistenceCustomTypeHandlerRegistry Instanz.\par
\par
\par
Was ist mit\par
PersistenceFoundation.getTypeDefinitionInitializerProvider\par
?\par
\par
Da wird in \par
PersistenceTypeHandlerManager.internalInitialize()\par
eine neue Instanz von \par
PersistenceTypeDefinitionInitializerProvider\par
erzeugt.\par
Darum wird der Getter in\par
PersistenceFoundation\par
nie verwendet.\par
-> Getter gel\'f6scht. Das ist ein tempor\'e4rer Hilfstyp, ein Werkzeug, kein Bauteil der Persistierungsmaschine.\par
\par
\par
\par
TypeHandlerProvider (ensuren und registrieren, aber auch bypass-ensuren f\'fcr Initialisierungsfall)\par
kennt einen TypeHandlerEnsurer (lookup oder create)\par
und der kennt wiederum die CustomHandlerRegistry (lookup)\par
\par
Was ist der unterschied zwischen einem TypeHandlerManager und dem TypeHandlerProvider?\par
\par
\par
\par
2017-10-10\par
\par
\'dcberblick TypeHandler Managing Typen:\par
\par
PersistenceTypeHandlerManager\par
- Top-Level type system Schnittstelle (direkt im storer) zum Ensuren der TypeHandler.\par
- Kennt PersistenceTypeHandlerRegistry, um nachzuschauen, ob es f\'fcr einen Type schon einen passenden typeHandler gibt.\par
- Kennt PersistenceTypeHandlerProvider, um einen passenden TypeHandler f\'fcr einen noch unbekannten Type zu erzeugen.\par
\par
PersistenceTypeHandlerProvider \par
- Kennt PersistenceTypeHandlerEnsurer (eigentlich ~Creator + CustomHandler-Lookup), um einen TypeHandler sicherzustellen. Registriert einen sichergestellten TypeHandler beim \'fcbergebenen TypeHandlerManager.\par
- Kennt SwizzleTypeManager, um vor dem TypeHandlerProviden das TypeId<->Type Mapping sicherzustellen.\par
- Bietet f\'fcr Initialisierungssonderfall auch direkten Zugriff auf den Ensurer, um zu Initialisierungszwecken einen TypeHandler ohne TypeId und ohne Registrierung beim TypeHandlerManager sicherzustellen.\par
\par
PersistenceTypeHandlerEnsurer\par
- kennt PersistenceCustomTypeHandlerRegistry f\'fcr Lookup nach vordefinierten Custom Handlers.\par
- kennt PersistenceTypeHandlerCreator f\'fcr die Erzeugung eines generischen Handlers bei Bedarf.\par
- macht genau das: lookup oder erzeugung falls n\'f6tig.\par
\par
PersistenceCustomTypeHandlerRegistry\par
- Ist ein Verzeichnis von Type->TypeHandler Mappings\par
\par
PersistenceTypeHandlerCreator \par
- Ist eine Logik zur Erzeugung von generischen TypeHandlers\par
\par
\par
\par
BinaryTypeHandlerEnsurer entzerren in generischen PersistenceTypeHandlerEnsurer und PersistenceTypeHandlerCreator mit Binary~ Implementierung.\par
Unn\'f6tige ~Foundation.internalSet~ Methoden wegmachen.\par
So. Nach dem Cleanup gibt es jetzt nur noch zwei BinaryTypeHandler~ interface: das Ding selbst und einen Creator daf\'fcr. Passt.\par
\par
\par
Jetzt zur\'fcck zum TypeId Initialisierung Ablauf.\par
TypeHandlerManager#initialize entsprechend erweitern.\par
\par
\par
\par
2017-10-11\par
\par
TypeHandlerManager#initialize fertig erweitern um ensureRegisteredCustomTypeHandler.\par
Testen. Paar Bugs fixen:\par
- TypeHandler-Konstruktoren f\'fcr initialie TypeIds \'fcberall rauswerfen.\par
- Fl\'fcchtigkeitsfehler beim Foundation umbauen.\par
- Swizzle Constants k\'f6nnen durch die \'c4nderung nun erst registriert werden, wenn alle TypeHandler Registrierungen abgeschlossen sind.\par
\par
Testen.\par
Exception beim StorageEntityCache initialisieren: TypeId not resolvable via type dictionary: 1000021\par
Irgendwas passt noch nicht. Debuggen.\par
\par
TypeDictionary hat leere Tables. Untersuchen/fixen.\par
\par
Dabei aufgefallen:\par
Es muss sowieso ordentlich getrennt werden zwischen TypeDictionaryProvider (l\'e4dt ein noch unvalidiertes TD in das Programm) und TypeDictionaryManager (verwaltet ein g\'fcltiges TD).\par
TypeDictionaryProvider muss aufgetrennt werden in einen TypeDictionaryImporter und einen reinen TypeDictionaryProvider f\'fcr Instanzierungen.\par
TypeDictionaryProvider benutzende Typen entsprechend umbauen.\par
\par
Dazwischen Frage zu Stand von CK.Gedanken dazu notieren. Statusbesprechung zu TypeRefactoring mit RF.\par
\par
Testen.\par
Wieder bei: TypeDictionary hat leere Tables. Untersuchen/fixen.\par
Da waren in PersistenceTypeLineage#checkViability die R\'fcckgabewerte vertauscht, darum wurde nie was geaddet.\par
\par
Beim Debuggen die Stelle gefunden, wo f\'fcr jede einzelne registrierte TypeDefinition das TypeDictionary neu geschrieben wird.\par
War bisher nur l\'e4stig, w\'e4re jetzt aber ein Bug: Es kann sein, dass beim Refactoring ein Fehler passiert, dann darf das TypeDictionary nicht mit den neuen Eintr\'e4gen geschrieben werden.\par
Oder ist das egal, weil (siehe oben) Entities auch von weiter zur\'fcck veralteteten Typen erkannt und refactort werden m\'fcssen?\par
Hmm...\par
\par
\par
\par
2017-10-12\par
\par
Jup. Das ist besser so. Siehe "TypeConverterProvider" oben.\par
Also redundantes Rausschreiben erst mal so lassen. Ist zwar schon unsch\'f6n (z.B. wenn zwischen dem ersten und dem letzten Rausschreiben eine Exception kommt, wurde die TypeDictionary Datei effektiv gestutzt/ruiniert), aber das kann als TODO f\'fcr sp\'e4ter stehenbleiben. Ist jetzt nicht wichtig und funktioniert ja im Normalfall.\par
\par
Weitertesten.\par
Jetzt wird das TypeDictionary gef\'fcllt.\par
Sortierung fehlt noch. Einbauen.\par
Au\'dferdem toString f\'fcr TypeHandlers implementieren.\par
\par
TypeDictionary#toString wirft eine Exception. Gefixt.\par
\par
In StorageTypeDictionary fehlt trotzdem noch der Handler f\'fcr PersistenceRoots$Implementation (TID 1000021)\par
Da wurde durch die Importer Splittung ein neues TypeDictionary mit der Storage verlinkt anstatt das runtime dictionary.\par
\par
Doch nochmal recherchieren, warum nach dem fertig initialisierten TypeDictionary nochmal ein Update steht. Eigentlich m\'fcsste da die HighestTypeId Bestimmung reichen.\par
Jup, das ist bis auf den Highest-Id-Update ein No-Op. Das mach ich jetz raus.\par
\par
Highest-Id ist dummerweise immer 0. Untersuchen und fixen.\par
Da wurde auch wieder vom importierten (anfangs leeren) anstatt vom runtime-initialisierten gelesen. Gefixt. Passt.\par
\par
Hurra, die MainTestStorageExample ist durchgelaufen.\par
Rausgeschriebene Meta-Dateien sehen soweit auch gut aus.\par
\par
Jetzt Test mit bestehenden TypeDictionary Eintr\'e4gen beim Initialisieren.\par
\par
MatchingTypeDefs und ChangedTypeDefs sind nach Abgleich beide leer. Untersuchen.\par
\par
Ach, das imported TypeDict hat leere caching Tables. Seltsam, bei der anderen Instanz mit demselben Code passt es doch auch. Untersuchen.\par
Dadurch, dass die TypeLineages direkt gef\'fcllt werden, wird die Registrierung \'fcber das TypeDictionary und dessen Cachingtabellen umgangen.\par
Das passt eh alles nicht, dass die TypeLineage sich die TypeDefs selbst erzeugt. Die soll der TypeDictBuilder erzeugen und dann direkt beim TypeDict registrieren.\par
Entsprechend umbauen.\par
Dabei auch Stelle der Aufl\'f6sung zu einer Runtime Klasse umstellen und Methodenaufrufe entsprechend konsolidieren.\par
\par
So, damit ist auch in den MatchingTypeDefs was drin. ChangedTypeDefs sind erwartungsgem\'e4\'df leer.\par
\par
Exception in TypeLineage: Runtime definition already initialized. Untersuchen.\par
\par
\par
\par
2017-10-13\par
\par
Nochmal laufen lassen von vorne, ohne TypeDictionary File.\par
Durch \'c4nderung von gestern n\'f6tigen Null-Check nachtragen.\par
\par
Exception in TypeLineage: Runtime definition already initialized Untersuchung:\par
Achja. Wenn die TypeLineages nicht mehr vorab erzeugt werden, sondern alles \'fcber das TypeDictionary l\'e4uft, muss man aber unterscheiden k\'f6nnen zwischen registerTypeEntry und registerRuntimeType.\par
Das ist jetzt irgendwie doch wieder das gleiche in gr\'fcn. Aber so ist es sauberer.\par
\par
Varianten einbauen.\par
\par
Dabei aufgefallen: latestTypesPerTypeId Table wird falsch bef\'fcllt. Immer nur nach TypeId putten ergibt keine konsistente Auflistung.\par
Das muss bei jeder \'c4nderung aus allen TypeLineages neu hergeleitet werden. Das hatte ich schon mal. Mist :[.\par
\par
Au\'dferdem aufgefallen:\par
Im TypeDictionary sollte bei dem niederrangigen registerTypeEntry zuerst in allTypesPerTypeId geaddet werden und wenn das fehlschl\'e4gt, dann gibt es eine Exception.\par
Beim RuntimeType ist das aber anders, da passt es weiterhin, wie es ist: nachtr\'e4glich Hart putten anstatt adden, weil ja ggf. registrierte Eintr\'e4ge ersetzt werden sollen.\par
\par
Aufgefallen: \par
Beim TypeHandlerManager initialisieren werden die initialisierten TypeDefinitions (in diesem Fall TypeHandlers) beim imported TypeDictionary registriert, was quatsch ist, weil das nach der Methode eh verworfen wird.\par
Ich glaub bei der TypeDictionary Runtime Instanz werden sie schon automatisch registriert \'fcber den Callback w\'e4hrend der Initialisierung.\par
Jetzt bin ich verwirrt und schon wieder so extrem m\'fcde, evtl. noch immer vom Blutspenden am Mittwoch. Das mach ich auch nicht nochmal.\par
\par
Aufgefallen:\par
Werden eigentlich auch alle veralteten TypeDictionary Entries in die TypeDictionary Runtime Instanz registriert? Aktuell sehe ich nicht, wo. Das w\'e4re ein Fehler.\par
Es kann doch nicht sein, dass man an sowas so lang dran sitzt und es immer noch nicht passt.\par
\par
\par
Die PersistenceTypeHandlerManager#internalInitialize ist auch schon viel zu lang. Das ist immer ein Indiz, dass zu viel gewurschelt wird.\par
Mal aufr\'e4umen.\par
\par
\par
\par
Jetzt mal wieder das Konzept nach aktuellem Kenntnisstand von vorn gedacht:\par
\par
- Persistiertes TypeDictionary wird importiert. Besteht nur aus flachen TypeDefinitions (keine TypeHandler). Potenziell leer. Wegwerfinstanz.\par
- Ein gibt eine TypeDictionary Instanz zur Laufzeit. Die ist anfangs leer.\par
- Zu jedem Eintrag im importierten TypeDictionary wird ein TypeHandler f\'fcr den entsprechenden Runtime Type erzeugt, falls m\'f6glich.\par
- Der TypeHandler muss mit einer Initializer Instanz gewrappt werden, weil die TypeId noch nicht bekannt ist. Welche TypeId es wird, kann erst nach bzw. durch das Matching festgestellt werden.\par
- Alle erzeugten TypeHandler werden mit dem importierten Eintrag abgeglichen: Wenn die Feld-Struktur gleich ist, kommt der Handler in die "Matching" Collection, wenn nicht in die "Changed" Collection.\par
- Bei jedem Hinzuf\'fcgen eines "Changed" Eintrags wird ein Callback zur Validierung aufgerufen. Defaultimplementierung: Typedefinition-\'c4nderung erzeugt eine Exception.\par
- Alle Matching TypeHandlers werden mit der TypeId aus dem importierten Entry initialisiert (TypeId bleibt gleich). Das Initialisieren registriert die gleich bei TypeDictionary Runtime Instanz, TypeRegistry, TypeHandlerRegistry.\par
- Danach werden komplement\'e4r zu den schon registrierten Typen alle Default Type<->TypeId Mappings aus der Swizzle Klasse in der TypeRegistry ensure-registriert, damit die schon mal alle da sind.\par
- Dann werden alle Changed initialisiert: Falls es f\'fcr ihren Type aus den Defaults eine TypeId gibt, wird die verwendet. Falls nicht, wird eine neue TypeId zugewiesen. Das Initialisieren registriert auch hier wieder hinten rum alles n\'f6tige.\par
- Wenn die Changed TypeHandlers fertig initialisiert sind, werden sie bei der Callback Logik registriert.\par
\cf1 - Dann werden noch alle Default/Custom TypeHandlers komplement\'e4r ensure-registriert. Auch hier wieder mit TypeId soweit schon bekannt oder neu vergebener. Anmerkung: das sind nur die, die nicht im importierten Type Dictionary stehen.\par
Moment: Das ist Unfug. Die importierten Eintr\'e4ge sind die definitiv relevanten. Registrierte Handler sind erst mal nicht zwangsweise n\'f6tig. Erst, wenn ein Storer beim Speichern darauf st\'f6\'dft. Bis dahin liegen die nur in der CustomRegistry rum.\par
Bei den Default TypeId Mappings ist es aber was anderes: F\'fcr jeden Typ darin soll es immer einen Eintrag geben. Falls das importierte Dictionary keinen vorgibt, dann default.\par
\cf3 Aber nochmal Moment: M\'fcssen dann nicht nach dem Defaults registrieren auch f\'fcr jeden dieser Types TypeHandlers erzeugt und registriert werden? Bzw. deren Registrierung w\'fcrde ja ausreichen. Nur alle Default Type m\'fcssen iteriert werden.\par
Oh Mann. St\'e4ndig ergibt sich irgendwas neues.\par
\cf0\par
\par
\par
Damit w\'e4re in den Laufzeit Strukturen (TypeRegistry, TypeDictionary, TypeHandlerRegistry) abgedeckt:\par
- Default TypeId Mappings\par
- TypeHandlers (generisch erzeugte und gelookupte default/custom) f\'fcr alle importierten TypeDictionary Entries und alle Default TypeId Mappings\par
\cf1 ! Noch nicht abgedeckt: veraltete Eintr\'e4ge aus den importierten TypeLineages\cf0\par
\par
\par
\par
\par
2018-05-08\par
\par
Uuund weiter gehts.\par
Siehe {{\field{\*\fldinst{HYPERLINK https://www.xdevissues.com/browse/OGS-3 }}{\fldrslt{https://www.xdevissues.com/browse/OGS-3\ul0\cf0}}}}\f0\fs28  f\'fcr Probleme mit dem Mergen zwischenzeitlicher \'c4nderungen.\par
Aber das ist halt so schlimm. Die wichtigsten Teile k\'f6nnen leicht ge-copy&paste-t werden. Teilweise muss sich der Code f\'fcr das bessere Legacy-Type-Mapper (LTM) Konzept eh \'e4ndern.\par
\par
Brainstorming zu bisherigen Konzepten und LTM:\par
\par
Jede \'c4nderung an einer Klasse soll einen neuen Eintrag im Type Dictionary mit einer neuen TID erzeugen. Das ist wichtig, weil alte Typen erhalten bleiben sollen, um alte St\'e4nde der Datenbank noch verwenden zu k\'f6nnen. Wenn man f\'fcr eine bestimmte TID die Definition der Klasse bei jeder \'c4nderung umschreibt, sind alle St\'e4nde vor der \'c4nderung unbrauchbar. Besser ist, dass jede Typdefinition im Dictionary f\'fcr sich immutable ist: Einmal erzeugt wird sie nie wieder ge\'e4ndert. Wenn sich eine Klasse \'e4ndert, dann ist das eine neue Definition im Dictionary.\par
Interessant ist noch der Spezialfall, wenn sich eine Klasse durch mehrfache \'c4nderung wieder auf einen fr\'fcher schon definierten Aufbau zur\'fcck\'e4ndert. Soll dann die fr\'fchere Definition inklusive fr\'fcherer TID wiederverwendet werden, oder soll das eine neue, komplett redundante Definition werden? Ich sehe an der ersten Variante kein Problem, au\'dfer dass damit halt nicht mehr gilt, dass immer die h\'f6chste TID einer Typbezeichnung auch automatisch die aktuelle ist. Aber das ist eigentlich kein Problem, wenn man es so sieht: die Klasse wurde tats\'e4chlich auf einen fr\'fcheren Aufbau zur\'fcckge\'e4ndert. Damit wird ganz korrekterweise die fr\'fchere Definition mit der fr\'fcheren TID wieder die aktuelle. Der LTM muss und kann ja eh von jeder Definition zu jeder anderen Definition ummappen, also warum nicht von #17 zur\'fcck auf #6 und bei der n\'e4chsten \'c4nderung eben zu #18.\par
\par
Das hei\'dft f\'fcr die im Type Dictionary enthaltenen Eintr\'e4ge:\par
- Ein full qualified class name kann in beliebig vielen Type Definitions vorkommen.\par
- Eine TID kann nur h\'f6chstens einer Type Definition zugeordnet werden.\par
- Alle Type Definitions mit dem gleichen full qualified class name bilden eine Type Definition Familie, oder "TypeLineage", wie ich es damals benannt hatte. Das trifft es nach wie vor am besten.\par
\par
Eine TypeLineage wird definiert durch den full qualified class name.\par
Jeder full qualified class name kann zu h\'f6chstens einer TypeLineage geh\'f6ren.\par
Eine TypeLineage enth\'e4lt alle TypeDefinitions mit gleichem full qualified class name.\par
\par
Wichtig: Was wir auf logischer Ebene als "Umbenennen eines Typs" betrachten, ist auf technischer Ebene tats\'e4chlich ein TypeLineage Wechsel.\par
Der Typ "com.my.app.customer.Customer" hat mit dem Typ "com.my.app.customer.MyAppCustomer" nichts zu tun. Die geh\'f6ren nicht zusammen. Alle Datens\'e4tze vom Typ "Customer" k\'f6nnen (sehr leicht) f\'fcr den Typ "MyAppCustomer" interpretiert werden, aber technisch sind das zwei unterschiedliche Typen, nicht ein "umbenannter" Typ. Wenn full qualified class names Typen eindeutig identifizieren, dann ist eine \'c4nderung des full qualified class name ein Wechsel auf eine andere Identit\'e4t, nicht eine "Umbenennung". Technisch gesehen kann man einen Typ nicht "umbenennen". Man kann nur einen neuen Typ machen und alle Vorkommen des alten im Source Code refactoren, bzw. bei existierenden Daten in einer Datenbank umschreiben oder - eleganter - mappen.\par
\par
Zu einem full qualified class name kann es eine runtime class geben, muss es aber nicht.\par
\par
Wenn es keine gibt, aber es gibt Datens\'e4tze mit einer TID f\'fcr den full qualified class name, muss es einen Mapping-Eintrag im Refactoring geben, um den Typ auf eine runtime class mappen zu k\'f6nnen.\par
Wenn es so einen Eintrag nicht gibt, ist das ein Fehler, der zu einem entsprechenden Abbruch f\'fchrt.\par
(D.h. Existierende Datens\'e4tze k\'f6nnen nicht interpretiert werden)\par
Wichtig: das gilt nicht f\'fcr jeden Eintrag im Type Dictionary, denn viele davon k\'f6nnen einfach veraltet und unbenutzt sein. Das gilt nur f\'fcr Typen, die tats\'e4chlich mit mindestens einem Datensatz (in seiner aktuellen/letzten Version) vorkommen.\par
\par
\par
Eine TypeLineage hat eine latestDefinition() und eine runtimeDefinition(). Das ist \'fcblicherweise das selbe, muss es aber nicht sein. Siehe oben.\par
\par
\par
\par
TODO:\par
- TypeHandler TID wieder versp\'e4tet initialisierbar machen anstatt konstruktor-initialisiert (copy&paste von altem Branch)\par
- TypeLineage einbauen (copy&paste von altem Branch)\par
- OGS Initialisierung so umbauen, dass erst StorageEntityCache#validateEntities bzw. ein Ersatz den tats\'e4chlich aktuellen Type setzt. Vorer gibt es nur Entries mit leerem Type. Irgendwie in einer vorl\'e4ufigen Entry-Kette.\par
- Unterscheidung zwischen LoadHandler (dort kommt bei Bedarf ein LTM rein) und StoreHandler (das ist immer der Handler f\'fcr den Runtime Type).\par
\par
\par
Versp\'e4tete TypeHandler OID Initialisierung ist soweit umgestellt bzw. vorbereitet, aber die weiteren Schritte sind eine Elendsarbeit.\par
Entweder ich b\'fcgel einfach blind alles dr\'fcber und k\'fcmmer mich um die hunderte Compilerfehler, aber dann kann ich gleich einen git merge machen, oder ich fiesel dutzende Klassen Methode f\'fcr Methode durch.\par
\par
\par
\par
2018-05-09\par
\par
TypeHandler TID Lazy Initialization Umstellung abgeschlossen und getestet.\par
Trennung zwischen PersistenceTypeDefinition und PersistenceTypeDescription \'fcbertragen.\par
TypeLineage und ~Creator \'fcbertragen.\par
TypeDictionary Erweiterung vorbereiten.\par
\par
\par
\par
2018-05-10\par
\par
Also f\'fcr die Integration des alten Branches sind noch zwei Teile n\'f6tig:\par
1.) TypeHandler Instanzierung \'fcbertragen.\par
2.) TypeDictionary mit TypeLineage Erweiterung \'fcbertragen.\par
Danach kann vom neuen Branch aus weitergemacht werden.\par
\par
St\'fcck f\'fcr St\'fcck umsetzen, testen.\par
\par
\par
OMG, ist das eine Fieselei, wenn man das ein halbes Jahr sp\'e4ter nicht mehr im Kopf hat.\par
z.B. nur eine von dutzenden Stellen:\par
\par
TypeDictionaryAppenderImplementation#appendField\par
benutzt im alten refactoring branch:\par
PersistenceTypeDictionary.paddedFullQualifiedFieldName\par
Wie l\'e4uft das im aktuellen?\par
Recherchieren, angleichen.\par
-> Die Methode wurde nur in den Appender verschoben, wo sie hingeh\'f6rt, aber den hab ich noch nicht mit \'fcbertragen.\par
\par
Irgendwie geht das so nicht.\par
Ich kann die Klassen nicht einzeln \'fcbertragen, sonst fehlt immer irgendwo irgendwas und ich muss tausend mal branches wechseln, um das gerade zu ziehen.\par
Ich kann nicht alle Klasse auf einmal \'fcbertragen, weil dann alle zwischenzeitlichen \'c4nderungen weg sind und es tausend Compilerfehler gibt.\par
Einzig vern\'fcnftiger Weg:\par
Schritt f\'fcr Schritt erst mal Type Dictionary Erweiterung \'fcbertragen. Wenn das fertig ist, dann TypeHandler Erweiterungen \'fcbertragen.\par
\par
\par
Aktuelles TypeDictionary Konzept:\par
Es gibt "allTypes", das sind alle TypeDefinitions, die im Dictionary stehen, jede mit eindeutiger TypeId. Also live Types und von diesen verschattete Types mit gleichem Namen.\par
Und es gibt "liveTypes", das sind die TypeDefinitions f\'fcr alle vorkommenden TypeNames, aber jeweils nur die mit der h\'f6chsten TypeId (die "aktuellsten").\par
allTypes wird verwendet beim Dictionary rausschreiben (klar) und in der Storage beim StorageTypeHandler erzeugen, weil die Storage ja STHs f\'fcr ALLE Typen (je TypeId) braucht, nicht nur f\'fcr die aktuellen der Anwendung.\par
\par
Das neue Konzept ist komplexer: Anstatt einfach nur Typen zu "verschatten", gibt es eine TypeLineage. Siehe oben. Eine je TypeName, usw.\par
\par
Eine TypeLineage hat:\par
- nonNull TypeName\par
- mayNull Runtime Type\par
- n TypeDefinitions mit jeweils eindeutiger TypeId\par
\par
Ein "latestTypeDefinition" kann es geben, ist aber einfach nur ein spezieller Getter mit entsprechender Logik (TD mit h\'f6chster TypeId)\par
Es gibt eine "liveTypeDefinition". Das ist eine Referenz auf eine der registrierten, die genau der TypeDefinition entspricht, die aus dem Runtime Type abgeleitet ist.\par
\par
\par
Schritt 1 f\'fcr die Erweiterung:\par
TypeLineage einbauen und ansonsten alles wie bisher.\par
Dazu erst mal aktuelle Implementierung der TypeLineage reviewen und verbessern.\par
TypeDictionary schrittweise erweitern.\par
\par
\par
\par
\par
\par
2018-05-11\par
\par
TypeDictionary Parser usw. ist erheblich umgebaut. Wieder einlesen. St\'e4ndig branches wechseln zum vergleichen.\par
\par
\par
Alt:\par
Es gibt einen Provider, der hat intern einen Loader und einen Parser. Der Loader l\'e4dt den String, der Parser parst und baut gleich das fertige Dictionary.\par
\par
Neu:\par
Es gibt einen Importer, der hat intern einen Loader, Parser und einen Builder. Der Loader l\'e4dt den String, der Parser parst die Entries und der Builder baut aus den Entries das fertige Dictionary.\par
Der Builder hat f\'fcrs Builden einen TypeDictionaryProvider und einen TypeDefinitionCreator.\par
TypeDictionaryProvider hat einen TypeLineageCreator.\par
Der PersistenceTypeHandlerManager verwendet dann schlie\'dflich einen Importer, um ein Dictionary zu erzeugen und l\'e4sst es dann von einem PersistenceTypeDictionaryManager managen.\par
Da ist dann gerade Baustelle im Refactoring Branch.\par
\par
\par
Vielleicht sollte der "Importer" doch besser wieder "Provider" hei\'dfen und der Provider einfach "Creator". Denn was da alles mit der provideten Dictionary Instanz gemacht wird erfordert eine neue Instanz, nicht eine bestehende.\par
\par
Und eigentlich sollte der PersistenceTypeDictionaryManager den Importer (Provider) kennen und on demand aufrufen. Im TypeHandlerManager hat das nix verloren.\par
Achso ... das war fr\'fcher so, musst aber aufgebrochen werden wegen der Typ-Abgleicherei. Oder mal schauen, wie ich das mach. War ja eben noch Baustelle ...\par
\par
\par
2018-05-14\par
\par
Weil die TypeLineages \'fcber das Dictionary gemanaget werden, muss auch das Dictionary eine "registerRuntimeDefinition" Methode haben, glaub ich. Mal checken, wie das im alten branch war.\par
Jup, das muss sich durchziehen. PersistenceTypeDictionaryManager Implementierung aktualisieren. Aufrufer (PersistenceTypeHandlerManager) anpassen.\par
\par
Irgendwie ist der Aufruf von PersistenceTypeHandlerManager#register wirr. Recherchieren. TODOs hinschreiben.\par
\par
PersistenceTypeHandlerManager#internalInitialize Konzept\'e4nderung \'fcberlegen, TODO hinmachen.\par
\par
\par
\par
2018-05-15\par
\par
Compilerfehler ausbessern. Seltsam, dass Eclipse manche Methodenvorkommen mitumbenannt hat und manche nicht.\par
PersistenceFoundation erweitern wo n\'f6tig.\par
PersistenceTypeHandlerManager#internalInitialize Konzept\'e4nderung implementieren.\par
Dabei Typemapping Validierung und Registrierung konsolidieren.\par
Testen, kleinere Fixes. Z.B. #registerRuntimeDefinition(s) Methoden sind noch nicht implementiert. Logik sorgf\'e4ltig durchdenken und nochmal die normalen registerDefinition(s) durchdenken.\par
Benamungen verbessern. Z.B. "Observer" statt Callback. Hilft auch, Namenskonflikte in den Methoden zu vermeiden (d.h. das ist nicht nur Kosmetik).\par
\par
\par
2018-05-16\par
\par
Test und fixes. L\'e4uft durch.\par
Recherchieren im alten Branch, was das mit dem TypeDefinitionInitializer war. Evtl. ist der gar nicht mehr n\'f6tig oder evtl. doch noch.\par
\par
\par
Also es war so:\par
Es gibt einen\par
PersistenceTypeDefinitionInitializer\par
Der wrappt einen TypeId-uninitialisierten TypeHandler\par
Mit #initialize(long typeId) wird der TypeHandler f\'fcr die TypeId initialisiert und beim TypeHandlerManager registriert.\par
\par
Erzeugt werden TypeDefinitionInitializer Instanzen NUR in PersistenceTypeHandlerManager#createTypeDefinitionInitializer.\par
Das macht:\par
latestDictionaryTypeDefinition vergleichen mit als initializer gewrapptem Handler (tdi).\par
Wenn gleiche Struktur, dann:\par
matchingTypeDefinitions.add(tdi)\par
sonst:\par
typeChangeCallback.validateTypeChange(latestDictionaryTypeDefinition, tdi);\par
changedTypeDefinitions.add(latestDictionaryTypeDefinition, tdi);\par
\par
Aufruferkontext von #createTypeDefinitionInitializer:\par
Das ist dann schon die offene Baustelle.\par
Letztendlich war die Idee:\par
- Matchende tdi mit bestehender TypeId der gematchten Dictionary Definition initialisieren.\par
- Nicht matchende mit neuer TypeId initialisieren.\par
\par
---\par
Also sinnvoll ist nat\'fcrlich die versp\'e4tete Initialisierung mit einer passenden TypeId, bestehend oder neu.\par
Aber ob das wirklich so kompliziert gewrappt werden muss, ist jetzt die Frage.\par
Fr\'fcher war auch die \'dcberlegung, dass eine Nicht-matchen mit der latest Type Definition immer einen neuen Typeintrag mit neuer TypeId erzeugt.\par
Inzwischen bin ich eher der Meinung, dass eine perfekt matchende alte Type Definition wiederverwendet werden sollte. Ob die Logik in der Javaklasse inzwischen ganz anders ist, kann der storage v\'f6llig egal sein, so wie es das bei bei allen anderen Klassen ja auch ist. Es z\'e4hlt nur Struktur (Feldtypen, Namen, Reihenfolge).\par
\par
Au\'dferdem ist das Konzept f\'fcr den Legacy Type Mapper nun leicht anders: F\'fcr den aktuellen Runtime Type gibt es immer einen bestimmten Handler und der gilt. Fertig aus.\par
Der eigentliche Teil zum Typ\'e4nderung handeln ist ja nur noch beim laden: F\'fcr eine TypeId muss ein passender LoadHandler gefunden werden.\par
Wenn das der aktuelle ist, super, alles easy. Wenn nicht, muss ein Legacy Mapper erzeugt werden, der alte TypeDefinition der betreffenden TypeId auf den aktuellen Runtime Type mappt.\par
\par
Also f\'fcr die Handler sollte eigentlich ausreichen:\par
- Einmal \'fcber alle TypeDefinitions dr\'fcberlaufen\par
- F\'fcr alle mit existierendem Runtime Type einen Handler ableiten.\par
- Schauen, ob eine TypeDefinition in der Lineage exakt auf den Handler passt.\par
- Wenn ja, dann Handler mit dieser TypeId initialisieren. Wenn nein, dann neue TypeId reservieren und TypeHandler mit dieser TypeId initalisieren.\par
- In beiden F\'e4llen TypeHandler als Runtime Type in der Lineage setzen.\par
\par
Fall 2 plus dieser Punkt ist genau das gleiche, als w\'fcrde die Storage Logik beim Storen auf einen neuen Typ sto\'dfen und diesen registrieren.\par
Es sollte aber noch einen "PersistenceTypeMismatchEvaluator" geben, dem im Fall 2 Handler und Lineage \'fcbergeben werden.\par
Damit kann man bei Bedarf eine Exception werfen, damit nicht munter neue Typen definiert werden, wenn der Mismatch eigentlich ein Versehen war.\par
\par
Das w\'e4re an dieser Stelle alles. Die Sache mit dem LoadHandler TypeId Lookup ist dann eine andere Baustelle.\par
\par
Achja, aber die Sache mit dem "TypeHandlerEnsurer" war noch. Die sollte schon noch umgezogen werden, weil sie besser strukturiert, evtl. sogar n\'f6tig ist.\par
Also recherchieren:\par
\par
PersistenceTypeHandlerProvider\par
PersistenceTypeHandler<M, T> provideTypeHandler(\par
\tab PersistenceTypeHandlerManager<M> typeHandlerManager,\par
\tab Class<T>                         type\par
)\par
\par
|\par
Ruft intern auf zusammen mit einem "this.typeManager.ensureTypeId(type)" Aufruf.\par
|\par
V\par
\par
PersistenceTypeHandler<M, T> provideTypeHandler(\par
\tab PersistenceTypeHandlerManager<M> typeHandlerManager,\par
\tab Class<T>                         type              ,\par
\tab long                             typeId\par
)\par
\par
\par
kennt:\par
\par
PersistenceTypeHandlerEnsurer\par
PersistenceTypeHandler<M, T> ensureTypeHandler(Class<T> type)\par
\par
kennt:\par
PersistenceCustomTypeHandlerRegistry<M> customTypeHandlerRegistry;\par
PersistenceTypeHandlerCreator<M>        typeHandlerCreator       ;\par
\par
\par
PersistenceTypeHandlerCreator\par
PersistenceTypeHandler<M, T> createTypeHandler(Class<T> type);\par
\par
kennt:\tab\par
PersistenceTypeAnalyzer        typeAnalyzer  ;\par
PersistenceFieldLengthResolver lengthResolver;\par
\par
\par
PersistenceTypeAnalyzer\par
XGettingEnum<Field> collectPersistableFields(\par
\tab Class<?>                                               type             ,\par
\tab XPrependingEnum<PersistenceTypeDescriptionMemberField> fieldDescriptions\par
);\par
\par
kennt:\par
PersistenceFieldEvaluator fieldSelector;\par
PersistenceTypeEvaluator  isPersistable;\par
\par
\par
\par
\par
\par
PersistenceTypeHandlerEnsurer#ensureTypeHandler(Class<T> type) wird aber noch an einer zweiten Stelle aufgerufen, n\'e4mlich bei der Initialisierung des TypeDictionaries und der daraus abgeleiteten TypeHandlers.\par
\par
\par
Nebenbei bleich mal die \'fcberenthusiastische PersistenceTypeSovereignty rausschmeissen.\par
\par
\par
BinaryHandlerNativeClass ist im bisherigen Branch noch ein Sonderfall, aber im alten OGS-3 Branch nicht mehr. Genauer abchecken.\par
\par
Also das ist dort ein AbstractBinaryHandlerStateless, weil der name raus ist. Macht Sinn.\par
Den typeLookup gibts immer noch, der wird auch immer noch verwendet, um die ObjectId zu einer Class Instanz aufzul\'f6sen.\par
Aber die Initialisierung dieses Felds ist einfach auskommentiert. Das ist immer null. Lol. Super.\par
\par
Aber mal nachgedacht: Diese \'c4nderung ist nicht richtig. Man kann einen als Datum persistierten Typ selbst nicht einfach nur \'fcber seine TypeId identifizieren. Die entsprechende Klasse k\'f6nnte es inzwischen ja gar nicht mehr geben.\par
Was man braucht, ist der Typename. Selbst, wenn es die zugeh\'f6rige Klasse nicht mehr gibt, ist das die "fachliche", datenm\'e4\'dfige Identit\'e4t des Typs.\par
Wenn man den Typnamen hat, DANN braucht man den typeLookup nicht mehr, denn dann kann man einfach ein Class.forName aufrufen.\par
Interessant ist, was passieren kann/soll/darf, wenn der Typname nicht mehr aufl\'f6sbar ist. Oder wenn der aufgel\'f6ste Type inzwischen eine andere TID hat.\par
Hmm...\par
\par
Das Anpassen kollidiert mit der TypeEnsurer Sache. Also erst das anpassen.\par
\par
Das ist ein verflixtes Zeug mit dem TypeEnsurer. Das neue ist besser, aber da sind so viele Unstimmigkeit abzugleichen.\par
Z.B. im alten ist PersistenceCustomTypeHandlerRegistry ein PersistenceTypeHandlerCreator, was wirr ist. Also erst mal pr\'fcfen, wie das im neuen ist. Branch wechseln ...\par
\par
Die PersistenceCustomTypeHandlerRegistry ist auch komplett umgebaut.\par
Das war damals echt schon ganz sch\'f6n viel Zeug an \'c4nderungen ... ^^.\par
\par
\par
\par
\par
2018-05-17\par
\par
TypeHandlerEnsurer Migration weitermachen. Schritt f\'fcr Schritt.\par
Zuerst mal weiter in PersistenceCustomTypeHandlerRegistry reinschauen.\par
Das verwendet nicht mehr TypeHandler Klassen, sondern TypeHandler Instanzen. Das ist besser, weil die TypeHandler Beschaffung damit nicht "magic" per Reflection passiert, sondern per IDE nachvollzogen werden kann.\par
Aber das "initialize" sollte dann eine Instanz zur\'fcckgeben, um dem TypeHandler Implementierer eine Chance zu geben, eine neue Instanz zu erzeugen, falls eine Implementierung mutable state hat und es im selben Prozess mehr als eine Instanz davon geben muss.\par
\par
BinaryTypeDictionaryProviderDefaulting recherchieren: Neues Registry Konzept verursacht dort Compilerfehler.\par
Im neuen scheint es die Klasse insgesamt gar nicht mehr zu geben.\par
\par
Wird aktuell verwendet in BinaryPersistenceFoundation#createTypeDictionaryProvider: wrapper f\'fcr super-Implementierung.\par
Letztendlich macht die Implementierung einfach nur den Aufruf BinaryPersistence.createDefaultTypeDictionary().\par
Mal checken ...\par
\par
Im alten OGS-3 Branch ist es eigentlich ganz einfach:\par
createTypeHandlerEnsurer\par
-> getCustomTypeHandlerRegistry\par
-> PersistenceFoundation#createCustomTypeHandlerRegistry (exception)\par
-> BinaryPersistenceFoundation#createCustomTypeHandlerRegistry (exception)\par
    return BinaryPersistence.createDefaultCustomTypeHandlerRegistry();\par
\par
So bau ich das im aktuellen auch. Der Rest fliegt raus.\par
\par
BinaryPersistenceRootsProvider nachziehen.\par
Das unsch\'f6ne (potenziell gef\'e4hrliche) "provideRootsClass" kann auch raus laut altem OGS-3 Branch.\par
Hm. Im aktuellen Branch wird da noch ein PersistenceRootResolver ben\'f6tigt. Ich glaub aber, das ist nicht veraltet, sondern neuer als der alte OGS-3 Branch. Mal checken.\par
Dann muss das rootsClass Ding doch wieder sein. Es sei denn, ich w\'fcrde die Root Entries lazy initialisieren ...\par
Provider umgebaut. Perfekte L\'f6sung. Passt. Next.\par
\par
BinaryTypeHandlerCreator nachziehen.\par
Recherchieren:\par
- #createTypeHandler d\'fcrfte keine primitiveHandler mehr erzeugen, sondern bei primitive eine exception werfen.\par
- #createTypeHandler d\'fcrfte f\'fcr BinaryHandlerNativeClass keine Sonderfallbehandlung machen m\'fcssen. Bzw. das d\'fcrfte allgemein kein Sonderfall mehr sein.\par
- #createTypeHandler braucht f\'fcr collectPersistableFields eine TypeManager Instanz. Wie ist das im alten OGS-3 Branch nun gel\'f6st?\par
Ergebnis:\par
Die beiden TypeHandlerCreator sind viel eleganter strukturiert und die TypeManager Referenz ist einfach auskommentiert :-D.\par
\par
So, jetzt sollte soweit alles migriert sein. Morgen testen.\par
\par
\par
\par
\par
2018-05-18\par
\par
Test. Erfolgreich. Passt. Committen.\par
\par
Jetzt noch das PersistenceTypeHandlerProvider TODO machen, das mir bei den Arbeiten aufgefallen war.\par
Das kann tats\'e4chlich vereinfacht werden. Einfach mal die Logik da hinschieben, wo sie hingeh\'f6rt, dann werden die Methodenaufrufe gleich ein St\'fcck einfacher bzw. fast trivial.\par
Test. Erfolgreich. Passt. Committen.\par
\par
Damit kann ich jetzt den ersten eigentlichen Punkt zur Typ\'e4nderung anfangen:\par
Wenn der vom runtime Type abgeleitete TypeHandler zu keiner existierenden TypeDefinition passt, dann als neue mit neuer TypeId registrieren anstatt Exception werfen.\par
\par
\par
\cf1 TODO:\cf0\par
\cf1 - siehe FIXME "Changed TypeId of persisted class"\par
\cf0\par
\par
Das wird gleich wieder kniffliger als gedacht: das TypeHandler ableiten macht dies rekursiv f\'fcr alle in ihm definierten Felder. Jeder Aufruf registriert den Handler.\par
Was f\'fcr die \'c4nderung n\'f6tig ist, ist aber, erst mal nur Handler zu erzeugen, ohne Registrierung und dann zu kucken, mit welcher TypeId aus dem Dictionary die initialisiert werden sollen.\par
\par
Was also n\'f6tig ist, ist Folgendes (orientiert am Plan von oben mit Erweiterungen):\par
- Einmal \'fcber alle TypeDefinitions dr\'fcberlaufen\par
- F\'fcr alle mit existierendem Runtime Type einen Handler ableiten, ABER:\par
> noch nicht f\'fcr eine TypeId initialisiern\par
> noch nicht registrieren\par
> noch nicht rekursiv Typen der Felder durchlaufen und weitere Handler ensuren\par
- Schauen, ob eine TypeDefinition in der Lineage exakt auf den Handler passt.\par
- Wenn ja, dann Handler mit dieser TypeId initialisieren. Wenn nein, dann neue TypeId reservieren und TypeHandler mit dieser TypeId initalisieren.\par
- In beiden F\'e4llen TypeHandler als Runtime Type in der Lineage setzen.\par
- Dann TypeHandler registrieren\par
- Dann TypeHandler Felder rekursiv durchlaufen\par
\par
Es sollte aber noch einen "PersistenceTypeMismatchEvaluator" geben, dem im Mismatch Fall Handler und Lineage \'fcbergeben werden.\par
Damit kann man bei Bedarf eine Exception werfen, damit nicht munter neue Typen definiert werden, wenn der Mismatch eigentlich ein Versehen war.\par
\par
Und es sollte noch zwischengesammelt werden:\par
Alle Handler mit Match und alle Handler ohne Match.\par
Dem PersistenceTypeMismatchEvaluator werden dann die Liste der Mismatch Handler und das TypeDictionary \'fcbergeben.\par
Der kann dann eine Exception werfen, bevor irgendwas registriert worden ist.\par
Dann weiter mit TypeId Initialisierung, Registrierung und rekursivem durchlaufen f\'fcr alle Handler.\par
\par
So sollte es passen.\par
\par
Gut, dass ich die PersistenceTypeHandlerProvider Entzerrung von oben gemacht hab, denn die macht das deutlich einfacher bzw. w\'e4re nun sowieso n\'f6tig.\par
Aber vorher sollte ich noch das "Maybe redundant type dictionary update" FIXME untersuchen, sonst st\'f6rt das beim Umbau.\par
\par
PersistenceTypeHandlerManager#internalInitialize\par
\par
1.) TypeDictionary vom TypeDictionaryManager erzeugen lassen. Ohne irgendwelche Registrierung von irgendwas.\par
2.) Alle Runtime Types (.class und TypeId der latest TypeDescription) in der TypeRegistry registrieren.\par
3.) this.update(typeDictionary) aufrufen\par
4.) F\'fcr jeden Runtime Type einen TypeHandler ensuren (= bei Bedarf erzeugen und registrieren)\par
\par
this.update(typeDictionary) macht:\par
- h\'f6chste TypeId aus dem Dictionary feststellen\par
- den TypeDictionaryManager alle TypeDefinitions des \'fcbergebenen TypeDictionaries validieren lassen.\par
=> was im Ablauf oben sinnlos ist, wenn derselbe Manager das Dictionary gerade erst erzeugt hat.\par
- aktuelle TypeId des Systems updaten, falls n\'f6tig (falls aktuelle kleine als h\'f6chste aus dem Dictionary)\par
=> Das ist sinnvoll\par
- im TypeDictionaryManager alle TypeDefinitions des \'fcbergebenen TypeDictionaries registrieren lassen.\par
=> was im Ablauf oben auich wieder sinnlos ist, weil damit effektiv das cachedTypeDictionary des Managers in sich selbst registriert werden soll (no-op)\par
Nachgepr\'fcft zur Laufzeit: Ist beide Male PersistenceTypeDictionary#Implementation (id=34), d.h. das dictionary wird bei sich selbst registriert.\par
\par
Fazit:\par
Die Update Methode kann schon Sinn machen, aber im obigen Ablauf reicht eine "updateCurrentTypeId" Methode. Der redundante TypeDictionary Quatsch kann raus.\par
\par
Umbauen. Testen. Passt.\par
\par
\par
Jetzt wieder beim Umbau des TypeHandler Erzeugen weitermachen.\par
\par
Aha. Nach einer halben Stunde recherchieren, planen und rumprogrammieren stellt sich raus, dass PersistenceTypeHandlerProvider eben doch auch PersistenceTypeHandlerEnsurer implementieren muss, n\'e4mlich genau um so ein "Durchreichen" von uninitialisierten TypeHandlers realisieren zu k\'f6nnen. Also dann doch wieder so.\par
\par
TypeHandler Erzeugen weitermachen.\par
\par
\par
\par
2018-05-21\par
\par
So! Weiter gehts.\par
Von den ~7 TODOs bei der TypeHandler Erzeugung ist nur noch eins \'fcbrig und das ist trivial. Implementieren, testen.\par
PersistenceTypeMismatchValidator Infrastruktur in der Foundation fehlt noch.\par
Jetzt testen.\par
\par
Bei leerer DB sind im initialize die DefaultHandlers nicht da. Sollten die nicht da sein?\par
Ansonsten l\'e4uft alles durch ...\par
Mal untersuchen.\par
\par
Jup, ist leer. Die Frage ist, wo der beste Platz f\'fcr die default Initialisierung ist. Im DictionaryProvider? Im TypeHandlerManager?\par
Die Dictionary-Ebene handelt eigentlich keine Typen. Default zu registrieren ist schon eine ziemlich hochrangige Sache. Die sollte eigentlich der Type(Handler)Manger machen.\par
Mal einbauen. Sauber umstrukturieren.\par
Testen.\par
Komisch: Jetzt fehlt im "blank" Fall das Update des Dictionaries: Kein write in das File (bzw kein File) und auch kein callback-update des Storage-Dictionaries.\par
Evtl. weil nur die Linaege Instanz aktualisiert wird, ohne dass das Dictionary was davon mitbekommt.\par
Muss ich morgen untersuchen ...\par
\par
\par
\par
2018-05-22\par
\par
Lieber gleich die initialisierten Handler beim TypeDictionaryManager auf einmal registrieren (dann gibt's auch nur einen Write) und schwups, schon gehts.\par
Jetzt noch testen, ob es wirklich keinen Fehler gibt, wenn es verschiedene Varianten einer TypeDescription im Dictionary gibt.\par
Ah: PersistenceTypeDictionaryManager#validateTypeDefinition wirft bei der Verwendung einer \'e4lteren passenden TypeDescription nun einen Fehler, weil currentByTid und currentByName nicht mehr dassselbe sind.\par
Muss angepasst werden. Durchdenken.\par
Also dieser Vergleich muss raus, weil der nicht mehr dem neuen Konzept entspricht.\par
Die sonstige Validierung, also die Members der \'fcbergebenen Definition mit der ge-lookup-ten abgleichen, macht aber schon Sinn, weil in dieser Methode TypeHandlers landen und mit dem Dictionary abgeglichen werden.\par
Ab\'e4ndern und Kommentierung verbessen.\par
Wieder testen.\par
Hehe: Der Exporter nach TypeName wirft jetzt eine Exception, wenn es f\'fcr einen TypeName zwei unterschiedliche Typen gibt. Da muss die TypeId mit rein.\par
Eingebaut in bin und in csv Filebenamung. Getestet. Passt.\par
\par
\par
2018-05-23\par
\par
Gestern getestet:\par
1.) Neuere Definition ohne Daten, \'e4ltere ist die passende und hat Daten.\par
Weitere F\'e4lle testen:\par
2.) \'c4ltere Definition ohne Daten, aktuellere ist die passende und hat Daten.\par
3.) \'c4ltere Definition mit Daten, aktuellere ist die passende und hat keine Daten. Das muss letzendlich beim Daten laden eine Exception werfen. Die zu beheben ist dann Teil 2 der Arbeit.\par
\par
zu 2.)\par
Typehandling funktioniert wie erwartet. Keine Exception. Export funktioniert. Passt alles.\par
\par
zu 3.)\par
Typehandling funktioniert wie erwartet. Exception in BinaryBuilder#createBuildItem, weil der Handler f\'fcr die TID des geladenen Datensatzes nicht gefunden werden kann.\par
Das ist wie erwartet. Hier gehts jetzt mit der Implementierung weiter.\par
\par
\par
Ab hier eigentlich Legacy Type Mapping, aufbauend auf erweitertem TypeDefinition Handling (Lineages, usw.)\par
\par
\par
Zun\'e4chst ist mal komisch: warum gibt es extra TID<->OID Eintr\'e4ge in der SwizzleRegistry? Die TID kommt aus dem Datensatz. Das muss ich recherchieren, evtl. kann das rausfliegen. Spart Speicher, Zeit und Komplexit\'e4t ein.\par
\par
Evtl. muss das Mapper erzeugen doch nicht erst so sp\'e4t in BinaryBuilder#createBuildItem stattfinden, sondern schon vorher beim Storage Initialisieren:\par
Es werden ja eh alle Datens\'e4tze registriert und ihre StorageTypeHandler gelookupt. Wenn dort einer fehlt (bzw. warum hat das dann nicht schon dort gekracht?) kann der Handler entsprechend erzeugt werden, mit Callback in die LoadHandler rein.\par
\par
Aber zur\'fcck zu der seltsames TID Registrierung...\par
Das sieht so aus, als k\'f6nnte es raus.\par
Einfach mal rausl\'f6schen und dann testen.\par
Sieht gut aus.\par
Testen. Passt.\par
Committen.\par
\par
Jetzt zur\'fcck zum eigentlichen Type Mapping. Storage Entry Initialisierung durchschauen. Einlesen ...\par
\par
Eigentlich k\'f6nnte das alles viel einfacher und effizienter sein, wenn die Entities r\'fcckw\'e4rts registriert werden w\'fcrden:\par
Es wird automatisch immer die \'e4lteste Version zuerst registriert und die Daten ggf. gecachet. Vorherige Versionen sind automatisch L\'fccken und werden ignoriert.\par
Problem daran ist: wie iteriert man Entities r\'fcckw\'e4rts, die nur vorw\'e4rts verkettet sind? Pl\'f6d ...\par
Man k\'f6nnte nat\'fcrlich Storage Dateien auf einmal einlesen und dann den Buffer einmal von vorne durchscannen. Wenn die Dateien riesig werden, wird halt auch der (tempor\'e4re) Buffer riesig. Wenn der zu riesig wird, sollte man halt kleinere Dateien w\'e4hlen. Wobei nat\'fcrlich ein Store schon mal eine Giga-Datei erzeugen kann, deren Einlesen dann den Buffer gigantisch gro\'dfe bzw. zu gro\'df werden lassen w\'fcrde. Evtl. muss doch mit einer maximalen Puffergr\'f6\'dfe eingelesesen werden und im ung\'fcnstigen Fall dann mehrfach von der Platte geladen werden.\par
\par
Dann w\'e4re der Ablauf:\par
- Dateien r\'fcckw\'e4rts iterieren\par
- Je Datei m\'f6glichst alles auf einmal einlesen.\par
- Einmal alles vorw\'e4rts iterieren und Offsets merken.\par
- Danach von hinten nach vorne Entities registrieren. Wenn es ein Entity schon gibt (d.h. SP\'c4TERE, NEUERE Version!), dann ignorieren.\par
\par
Vielleicht so machen: Verkettete Liste aus "FileScanSegment":\par
- Offset im File.\par
- L\'e4nge (ist normalerweise gleich der Buffersize, oder weniger)\par
- long[] mit offsets je Entities.\par
- entityCount als size f\'fcr das growing array.\par
\par
Es gibt immer nur einen Buffer mit einer bestimmten Gr\'f6\'dfe (standardm\'e4\'dfig eher gro\'df, sowas wie 10 MB).\par
Standardm\'e4\'dfig wird ein FileScanSegment angelegt.\par
Falls die Datei gr\'f6\'dfer ist ODER falls das offsets array voll ist, wird ein weiteres Segment angelegt.\par
Wenn das Ende der Datei erreicht ist, ist der Buffer noch mit den Daten des letzten Segments gef\'fcllt. Im Idealfall reicht ein Segment f\'fcr die Datei und der Buffer muss nur ein einziges Mal gef\'fcllt werden.\par
Die Segments werden von hinten nach vorne durchlaufen. Idealerweise gibt es nur eins.\par
Das long[] array jedes Segments wird von hinten nach vorne durchlaufen.\par
Jede OID wird nur einmal registriert, d.h. nur die sp\'e4teste/aktuellste Version eines Datensatzes z\'e4hlt.\par
Dabei wird auch gleich der richtige Type festgestellt, usw. Das macht das ganze nachtr\'e4glich validieren, upaten, usw. trivial. Und wahrscheinlich auch die Performance besser, weil nicht millionen \'fcberfl\'fcssige Entry Updates gemacht werden m\'fcssen.\par
\par
Naja, mal genauer recherchieren:\par
Entfallen w\'fcrde f\'fcr n Vorkommen/Versionen eines Entities\par
- alle resetExistingEntityForUpdate im Kollisionsfall (n-1 St\'fcck).\par
- n-1 getType Aufrufe. Einmal muss es trotzdem sein.\par
- Extra updateStorageInformation Aufrufe (auch n-1).\par
- Oh, und, besonders interessant: viel sinnloses Cache F\'fcllen von vorherigen Entities. \par
\par
\par
Hm... aber eigentlich ist es so:\par
Das ist eine tolle Sache, die viel Performance bei der Initialisierung bringen wird, aber f\'fcr das eigentliche Thema Type Mapping bringt das gar nichts.\par
Denn:\par
Die Storage hat ihr eigenes Type System. Auch Entities mit runtimem\'e4\'dfig veraltetem Type werden von der Storage ganz normal verarbeitet f\'fcr GC usw.\par
Erst, wenn die Daten in die Anwendung geladen werden m\'fcssen, gibt es ein Typ-Problem, das gel\'f6st/gemappt werden muss.\par
\par
Wobei allerdings auch so ist:\par
Alle Typprobleme sollten bei der Initialisierung auftauchen und entweder verl\'e4sslich gel\'f6st werden oder einen Fehler mit Abbruch erzeugen.\par
Wenn man das Ding einfach fehlerlos starten kann, aber nie wei\'df, ob irgendwann sp\'e4ter beim Entities laden noch irgendein alter Typ nicht gemappt ist, ist das mindestens nervig oder sogar vertrauenserodierend.\par
Das hei\'dft es m\'fcsste trotzdem gleich in der Storage Initialisierung zumindest eine Art TypeCheckCallback geben, der man die TypeId eines tats\'e4chlich existierenden Datensatzes mal zum "beschnuppen", also TypeHandler-validieren, geben kann.\par
Haha und jetzt schlie\'dft sich der Kreis:\par
Das sollte nat\'fcrlich nicht f\'fcr jedes veraltete Entity passieren, sondern nur f\'fcr die aktuellen Version. Also w\'e4re die Reihenfolgeumkehr und Type-Lookup Invertierung doch wieder n\'f6tig.\par
\par
\par
\par
2018-05-24\par
\par
Es sollte aber nicht so sein, dass bei der Storage Initialisierung per Callback an die Persistence Ebene kommuniziert wird, denn:\par
- Das sind Storage Channel Threads. Die sollten auf keinen Fall Zeug aus der Anwendungsebene direkt aufrufen.\par
- Es sind potenziell mehrere Threads, d.h. es m\'fcsste bei dem Type Handler Mapping dann alles threadsicher sein (vermeidbarerweise/unn\'f6tigerweise)\par
- Man k\'f6nnte so keine Gesamtliste an problematischen Typen erstellen, weil manche Typen evtl. nur ein einem Channel vorkommen (z.B. wenn es nur eine Instanz des Typen gibt)\par
\par
Besser ist:\par
Alle Channels sammeln beim Initialisieren die TypeIds, die tats\'e4chlich verwendet werden.\par
Die werden zu einem zentralen Set zusammengesammelt.\par
Dieses Set gibt die Initialisierung als Ergebnis zur\'fcck.\par
Dieses Ergebnis kann sich der Anwendungsthread, der die Initialisierung gestartet hat, anschauen und wo n\'f6tig auf der Anwendungsseite (Loader usw.) Type Mappings erzeugen oder einen Fehler werfen.\par
\par
Das kann mit der bisherigen, nachgelagerten Validierung auch gemacht werden. Die Initialisierungsumkehr w\'e4re zwar eine tolle Effizienzsteigerung, aber ist daf\'fcr nicht n\'f6tig.\par
Muss ich mal als extra Issue aufmachen.\par
\par
... Hmpf! Oder ist die Umkehr doch n\'f6tig, weil:\par
Momentan geht die Initialisierung davon aus, dass ein Entity / OID immer dieselbe TID hat. Mit der Typ\'e4nderung ist das nicht mehr der Fall.\par
Da m\'fcsste ich jetzt eh erheblich dran rumstricken. Type updaten, usw., das zieht dann wieder die \'fcblichen Detailprobleme und Verkomplizierungen nach sich.\par
Dann kann ich f\'fcr den gleichen Aufwand gleich die bessere Initialisierungsstrategie bauen, die dieses Problem automatisch mitl\'f6st.\par
\par
Also ganz sorgf\'e4ltig \'fcberlegt, damit ich Zeug m\'f6glichst nicht mehrfach programmieren muss:\par
- Storage Files r\'fcckw\'e4rts initialisieren.\par
- Dabei jedes erste (= sp\'e4teste / aktuellste) vorkommen eines Entities/OID registrieren und TypeHandler setzen. Alle \'e4lteren verwerfen.\par
- Wenn alles fertig registriert ist, validieren.\par
- Beim Validieren alle tats\'e4chlich in aktuellen Entities vorkommenden TypeIds zusammensammeln.\par
- Als ergebnis der Initialisierung die Menge der vorkommenden TypeIds an die aufrufende Logik zur\'fcckgeben, damit die die Typen abgleichen und ggf. Mapper sicherstellen oder eine Exception werfen kann.\par
\par
Interessant ist noch folgender Fall:\par
Ein Entity ist im Graph \'fcberhaupt nicht mehr erreichbar, d.h. logisch "gel\'f6scht", aber die Bytes daf\'fcr liegen noch in den Datenbankdateien.\par
Die Initialisierung st\'f6\'dft irgendwann darauf, registriert sie, registriert ihre TypeId, gibt sie an die Persistence Ebene weiter.\par
Diese findet f\'fcr einen Typ, der aus Entwickler sicht "l\'e4ngst gel\'f6scht" ist, wahrscheinlich kein passendes Mapping (falls eins n\'f6tig w\'e4re) und wirft darum evtl. einen Fehler, auch wenn das Entity selbst durch einen Lade-Request niemals abgefragt werden wird, weil es ja eben nicht mehr erreichbar ist. Technisch ist das korrekt, aus Sicht des Entwicklers kann es aber zumindest nervig sein oder als Fehler empfunden werden.\par
Bei der Initialisierung erst mal eine komplette Garbage Collection laufen lassen ist keine praktikable L\'f6sung.\par
Besser ist:\par
Wenn kein Mapping gefunden wird, wird eins implizit angenommen/generiert. Hier k\'f6nnte es noch den Fall geben, dass der ItemMatcher sich nicht sicher ist und r\'fcckfragen muss. Mal sehen, wie das dann gel\'f6st werden kann.\par
Es k\'f6nnte auch eine M\'f6glichkeit geben, veraltete Typen (bzw. TypeIds) definieren zu k\'f6nnen. F\'fcr die wird dann einfach ein best-effort Mapping erzeugt, das aber letztendlich nie verwendet werden wird. Evtl. k\'f6nnte die R\'fcckfrage auch so eine Option bieten: "Ignore Type" oder so.\par
Die Zahl der F\'e4lle, die dann immer noch "Probleme" machen (schlimmstenfalls eine unerwartete Nachfrage, wie ein Typ gemappt werden soll, den der Entwickler eigentlich als gel\'f6scht annimmt), sollte dann sehr sehr gering, d.h. zumutbar, sein.\par
Wer unbedingt will, kann solche "Restf\'e4lle" dann noch mit einer Art Totschlaglogik behandeln. Wobei die dann wieder von unpassend einfachen Annahmen ausgeht und dann schreit jeder, warum da Fehler drin sind.\par
Naja. Mal sehen, was letztendlich daraus wird.\par
\par
\par
Wieder eindenken in StorageDataFileItemIterator Funktionsweise und wie ich da die ge\'e4nderte Buffer Strategie (ein gro\'dfer, in den m\'f6glichst ein File auf einmal reingeht und der dann geff\'fcllt weiterverwendet werden kann) reinbring.\par
Mit einer neuen BufferProvider Implementierung, die beim Bufferproviden ein FileScanSegment anlegt, m\'fcsste es klappen.\par
Mal so implementieren.\par
\par
\par
\par
2018-05-25\par
\par
Die neue Initialisierung ist gestern fast fertig zum testen geworden. Aber einen fiesen Sonderfall gibt es: Es vermerkt und entsprechend durchgereicht werden, wenn ein Entity mit unvollst\'e4ndigen Daten im Buffer ist.\par
Mal recherchieren in StorageDataFileItemIterator#processInputFile und #processBufferedEntities.\par
Erweitern um Flag incompleteLastEntity.\par
Entityregistrierung anpassen.\par
Mal OGS-3 updaten und Mail an MK, TS.\par
\par
\par
\par
2018-05-28\par
\par
Mal schauen, wo und wie ich die Config durchschleifen muss, damit im FileManager der Maximum File Length Wert f\'fcr den buffer vef\'fcgbar ist.\par
Ach, nat\'fcrlich: gar nicht, weil der DataFileEvaluator schon die maximumLength zur\'fcckgibt und der ist schon im FileManager, weil das, naja, der FileManager ist. W\'e4r ja auch bl\'f6d, sonst.\par
Zwischenzeitlich ge\'e4nderte Benamungen angleichen.\par
Wieso sind die Filewerte in dem Ding long statt int? Aktuell ist int das limit, damit die entity fileposition nur 4 byte braucht.\par
Und mal ehrlich: Als maximalgr\'f6\'dfe eines einzelnen Files f\'fcr beliebig viele Files sind 2 GB mehr als ausreichend. Aus Housekeepinggr\'fcnden sollten solche files sogar eher 10 MB gro\'df sein. Da ist 2 GB wirklich enorm.\par
So, alles ge\'e4ndert. Damit muss an den Referenzen zwischen ein Einzelteilen gar nichts ge\'e4ndert werden.\par
\par
validateEntities() muss noch \'fcbernommen und ggf. angepasst werden.\par
Ahja, dazu muss das ganze oldTypes Provisorium Zeug raus.\par
\par
Nebenbei gleich mal die OccuringTypeIds Sammelei implementiert.\par
\par
\cf2 DONE (siehe unten):\par
Hm. Mit dem neuen Initialisierungskonzept ist eigentlich kein Platz mehr f\'fcr einen StorageEntityCacheEvaluator entityInitializingCacheEvaluator. Evtl muss ich den mit einem kleinen Umweg wieder einbauen.\par
\cf0\par
Implementierung nochmal durchdenken und aufr\'e4umen.\par
\par
Ich denke, das mit dem Legacy Type Mapping f\'fcr unerreichbare Entities wird am besten so gel\'f6st:\par
- Wenn man sich \'fcberhaupt nicht auskennt oder sich nicht drum k\'fcmmern will, l\'e4sst man einfach implizit einen generierten Load Handler anlegen, der dann nie verwendet werden wird.\par
- Wenn man sich sicher ist, dass Entities eines gewissen Typs nicht mehr durch Laden erreichbar sind, dann tr\'e4gt man den Typ in das manuelle Refactoring als gel\'f6scht ein (typename -> [nix]).\par
- Wenn beides nicht zutrifft, muss man halt um Himmels willen vorher einen Full GC mit Full File Check mit 0% L\'fcckentoleranz aufrufen, dann sind alle unerreichbaren Entities weg.\par
\par
Eine dieser drei Varianten muss f\'fcr jeden m\'f6glich bzw. zumutbar sein.\par
\par
Code durschauen, aufr\'e4umen, Kommentare verbessern.\par
Nochmal neue Bufferei und Einleserei durchdenken:\par
Es gibt drei F\'e4lle:\par
1.) Entity (irgendeins, potenziell auch das letzte) ist vollst\'e4ndig im Buffer enthalten (Header und Daten bis zum letzten Byte)\par
2.) Buffer endet mit einem unvollst\'e4ndigen Entity (Header vollst\'e4ndig, aber Daten mit minderstens hinterstem Byte oder mehr fehlend)\par
3.) Entityl\'e4nge ist gr\'f6\'dfer als der Buffer. Fieser Sonderfall von Fall 2). \par
4.) Buffer endet mit einem unbrauchbaren Entity (Header unvollst\'e4ndig, gar keine Daten)\par
\par
zu 1): Entity wird registriert, Daten k\'f6nnen gecachet werden.\par
zu 2): Entity wird registriert, Daten k\'f6nnen NICHT gecachet werden. Betrifft nur ganz wenige Entities in der gesamten Datenbank. Sollte nicht merkbar sein.\par
zu 3): FilePosition wird f\'fcr die n\'e4chste Bufferf\'fcllung auf den Beginn des Entities gesetzt. Buffer wird auf die L\'e4nge des Entityheaders begrenzt und somit nur der Entity Header eingelesen. \par
zu 4): FilePosition wird f\'fcr die n\'e4chste Bufferf\'fcllung auf den Beginn des Entities gesetzt, damit es komplett eingelesen wird.\par
\par
Bl\'f6d ist halt: f\'fcr 2) muss es eine extrea Fallunterscheidung in den Registrierungsmethoden geben. Wenn man das Entity einfach nochmal miteinlesen w\'fcrde, k\'f6nnte die entfallen. Die extrem seltene Zusatzarbeit, die Daten eines einzelnen Entities nochmal einzulesen, w\'fcrde insgesamt nicht ins Gewicht fallen. Es gibt aber so oder so noch Fall 3, der so behandelt werden muss. Also kann man Fall 2) eigentlich doch wieder so lassen. Bl\'f6d.\par
Nochmal anschauen, ob man das intelligenter fallunterscheiden k\'f6nnte.\par
\par
Oh, dabei aufgefallen: L\'f6sung f\'fcr StorageEntityCacheEvaluator:\par
Einfach eine zweite Methode #initiallyCacheEntity mit default: return !clearEntityCache. Hehe. Fertig. Dann kann man eine Implementierung machen, die das initiale Cachen anders oder gar nicht macht, aber standardm\'e4\'dfig l\'e4uft alles simpel. Passt.\par
Dann schmeiss ich das in der alten Implementierung auch schnell raus und stell auf das neue um, dann ist der Methodenparameter und der Setter-Grusch schon mal weg.\par
\par
OGS-44 und OGS-3 updaten.\par
\par
Noch paar kleine Fixes machen und auff\'e4llige Stelle mit TODO markieren.\par
\par
\cf1 TODO:\par
- is it really always buffer limit? what about incomplete entities and as a consequence file position resets?\par
\cf0\par
\par
\par
2018-05-29\par
\par
TODO zu buffer limit recherchieren. Ich glaub, das ist falsch.\par
\par
...\par
\par
Eigentlich ... ist dieses ganze Buffer Size Ged\'f6ns und verschiedene F\'e4lle und nur header und bla unn\'f6tige Verkomplizierung.\par
Viel einfacher w\'e4r:\par
Beim Auflisten der Files gleich die maximale L\'e4nge feststellen.\par
Initialisierungsbuffer genau so gro\'df machen.\par
Damit ist unter Garantie der Buffer gro\'df genug f\'fcr jedes file.\par
Damit reicht eine triviale File Iterierung, es gibt keine Sonderf\'e4lle, keine reloads, keinen Segment overhead o.\'c4., jedes Entity ist cacheable.\par
Wenn jemand riesige Files haben will, also 100MB, 500MB, 1 GB, dann braucht der Server beim Starten halt auch einmalig diese Gr\'f6\'dfe im RAM zum initialisieren. Danach wird der wieder freigegeben.\par
Wenn man eine anscheinend so gigantisch riesige Datenbank hat, dann sollte man auch irgendwo noch 1 GB freien RAM rumliegen, so wie das heute jeder dumme Arbeitsplatz-PC hat.\par
Das einzige Problem w\'e4re, h\'f6chst theoretisch, wenn ein Entity mit Speicherposition < MAX_INT mit seiner L\'e4nge \'fcber MAX_INT File length hinausgeht. Dann kann das File nicht mehr am St\'fcck eingelesen werden.\par
Aber ich sag jetzt mal so: in den GB-Bereich sollte man mit storage files eh nie kommen. Und: Sollte es irgendwann mal so weit kommen, muss es halt auch mal file IO ohne das schwachsinnige int limit geben.\par
Das macht alles gigantisch viel einfacher und sicher fehlerfrei.\par
\par
So implementieren. Auslagern in StorageEntityInitializer Implementierung.\par
\par
Testen.\par
FileManager Headfile muss on the fly gesetzt werden, weil der EntityCache das zum registrieren braucht.\par
Oder ich bau das bissl um, dann m\'fcsste es sogar performanter sein und der etwas seltsame Initialisierungszeitpunkt fliegt aus dem EntityCache wieder raus.\par
\par
Testen.\par
Das enqueuen eines Entities im File muss nun r\'fcckw\'e4rts erfolgen anstatt vorw\'e4rts.\par
Umbauen.\par
\par
Testen. Passt f\'fcr ein gro\'dfes File.\par
\par
Config Defaults umbauen, so dass mehrere Files erzeugt werden.\par
Testen. Kleiner Reihenfolge Denkfehler bug. Zeilen umstellen.\par
Testen. Passt.\par
\par
Alten init Code l\'f6schen. Und durch neuen ersetzen.\par
Dabei auch gleich das oldTypes Ged\'f6ns rauswerfen.\par
\par
Testen mit und ohne Entity Data Caching.\par
Interessant: dauert ca. 1,5 mal so lang: 65 statt 45 ms bei 15 MB Daten.\par
Wobei diese Zeiten so oder so ein Witz sind. 3 oder 4 ms pro MB. D.h. ein Gigabyte an Daten geht im Bereich von 3-4 Sekunden. Bei 160 MB sind es sogar nur 480 ms, also eher 3 ms pro MB, selbst mit Caching.\par
\par
\par
\par
2018-05-30\par
\par
So, neue, zum neuen Typversionskonzept passede Initialisierung abgeschlossen. N\'e4chstes Thema.\par
\par
Aktuell sind zwei OGS-3 TODOs im Sourcecode:\par
- in BinaryBuilder#createBuildItem\par
- in StorageManager#internalStartUp\par
Das erste kann sofort wieder raus, weil das durch das zweite bei der Initialisierung vorbereitet anstatt im Betrieb on-demand gemacht werden wird.\par
\par
Nur vorsichtshalber mal checken, wie die beiden zusammenh\'e4ngen:\par
- BinaryBuilder#createBuildItem checkt auf Vorhandensein des TypeHandler im BuildItem.\par
- Das BuildItem kommt vom District, der macht daf\'fcr ein lookupTypeHandler()\par
- #lookupTypeHandler verwendet die Referenz typeLookup\par
- Das ist die PersistenceTypeHandlerRegistry Instanz des PersistenceTypeHandlerManager-s\par
- Die kommt wiederum von der PersistenceFoundation, #createTypeHandlerManager <- #getTypeHandlerRegistry <- #createTypeHandlerRegistry\par
\par
Kurz gesagt: der BinaryBuilder schaut in der zentralen TypeHandlerRegistry nach. Passt.\par
\par
Jetzt ist nur noch die Frage, wie der StorageManager mit dieser verbunden ist. Bzw. das ist jetzt das zweite TODO und das erste kann getrost gel\'f6scht werden.\par
\par
Oh, das wird komplizierter als gedacht.\par
Es ist so:\par
Es gibt zwei Ebenen: Storage und Persistence.\par
Storage k\'fcmmert sich grob gesagt um die Dateien und Cachen von Bin\'e4rdaten.\par
Persistence k\'fcmmert sich um den \'dcbergang von Anwendungsinstanzen zu Bin\'e4rdaten.\par
Die Storage Ebene ist nur an einer Stelle mit der Persistence Ebene verbunden: in der Connection (darum hei\'dft die so).\par
Die erzeugt Storer/Loader, die die Bin\'e4rdatenseite von der Storage Ebene handeln lassen und die Seite des \'dcbergangs zur Anwendung von der Persistence Ebene.\par
Dummerweise kennt der StorageManager selbst bisher nicht die Persistence Ebene und hat damit keinen Zugriff auf die PersistenceTypeHandler Infrastruktur.\par
Mal durchschauen und durchdenken ...\par
\par
Oh, aufgefallen: Der Abgleich muss sogar fr\'fcher als in dem StartUp stattfinden:\par
Schon das Validieren der Entities braucht ja TypeHandler und das sind die aus der Persistence Ebene.\par
Bisher lauscht das StorageTypeDictionary \'fcber einen Callback in der Persistence Ebene mit, ob ein neuer TypeHandler dazukommt und registriert sich den ebenfalls.\par
F\'fcr den Abgleich muss nun der andere Weg m\'f6glich werden:\par
Die Storage Ebene trifft auf einen Type (TypeId), f\'fcr den es keinen TypeHandler gibt und muss das an die Persistence Ebene melden, damit die einen erzeugt. Also einen LegacyTypeMapperHandler.\par
Nat\'fcrlich alle auf einmal und dann werden entweder alle n\'f6tigen Handler erzeugt und registriert, oder es gibt eine Exception.\par
\par
Hei\'dft:\par
- die StorageTypeHandler im StorageType m\'fcssen nun zun\'e4chst mal null sein k\'f6nnen.\par
- Nach der Registrierung aller Entities aber vor der Validierung werden alle Types mit TypeHandler null zusammengesammelt. /!\\ \'e4rgerlich dabei: das l\'e4uft lokal in den StorageChannels, d.h. es muss erst zentral zusammengesammelt werden. Doof.\par
- Wenn die Liste komplett ist (d.h. alle Channels haben ihre lokale Liste gemeldet, der letzte merget alles zusammen), wird die \'fcber irgendwie einen Callback an die PersistenceEbene gemeldet.\par
- Die wirft dann entweder eine Exception f\'fcr einen oder mehrere Typen oder erzeugt Legacy TypeHandler und registriert die in der Registry.\par
- Danach holen sich alle Channels die n\'f6tigen TypeHandler aus der aufgestockten TypeHandlerRegistry und machen wie gewohnt mit der Entity Validierung weiter.\par
\par
Das ist soweit alles straight forward l\'f6sbar, bis auf einen Punkt: wie bringt man den Callback zur Persistence Ebene in den StorageEntityCache rein?\par
\par
Bisher gibt es die Verbindung nur zwischen PersistenceTypeDictionary und StorageTypeDictionary.\par
Was n\'f6tig w\'e4re, ist eine Verbindung zwischen PersistenceTypeHandlerManager und StorageEntityCache und zwar in beide Richtungen.\par
Mal recherchieren...\par
\par
Hm, die Methode, wo die TypeDict Linkerei bisher passiert, EmbeddedStorageFoundation#createEmbeddedStorageManager, sieht daf\'fcr schon mal gut aus:\par
Dort wird der PersistenceTypeHandlerManager initialisiert und der StorageManager erzeugt.\par
D.h. man gibt dem StorageManager den TypeHandlerManager (in Form eines simplen interfaces) mit, der reicht das an die EntityCaches weiter und die verbandeln sich gegenseitig.\par
Der Link zwischen den TypeDicts fliegt dann daf\'fcr raus. War eh bl\'f6d, dass eigentlich passive Datenstrukturklassen aktiv herumkomunizieren. Besser ist, dass die beiden ManagementLogik Klassen kommunizieren und dann jeweils ihre passiven Datenstrukturinstanzen updaten.\par
\par
Ne, Moment mal: die Storage Ebene braucht nur die PersistenceTypeDefinitions aus dem Dictionary und die sind dann TypeLineage erweiterung ja einwandfrei da.\par
Mal live testen, ob das wirklich stimmt... passt.\par
\par
Okay, das hei\'dft: zur\'fcck zur anf\'e4nglichen Vermutung. Man muss nur einen Weg finden, wie der StorageManager mit dem TypeHandlerManager reden kann.\par
Naja und das ist durch die Recherche trivial geworden:\par
In EmbeddedStorageFoundation#createEmbeddedStorageManager ist der TypeHandlerManager verf\'fcgbar und eine Zeile drunter wird der StorageManager instanziert.\par
D.h. die werden mit einem lustigen Interface einfach miteinander verbandelt, dann k\'f6nnen sie quatschen und fehlende Types synchen. Passt.\par
Dass die Dict<->Dict Kommunikation nicht so ganz h\'fcbsch ist stimmt zwar trotzdem noch, aber das lass ich jetzt so, da rei\'df ich wegen kaum mehr als Kosmetik nicht rum.\par
\par
Oder noch besser: Eigentlich geh\'f6rt das nicht in den StorageManager, sondern in den EmbeddedStorageManager, der diesen aufruft. Denn nur im Embedded Fall, bzw. auf der "Seite" der Anwendung, macht es Sinn, an Types herumzuanalysieren und Legacy Mapper anzulegen. D.h. der StorageManager schiebt die IdAnalysis einfach nur noch eins weiter.\par
\par
Der EmbeddedStorageManager holt sich von der Foundation den TypeHandlerManager und damit kann endlich die eigentliche Type-Abgleich-Logik eingebaut werden.\par
\par
Einbauen. Bissl umstrukturieren.\par
\par
\par
OGS-3 updaten.\par
Seltsam, geht nicht. Recherchieren.\par
Ist bei allen OGS Issues so.\par
Issues aus anderen Projekten kommentieren kann ich noch.\par
Das JET Projekt scheint ganz weg zu sein.\par
\par
FH suchen. Im XDEV Jira geht ja gelegentlich mal was mit Berechtigungen schief. Ist nicht da. Mail schreiben.\par
\par
Dann letzten Kommentar in OGS-3 updaten.\par
\par
Vorsichtshalber Text speichern:\par
---\par
edit: 2018-05-30\par
Irgendwie kann ich in OGS Issues keine Kommentare mehr posten, aber noch editieren.\par
Aktueller Stand:\par
2.1 und 2.2. sind fertig.\par
Die n\'e4chsten drei hab ich mehr oder weniger gleichzeitig in Bearbeitung.\par
\par
Ich bin jetzt an dem Punkt, wo die veraltete Typbeschreibung mit der aktuellen Typbeschreibung abgeglichen und daraus ein Mapping erzeugt wird. Inklusive Ber\'fccksichtigung manueller Vorgaben. Daf\'fcr kann, wie in OGS-41 geplant, das manuelle Refactoring Mapping mitverwendet werden, so dass die Implementierung daf\'fcr schon automatisch fertig ist.\par
---\par
\par
\par
\par
2018-05-31\par
\par
Irgendwie ist es komisch, dass das PersistenceRefactoringMapping Ding bisher nur in der EmbeddedStorage Schicht ist, aber jetzt im PersistenceTypeHandlerManager, also der Persistence Schicht, gebraucht werden w\'fcrde.\par
Noch dazu, weil es Persistence~ hei\'dft und eigentliche reine Aufgaben der Persistence Ebene macht. Mal rechechieren.\par
\par
Ergebnis:\par
Also der ganze Block aus PersistenceRootResolver, BinaryPersistenceRootsProvider, PersistenceRefactoringMappingProvider in der EmbeddedStorageFoundation ist eigentlich Zeug der Persistence Ebene. Also eigentlich der BinaryPersistenceFoundation. Witzigerweise ist das einzig andere Feld in der EmbeddedStorageFoundation vom Typ EmbeddedStorageConnectionFoundation und die leitet ab von ... tada: BinaryPersistenceFoundation.\par
Hei\'dft: diese Teile sind in der EmbeddedStorage Ebene eigentlich deplatziert, sondern geh\'f6ren in die Persistence Ebene und deren Foundation. Wir das mit dem einen Binary~ Ding ist, ob man das noch zu Persistence~ allgemein abstrahieren kann, muss ich mal noch checken.\par
Dann ist das RefactoringMapping Zeug ordentlich in der Persistence Ebene und der TypeHandlerManager kann es mit \'fcbergeben bekommen. Passt.\par
\par
Jup. Das kann abstrahiert werden. Die Verwendung davon gibt ja sogar eh nur ein PersistenceRoots zur\'fcck, also war die zu spezifische Typisierung Bl\'f6dsinn. Ab in die PersistenceFoundation mit dem Zeug.\par
\par
Die zwei getRootResolver und provideRootResolver sind irgendwie seltsam. Provide~ Methoden gibts in der Foundation eigentlich nicht.\par
Mal recherchieren.\par
\par
Umbenannt auf getRootResolver und getEffectiveRootResolver, was deren eigentlichem Verhalten/Zweck entspricht.\par
\par
Und jetzt ist die interessante Frage: warum hei\'dfen in den Foundations die Provider-Methoden, die ja typische Provider-Arbeit machen, get~ und nicht provide~?\par
Dadurch kann es n\'e4mlich auch keine wirklichen getter geben.\par
\par
Das Roots Zeugs nach PersistenceFoundation zu verschieben und trotzdem nur sch\'f6n einfach die EmbeddedStorageFoundation zu verwenden, war etwas kniffliger als gedacht. Aber funktioniert und jetzt ist das Zeug dort, wo es hingeh\'f6rt.\par
\par
Nun das bestehende RefactoringMapping im dazukommenden TypeHandlerManager Code einsetzen.\par
Nice, dann ist damit schon  mal das Mapping von einem Type auf einen anderen drin.\par
\par
Testen, ob default root und custom root nach der Umstellung noch gehen.\par
Kleiner Fl\'fcchtigkeitsfehler in der Testklasse (store(MY_ROOT.get()) anstatt store(MY_ROOT)) und daran ewig rumdebuggt, aber kaum macht mans richtig, schon gehts.\par
\par

\pard Issue OGS-3 updaten:\par
\par
edit 2018-05-31:\par
Kleines Update:\par
Die neue RootResolving- und RefactoringMapping-Logik aus OGS-41 war auf der EmbeddedStorage Ebene, obwohl das alles nur Zeug der allgemeinen Persistence Ebene ist. F\'fcr Punkt 2.5 (also User-Mapping ber\'fccksichtigen k\'f6nnen) w\'e4re es nun aber auf der Persistence Ebene n\'f6tig geworden. An zwei Orten haben, die potenziell inkonsistent zueinander oder selbst im g\'fcnstigsten Fall verwirrend und umst\'e4ndlich zu verwenden w\'e4ren, w\'e4re bl\'f6d, also musste konsolidiert werden: reines Persistence Zeug auf die Ebene, wo es hingeh\'f6rt. Enthielt ein paar knifflige Details, aber jetzt passt diesbez\'fcglich alles, inklusive Test, ob das Root Resolven noch geht (default und custom).\par

\pard\sl276\slmult1\par
\par
\par
2018-06-01\par
\par
Gleich mal den "DeletedTypeHandler" implementieren. Wobei jetzt die interessante Frage ist: Soll der wirklich eine Exception werfen, oder soll er einfach als instanz null zur\'fcckgeben?\par
Hm, oder einen Provider daf\'fcr machen, der das entscheiden l\'e4sst?\par
\par
Handler implementiert, aber immer noch kein Ergebnis, ob die eine oder die andere Variante immer besser ist.\par
Letztendlich ist es bei sowas immer das gleiche: Provider bauen mit sinnvollem Default. Wenn's jemandem nicht passt, soll er die eine Zeile Code aufwenden, um es anders zu machen.\par
\par
Entsprechend einbauen. Methoden im TypeHandlerManager umstrukturieren bzw. weiter implementieren, soweit m\'f6glich.\par
Damit bleibt nun nur noch der Fall, alte und neue type definition zu vergleichen und einen LegacyMapper daraus abzuleiten.\par
Dann fertig (yay).\par
\par
Noch PersistenceFoundation um PersistenceDeletedTypeHandlerCreator erweitern.\par
Und Testen w\'e4re auch nicht schlecht.\par
\par
Ah, nullpointer beim TypeLineage lookup-en, wenn es f\'fcr einen Typ im Dictionary keinen Runtime Typ gibt. Ist ja klar. Lookup Methode umbauen von Class Parameter (von dem letztendlich eh nur der name verwendet wird) auf nur name.\par
Testen. Passt.\par
\par
Refactorings Mapping Eintrag bauen. Hm. Convenience Setter in EmbeddedStorageFoundation einbauen.\par
Testen.\par
Ahja, Registrierung des Deleted Handlers fehlt noch. Bissl recherchieren, einbauen.\par
Testen.\par
Haha, Mist. Die PersistenceTypeHandlerRegistry will den type registrieren, um die Konsistenz zu \'fcberpr\'fcfen und zu wahren. Aber die Deleted Dumm Handler haben keinen Typ. Darum ja Deleted.\par
Eigentlich kann das nur \'fcber eine "Hintert\'fcr"-Registrierm\'f6glichkeit in der Registry gel\'f6st werden. Aber das ist gef\'e4hrlich. Oder ich mach einen expliziten Typ "DeletedTypeHandler" und nur solche kann man dort registrieren.\par
Ich glaub, so mach ichs.\par
\par
Dabei aufgefallen: das gleiche in gr\'fcn werd ich f\'fcr die "normalen" LegacyTypeHandler brauchen. Also gleich noch eine Typebene reinzimmern und die Hintert\'fcr darauf typisieren.\par
Testen. Passt auf Anhieb.\par
\par
\par
Ab hier Elternzeit / Homeoffice\par
\par
\par
2018-06-05\par
\par
14:30\par
Issuetracker Login usw.\par
Branch auschecken, Git-Problem. Mail an RF.\par
Rumprobieren, geht wieder. Mail an RF.\par
15:00\par
\par
Zwischen 18:00 Uhr und 21:45:\par
Ca. 30 Minuten Code Review Jetstream Performance Test und Kommunikation.\par
\par
\par
2018-06-06\par
\par
Ca. 1h f\'fcr Performance Test \'dcberlegungen. Datenebenen usw.\par
15 Minuten Kommunikation mit MK.\par
\par
\par
2018-06-07\par
\par
Ca. 1h f\'fcr Performance Test \'dcberlegungen. Datenebenen usw.\par
30 Minuten  Telefonat mit RF zu Performance Tests. (14:00 - 14:45 abz\'fcglichen privaten Smalltalk).\par
15 Minuten Kommunikation mit MK.\par
\par
\par
2018-06-21\par
\par
Ca. 1h f\'fcr weitere \'dcberlegungen Performance Test Datenebenen und Vergleichbarkeit von Datenbankl\'f6sungen.\par
Ca. 1h f\'fcr Kommentar zu Jetstream Verwendung mit Android ({{\field{\*\fldinst{HYPERLINK https://www.xdevcollaboration.com/display/JET/Android }}{\fldrslt{https://www.xdevcollaboration.com/display/JET/Android\ul0\cf0}}}}\f0\fs28 )\par
\par
\par
2018-06-22\par
\par
Ca. 0,5h f\'fcr OGS Code Hinweis f\'fcr Performance Tests und StorageEntityCacheEvaluator Code \'c4nderungen f\'fcr Ableitbarkeit.\par
Ca. 0,5h f\'fcr OGS Code Hinweis bzgl. SwizzleRegistry Reset f\'fcr Performance Tests und SwizzleRegistry Zugriff Verbesserungen.\par
\par
\par
2018-06-23\par
\par
Ca. 1,0h f\'fcr Fertigstellung und posten von Performance Tests \'dcberlegungen.\par
\par
\par
\par
Elternzeit Ende.\par
\par
\par
2018-09-03\par
\par
Hui! Schon \'fcber ein Jahr seit Tagebuchbeginn. Aber nat\'fcrlich nicht 1 Jahr dran gearbeitet.\par
Wieder einlesen/eindenken.\par
\par
Also jetzt w\'fcrde es eigentlich weitergehen mit dem ItemMatcher. Oder sollte vorher noch auf einen perfekten Match gepr\'fcft werden? Oder ist das nur unn\'f6tige Code Verkomplizierung? Die Performance f\'fcr die Matcherei spielt hier ja keine Rolle.\par
Mal Matcher Beispiel anschauen.\par
\par
Dabei kleinen, aber krassen Giga-Bug in X.List() entdeckt. Recherchieren, wann ich den warum verbrochen hab und was davon noch betroffen ist.\par
Sonst nix. Fixen. Committen.\par
\par
Weiter\'fcberlegen. Itemmatcher wieder anschauen. Testklasse bissl verbessern.\par
Hm, aber vor dem Matching stuff muss erst mal nach expliziten Mappings gesucht werden. Und die m\'fcssen dann in den matcher einfliesen, damit sie die Mehrdeutigkeitenreduzieren.\par
\par
\par
2018-09-04\par
\par
Also zun\'e4chst mal recherchieren, ob man in dem ItemMatcher eine Bevorzugungsmap einspeisen kann.\par
Nein, kann man nicht. Oder macht man das \'fcber einen Similator mit Similarity 1.0?\par
Mal \'fcberlegen ...\par
Eigentlich nicht, weil das was anderes ist:\par
Ein explizites Mapping kann vorgeben: "Hans" in Source soll auf "Sepp" in Target gemappt werden, selbst dann, wenn es in Source selbst einen "Sepp" gibt.\par
W\'fcrde man nur eine \'c4hnlichkeit von 1.0 verwenden, g\'e4be es keine Bevorzugung mehr, sondern einfach nur zwei Paare mit 1.0.\par
Hei\'dft:\par
Es muss auf jeden Fall eine Vorzugsmap geben.\par
Die Frage ist nat\'fcrlich, ob die in den Similator rein muss oder ob man nicht eher vor der Anwendung des Matchers die expliziten Zuordnungen einfach raus nimmt.\par
Ja, das ist sinnvoller. Beim Matcher gehts um \'c4hnlichkeit und nicht darum, \'c4hnlichkeitslogik auszuhebeln.\par
\par
Davon abgesehen ... wenn ich mir den Code (Kommentare von 2011!) so anschau: Da muss ich einiges \'fcberarbeiten:\par
- Java 8 Features\par
- verk\'fcrzte Bezeichner und seltsame Bezeichner ordentlich benennen.\par
- premature performance optimizations (quantifier) rausnehmen\par
- String Assembly Logik in eigene Klasse verschieben.\par
- Blanke API Klassen durch Interface ersetzen.\par
Ist zwar alles nicht tragisch und es funktioniert auch so, aber wenn der Matcher nun (endlich) produktiv verwendet wird, sollte die Code Qualit\'e4t schon den \'fcblichen Standard haben.\par
\par
\par
2018-09-05\par
\par
Ist soweit fertig bis auf die Quantifier Entfernung. Da schreib ich aber mal nur ein TODO.\par
\par
Jetzt bei der eigentlichen Baustelle weiterdenken:\par
Zuerst m\'fcssen mal die expliziten Mappings eingelesen werden.\par
Dann m\'fcssen die explizit zugeordneten Felder auf beiden Seiten per Namen rausgesucht werden (evtl. gleich in eine XTable reinpacken).\par
Knifflig: Felder mit gleichen Namen in unterschiedlichen Klassen. Wichtig!\par
\par
Erst mal wieder in die schon existierende Mapping Funktionalit\'e4t einlesen. PersistenceRefactoringMapping und OGS-41.\par
\par
Wieder Eindenken zieht sich ... wo wird PersistenceRefactoringMapping schon verwendet? Ist der "#" als Trennzeichen schon irgendwo zentral definiert?\par
...\par
Ah! Das ist schon im TypeHandlerManager und wird sogar schon f\'fcr das TypeName Mapping verwendet.\par
Dann muss man quasi das gleiche in gr\'fcn einfach nur f\'fcr die Felder machen. Allerdings: Mit full qualified field names und optionalen Vereinfachungen\par
\par
Mal so implementieren ...\par
\par
Hm, noch eine Verkomplizierung: Field Members und PseudoField Members.\par
Hm. daf\'fcr in PersistenceTypeDescriptionMember noch #uniqueName und #declaringTypeName nachr\'fcsten, kommentieren und PersistenceTypeDescriptionMemberField anpassen.\par
Eigentlich ist f\'fcr die Identifizierung eines Felds dann sogar ein doppelter Qualifier n\'f6tig: definingType#DeclaringType#fieldName. Denn es kann ja sein, dass ein deklariertes Feld einer Superklasse entfallen soll und in verschiedenen Kindklassen unterschiedlich gemappt werden soll.\par
Dann muss ich aber wirklich Erg\'e4nzungslogiken bauen, um manche Teile des Identifiers wegzulassen, sonst drehen wieder alle durch, wie kompliziert es ist.\par
Wobei man das auch nicht zu sehr vereinfachen darf, sonst entstehen ungewollte Mehrdeutigkeiten.\par
Was auf jeden Fall geht ist: Wenn defining und declaring type gleich sind, reicht es, den type einmal zu schreiben.\par
\par
Hm, ne, es ist noch kniffliger:\par
Wenn ich das so mache, dann m\'fcsste man bei einem ge\'e4nderten Feld f\'fcr jede Kindklasse einen Eintrag machen. Also hundert Kindklassen, hundert Eintr\'e4ge. Da dreht jeder durch. Zurecht.\par
Also muss es so sein:\par
[typeName]#[fieldName] wird intepretiert als declaringClass Eintrag und der gilt allgemein in allen Kindklassen.\par
Das sollte auch der Normalfall sein: Ein Feld \'e4ndert sich designstrukturm\'e4\'dfig eher innerhalb derselben Klassen, nicht \'fcber Klassen hinweg.\par
\par
Als Sonderfall kann man dann auch noch schreiben:\par
[typeName]#[typeName]#[fieldName]. Das wird interpretiert als Eintrag, der nur f\'fcr die definingClass gilt.\par
\par
Beispiel:\par
Klasse A definiert ein Feld "lastName".\par
Klasse B extends A.\par
Nun soll in Klasse A das Feld "lastName" gel\'f6scht werden. Also Eintrag: C#lastName -> [null].\par
Die Klasse B hat aber ein Feld "lastName" dazu bekommen (sprich: im Design ist das Feld von A nach B verschoben worden). D.h. die vorhandenen Daten f\'fcr "lastName" sollen im Fall von B Instanzen nicht verloren gehen, sondern weiterhin im daf\'fcr vorgesehenen Feld "lastName" stehen. Wie bringt man das dem Refactoring bei?\par
So:\par
B#C#lastName -> B#lastName\par
\par
Diese Struktur ist NICHT hierarchisch, d.h. bei C extends B extends A kann man NICHT schreiben C#B#A#lastName und ein Eintrag B#A#Lastname gilt NICHT automatisch auch f\'fcr die Klasse C.\par
Es gibt immer nur die zwei Klassen: "DefiningClass" (die konkrete, aktuelle Klasse) und "DeclaringClass" (die, in der das Feld steht).\par
Hier muss man dann tats\'e4chlich zwei Eintr\'e4ge f\'fcr dasselbe Feld machen. Einen f\'fcr Klasse B und einen f\'fcr Klasse C. F\'fcr derartige Sonderf\'e4lle sollte das aber zumutbar sein.\par
\par
Jetzt ist noch die Frage nach der Priorit\'e4t:\par
Wie immer: je spezifischer, umso wichtiger.\par
1.) [typeName]#[typeName]#[fieldName]\par
2.) [typeName]#[fieldName]\par
Alles, was in 1 oder 2 gefunden wird, wird als definite Match registriert und rausgenommen. Der Rest geht ins:\par
3.) Similarity Matching\par
\par
So implementier ich das jetzt mal. Mal sehen, ob dabei noch was auftaucht.\par
\par
\par
2018-09-06\par
\par
Implementierung weitermachen.\par
\par
Dabei aufgefallen: PersistenceTypeDescription#members sollte eigentlich eine Enum sein: einzigartige Elemente mit Reihenfolge. Ist aber nur eine Sequence.\par
Recherchieren.\par
Dabei aufgefallen: Beim TypeDictionary einlesen wird die Einzigartigkeit nicht gepr\'fcft. Erst mal alle Eintr\'e4ge, auch mit potentiellen Inkonsistenzen, in eine List stecken, ist ja okay, damit man damit arbeiten und ggf. Fehler anzeigen kann.\par
Aber bevor eine Description gebaut wird, muss das in eine Enum gesteckt werden zur Validierung. Das ist genau das, was fehlt.\par
Und dabei aufgefallen:\par
Hehe, es gibt schon hier zwei Arten von Equality:\par
1.) Datenm\'e4\'dfig definierte Identit\'e4t. In diesem Fall: UniqueName\par
2.) Gleichheit der Definition (Declaring Class, Type, Name) f\'fcr eine Validierung des Dictionaries gegen\'fcber der Runtime.\par
Das muss ich umbauen. Dann kann PersistenceTypeDescription#members auch eine Enum werden und dann kann ich beim Refactoring gesichert davon ausgehen, dass die Members einzigartig sind.\par
\par
Hmpfl, dabei aufgefallen: Der DescriptionMemberEqualator hat ein bisschen wirres Konzept mit den \'dcberladungen und instanceof checks.\par
Besser ist die Unterscheidung oben: Identit\'e4t oder ganze Definition.\par
Nochmal genauer Recherchieren, was der Grund daf\'fcr ist und ob das Sinn macht.\par
Ne, eher nicht.\par
\par
\par
\par
2018-09-07\par
\par
DescriptionMemberEqualator l\'f6schen und durch einfacheres, normaleres equality Konzept ersetzen. Dabei gleich UniqueName Identity Equality dazubauen.\par
HashEqualator usw.\par
Die Umstellung von PersistenceTypeDescription#members von Sequence auf Enum hat sich einmal quer durch die TypeHandling Klassen gezogen.\par
Dabei gleich zentralisierte Methode PersistenceTypeDescriptionMember#immureValidated implementiert.\par
\par
\par
2018-09-10\par
\par
Nochmal Implementierung von Freitag durchchecken und durchdenken. Benamung bissl verbessern. Passt.\par
Jetzt weiter im Text: TypeDescription Members abgleichen.\par
\par
Interessant:\par
Ich hatte zuerst Table<PersistenceTypeDescriptionMember, String> Target Mappings. Intuitiv von Source nach Target.\par
Aber es muss genau umgekehrt sein:\par
Table<String, PersistenceTypeDescriptionMember>, also ein Lookup von Target nach Source mit eindeutigen Target Member Identifier Strings.\par
Denn:\par
1.) Die Einzigartigkeit der Source Members ist ja eh schon garantiert, die m\'fcssen keine Keys sein.\par
2.) Es muss aber auch die Einzigartigkeit der Targets Strings garantiert sein, sonst k\'f6nnten ja mehrere Source Members zum selben Target Field aufgel\'f6st werden. Darum m\'fcssen das die Keys sein.\par
3.) Der Lookup erfolgt "r\'fcckw\'e4rts" \'fcber testweise konstruinierte Identifier, nicht "vorw\'e4rts" \'fcber die Source Members.\par
\par
\'dcberlegung zu Sonderfall:\par
K\'f6nnte es sein, dass ein Source Member auf mehrere Target Members kopiert werden soll? Dann d\'fcrfte die Zuordnung nicht 1-zu-1, sondern m\'fcsste 1-zu-n sein.\par
Ergebnis: theoretisch ja, aber soetwas w\'e4re designtechnisch immer Unsinn: Welchen Vorteil soll es haben, in einem Datensatz denselben Wert zu duplizieren? Alle vorstellbaren Antworten darauf sind eine Sache der Anwendungslogik (zwei Getter f\'fcr denselben Wert. Oder falls es aus irgendwelchen Strukturkompatibilit\'e4tsgr\'fcnden n\'f6tig werden w\'fcrde, dann m\'fcsste eine Refactoringlogik auf Ebene der Anwendung nach nachpflegen. Wenn man anf\'e4ngt, das in die Datenbankebene zu schieben, dann braucht man auch Arithmeti, Funktionen, Custom Funktionen und schwups, ist man dabei, eine eigene Sprache zu implementieren. Nene, auf der Datenbankebene werden mit 1-zu-1 Zuordnungen alle Daten sauber umgeformt. Alle weiteren Bl\'f6dsinnsspielereien dar\'fcber muss man selber schreiben. Durch ein Script oder durch einen CustomLegacyHandler. Beides liefert einwandfreie Ergebnisse ohne Nachteile.\par
Fazit: 1-zu-1 reicht.\par
\par
Entsprechend umbauen.\par
\par
Ah, coole Idee:\par
Ein Array an IdentifierBuilder Funktionsobjekten machen, die dann dynamisch durchgecheckt werden, ob f\'fcr ein TargetMember mit der entsprechenden Logik ein Mapping gefunden wird.\par
Einbauen ...\par
\par
Hm, jetzt bin ich verwirrt: Wieso hab ich zwei unterschiedliche Maps f\'fcr defining Class und declaring Class gemacht? Falls es um Priorit\'e4t geht, w\'e4re das ja mit der Reihenfolge der IdentifierBuilder abbildbar.\par
Recherchieren ...\par
Jup. Das kann raus.\par
\par
\par
\par
2018-09-11\par
\par
Umstrukturierung auf IdentifierBuilder abschlie\'dfen.\par
toUniqueUnqualifiedIdentifier() implementieren.\par
MultiMatcher noch bissl aufr\'e4umen und provisorisch einbauen.\par
\par
Das sollte alles in einen eigenen "Member Mapper" oder sowas gekapselt werden.\par
Dazu mal schauen, wie das mit dem anderen TODO ist: custom legacy handler lookup. Kann der da auch rein oder muss das vorher passieren oder muss das unabh\'e4ngig sein?\par
\par
Warum l\'e4uft das in EmbeddedStorageManager#createLegacyTypeMappings \'fcberhaupt \'fcber TypeIds?\par
Recherchieren und besser kommentieren ...\par
\par
Also mal ganz von vorne:\par
EmbeddedStorageFoundation#createEmbeddedStorageManager macht den ganzen Setup Grusch, importiert das TypeDictionary.\par
Dabei wird auch der TypeHandlerManager initialisiert. Allerdings nur f\'fcr alle Runtime TypeLineages.\par
Macht ja Sinn: Alles aus dem Dictionary, was per Klassenname direkt in der Runtime gefunden wurde, bekommt - f\'fcr die aktuelle Version - gleich mal einen TypeHandler.\par
\'dcbrig bleiben aus dem Dictionary alle Klassennamen, die keinen Runtime Type haben (evtl. umbenannt worden) und alle \'e4lteren Versionen aktueller Klassennamen.\par
Danach kommt im Wesentlichen nur noch das EmbeddedStorageManager#start.\par
Da drin werden alle vorkommenden TypeIds durchlaufen und TypeHandler daf\'fcr sichergestellt.\par
Bei allen schon existierenden passiert gar nichts. Gibts schon. Passt.\par
F\'fcr alle anderen wird versucht, ein LegacyHandler zu erstellen und wenn das nicht geht (neuer Typ oder TypeId ist die der aktuellen runtime Type TypeDefinition), dann wird ein normaler TypeHandler erzeugt.\par
Da sind jetzt ein paar Redundanzen drin, aber das kann davon kommen, dass eine allgemeine Funktionalit\'e4t aufgerufen wird, die auch in einem anderen Kontext korrekte Ergebnisse liefern muss. Die in diesem Kontext schon behandelten Typen werden einfach \'fcbersprungen, also kein Problem.\par
Was aber seltsam ist, ist, warum \'fcberhaupt nur \'fcber die TypeId gegangen wird.\par
Sinnvoll ist auf jeden Fall schon mal, dass das nicht alle im Dictionary vorkommenden TypeIds sind, sondern alle wirklich in der Datenbank vorkommende. Das hei\'dft es wird nur f\'fcr die n\'f6tigen Typen ein Legacy Mapper erzeugt, nicht f\'fcr irgendwelche l\'e4ngst irrelevant gewordenen Dictionary Uralt-Eintr\'e4ge.\par
Hm. Man kann zwar die TypeId \'fcber das Dictionary zu einer TypeDefinition aufl\'f6sen, das wird in dem tryLegacyTypeHandler() auch gemacht, aber sollte das nicht vorher und an zentraler Stelle gemacht werden?\par
Also so:\par
- Alle vorkommenden TypeIds sammeln.\par
- Alle zu TypeDefinitions aufl\'f6sen.\par
- Wenn bei einer kein (veralteter oder aktueller) Dictionary Eintrag gefunden wird, dann Exception werfen, denn das hei\'dft dann, dass Stuff in der Datenbank liegt, f\'fcr den das TypeDictionary keinen Plan liefern kann.\par
Oder wird das vorher schon gemacht in dem IdAnalysis Zeugs?\par
Recherchieren ...\par
Ne, da wird noch nix validiert. Bzw: Storage-intern wird bei jedem TypeId Lookup nat\'fcrlich geschaut, ob es im StorageTypeDictionary daf\'fcr einen Eintrag gibt. Hm. Da das vom normalen TypeDictionary ableitet, k\'f6nnte man das durchaus als Validierung sehen.\par
Also das hier: StorageEntityCache#addNewType: "TypeId not resolvable via type dictionary".\par
Hm. Oder sollte die Anwendungsseite ihre TypeDefinitions autark selbst validieren, u.A. als Schutz gegen \'c4nderungen der Storage Logik?\par
Irgendwo da sollten jedenfalls die TypeIds \'fcber das Dictionary zu TypeDefinitions aufgel\'f6st werden und f\'fcr die sollten dann im PersistenceTypeHandlerManager TypeHandler ensuret werden. Falls es nicht schon aktuelle gibt, dann m\'fcssen Legacy handler erzeugt werden. Ohne Fallback, einen neuen, noch unbehandelten Typ f\'fcr eine TypeId anzunehmen, sondern dann mit Exception.\par
\'dcberhaupt darf eigentlich der PersistenceTypeHandlerManager, also die Schnittstelle auf der Seite der Anwendungslogik, nie in die Situation kommen, \'fcber eine blanke TypeId einen TypeHandler erzeugen zu sollen. Das muss immer \'fcber einen Runtime Type oder - im Fall der Legacy Handler - eine TypeDefinition laufen. Vielleicht ist das die grunds\'e4tzlich bessere Einteilung beim TypeHandlerManager:\par
- Runtime Type (eine echte Class<?>) f\'fcr den laufenden Betrieb.\par
- TypeDefinition (aus dem Dictionary) zum LegacyHandler ableiten.\par
- F\'fcr TypeIds darf es im TypeHandlerManager gar keine API geben. \par
\par
Als Pr\'fcfung mal Recherchieren, ob die bisherigen per-TypeId-Methoden des TypeHandlerManagers irgendwo anders au\'dfer beim LegacyMapping verwendet werden. D\'fcrfte eigentlich nicht der Fall sein.\par
Jup. Die delegaten und rufen sich alle nur gegenseitig APIm\'e4\'dfig auf. Wobei die Frage ist, ob ein lookup nach TypeId nicht durchaus sinnvoll ist. Immerhin ist das auch der einzige Weg, wie man eine TypeDefinition eindeutig identifiziert.\par
Also lookup via TypeId, aber ensure nur via TypeDefinition.\par
Hehe, witzig: vor LegacyHandlern h\'e4tte ich gesagt: Die handlersByTypeId Map kann eigentlich aus der TypeHandlerRegistry raus. Aber nun, mit LegacyHandlern, ist das die einzige Stelle, wo die registriert werden.\par
Also passt.\par
Genau. Also raus fliegen: provideTypeHandler(long) und ensureTypeHandler(long). Damit dann auch das komische "createProperTypeHandler" Fallback Ding von oben, das es logisch konsistent gar nicht geben br\'e4uchte bzw. d\'fcrfte. Passt.\par
\par
Das ging erfrischend schnell. Jetzt \'fcberlegen wegen Kapselung und LegacyTypeHandler Lookup.\par
\par
Hm. Also es m\'fcsste eigentlich reichen, eine HashEnum mit typeId-uninitialisierten LegacyTypeHandler Instanzen zu halten.\par
Die werden dann alle durchgescannt, ob eine Beschreibung davon genau auf die \'fcbergebene TypeDefinition passt.\par
Wenn ja, dann ist das der TypeHandler daf\'fcr. Dann wird dessen TypeId initialisiert und die Instanz als TypeHandler zur\'fcckgegeben. Alle freuen sich.\par
Wenn nein, dann muss ein generischer LegacyTypeHandler  anhand von Mappings und MultiMatcher abgeleitet werden.\par
Die Map k\'f6nnte in einem "PersistencLegacyTypeMapper" durchaus drin sein. Die passt da rein.\par
Auch die IdentifierBuilder und der '#' Grusch.\par
\par
Hm. Dann ist die n\'e4chste Frage, ob der refactoringMappingProvider vielleicht auch dorthin verschoben werden sollte.\par
Dann w\'e4rs aber eher ein "PersistenceRefactoringHandler", der sich k\'fcmmert um manuelle Refactoring Mappings und um LegacyTypeHandler Sicherstellung.\par
Ne Moment: Das ganze RefactoringMapping Ding wird im TypeHandlerManager nur f\'fcr die LegacyTypeHandler erzeugung gebraucht. Also kann man das alles sauber single-concern-m\'e4\'dfig zu einem "PersistencLegacyTypeMapper" zusammenkapseln.\par
So mach ichs!\par
\par
\par
\par
2018-09-12\par
\par
Foundation erweitern um neuen PersistencLegacyTypeMapper. Dabei gleich die dumme '#' Konstante konfigurierbar machen.\par
\par
Gleich mal Konzept machen f\'fcr Custom LegacyTypeHandler Registrierung. Am besten m\'f6glichst \'e4hnlich zu der schon existierenden Custom Handler Registrierung.\par
Ah ja, hehe: Am \'e4hnlichsten und einfachsten ist: Genau im selben Ding. Es gibt eine "PersistenceCustomTypeHandlerRegistry", dort kommen die mit rein.\par
Sch\'f6n typisiert, damit nix schief gehen kann. Passt alles.\par
\par
Hm, wieder mal auf das knifflige Thema gesto\'dfen: wann sind zwei TypeDescriptions gleich?\par
SwizzleTypeIdentity#equals definiert typeIds gleich UND Name gleich.\par
Aber das stimmt eigentlich nicht. Richtig ist: die gleiche Identit\'e4t liegt vor, wenn die TypeIds gleich sind. Unterschiedliche Namen sind dann ein Fehler, keine Ungleicheit.\par
Gleiche Beschreibung liegt vor, wenn alle entscheidenden Werte (Members usw.) gleich sind.\par
Diese Doppelgleichzeit oben wird in PersistenceTypeHandlerManager#validateTypeHandler f\'fcr die Validierung verwendet. Mal dr\'fcber nachdenken.\par
Also dort ist das eh Quatsch: Erst gibt es einen Lookup per Name und dann wird gepr\'fcft, ob TypeId und Name gleich sind. Name ist, garantiert durch den Lookup, eh gleich. Dann bleibt eh nur noch als validierung, ob beide die gleiche TypeId haben.\par
Das ist an dieser Stelle auch sinnvoll: Der TypeHandler (der zwangsweise die aktuelle Definition eines Typs verwendet) und die als aktuell registrierte TypeDefinition m\'fcssen die gleiche TypeId haben, sonst passt was nicht.\par
Um das zu validieren reicht hier aber, die TypeIds direkt zu vergleichen. D.h. die ganze #equals Methode kann weg.\par
\par
\par
2018-0913\par
\par
Equality Zeug fertig aufr\'e4umen.\par
CustomLegacyHandler Registrierung abschlie\'dfen und einbauen.\par
\par
So! Jetzt fehlt eigentlich nur noch das Similator Zeug. Bzw. Jetzt w\'e4re mal Zeit f\'fcr einen Test, ob bis da hin alles funktioniert, wie es soll. Explizite Mappings, usw.\par
Testen.\par
\par
Ah, richtig: Occuring TypeIds zu TypeDefinitions aufl\'f6sen fehlt noch. Implementieren.\par
Hm. Wobei schon irgendwie die Frage ist: Soll wirklich der Storage Kontext \'fcber den PersistenceTypeManager und dessen TypeDictionary die TypeIds zu TypeDescriptions aufl\'f6sen, um sie dann dem TypeManager wieder zu geben?\par
W\'e4re es nicht sauberer, dem TypeManager eine TypeId Liste zu geben, die er sich intern dann selber aufl\'f6st? Irgendwie schon. Dann sind in der API aber wieder TypeIds drin. Bl\'f6d.\par
Wobei die eh schon drin sind: f\'fcr lookups, f\'fcr den highest TypeId update.\par
Also doch per TypeIds. Implementieren.\par
Testen.\par
\par
Haha: PrimitiveDescription hat keinen UniqueName, darum Nullpointer. Mal \'fcberlegen f\'fcr einen sauberen Fix.\par
Eigentlich sollte es unproblematisch sein, einfach direkt primitiveDefinition() zur\'fcckzugeben. Primitive Types sollten ja immer nur ein Member haben.\par
Testen.\par
Passt.\par
\par
PersistenceTypeMismatchValidator darf jetzt nat\'fcrlich keine Exception mehr werfen. Default von failing auf noOp \'e4ndern, kommentieren.\par
Testen.\par
Passt.\par
\par
So, jetzt steht der Debugger im PersistencLegacyTypeMapper. Mal durchschauen.\par
Abgesehen von einem kleinen Fl\'fcchtigkeitsfehler siehts im getesteten Fall gut aus, aber um alle F\'e4lle zu testen, muss ich mir ein paar Testklassen mit entsprechenden \'c4nderungen bauen.\par
\par
\par
Testf\'e4lle:\par
\par
1.) Klassen\par
- Name der Klasse \'e4ndert sich. Geht nur per explizitem Mapping.\par
- Felder mit expliziter Declaring Class m\'fcssen erkannt werden.\par
\par
2.) \'c4nderungen innerhalb der Klasse (ohne Vererbung)\par
- Feld wird umbenannt\par
- Feld f\'e4llt weg.\par
- Feld kommt neu dazu.\par
- Feld wird an andere Stelle verschoben.\par
\par
\par
3.) \'c4nderungen innerhalb der Klasse (mit Vererbung)\par
TODO (eklig)\par
\par
4.) Fiese F\'e4lle\par
- Aktuelle Klassendefinition ist so, dass ein fr\'fcherer TypeDictionary Eintrag wieder genau passt, weshalb der aktuelle Handler mit der alten TypeId initialisiert werden muss.\par
\par
\par
\par
Ah, schon was aufgefallen:\par
Wenn sich von einem Type einfach nur der Name ge\'e4ndert hat und sonst sind alle Felder unver\'e4ndert, dann sollte direkt der aktuelle BinaryHandler verwendet werden, ohne dass ein Legacy Dingens erzeugt wird.\par
Das ist wichtig, falls Custom BinaryHandler verwendet werden. Wenn der Name schon mal richtig aufgel\'f6st ist, sollen die ja wieder verwendet werden, anstatt dass nach einem LegacyHandler gesucht wird.\par
Oder vielleicht kann das allgemeiner formuliert werden:\par
Wenn nach dem member-matching ein Mapping rauskommt, bei dem kein Feld wegf\'e4llt, keins dazukommt und sich keine Reihenfolge \'e4ndert (auch wenn vielleicht Namenstrings anders sind), dann kann f\'fcr die alte TypeId der aktuelle BinaryHandler registriert werden. Das w\'e4re dann streng genommen eine Inkonsistenz im TypeHandler Lookup, weil TypeId 123 auf den Handler f\'fcr TypeId 345 linkt.\par
Das wird dann aber ein bisschen knifflig, weil dann dem LegacyMapper der aktueller Handler \'fcbergeben werden muss und auch ein Callback, um nur optional einen LegacyMapper zu registrieren.\par
Oder muss ein Handler immer registriert werden (also im Beispiel f\'fcr 123), aber das muss nicht unbedingt ein LegacyHandler sein? Hm...\par
\par
Allerdings sieht die API zur Registrierung nicht vor, dass eine explizite TypeId angegeben werden kann, sondern es wird die vom TypeHandler genommen.\par
Vielleicht w\'e4re es eh besser, das sauber zu verbinden: Einen richtig typisierten LegacyTypeHandler, mit der richtigen TypeId und der alten TypeDefinition (ggf. mit alten Benamungen) und dann dem aktuellen TypHandler als delegate.\par
Hei\'dft: Definitionsm\'e4\'dfig alt, aber aktuelle Logik, weil sie ja zuf\'e4llig passt. Der minimale Performancenachteil durch einmal mehr dereferenzieren ist hier egal, bzw. generische L\'f6sungen f\'fcr veraltete Daten sind halt durch die Umbiegerei 0,5% langsamer. Da braucht sich niemand dran st\'f6ren. Wenn doch, sollen sie einen Custom Handler implementieren, Problem gel\'f6st.\par
So mach ichs!\par
\par
Wobei das mit dem "genau passt" gef\'e4hrlich ist:\par
Wenn das Feld "String note" wegf\'e4llt und an seiner Stelle ein Feld "String uStIdNr" tritt, dann ist das designm\'e4\'dfig NICHT dasselbe Feld. Wenn man das einfach annimmt, hat man auf einmal alte Anmerkungsstrings im uStIdNr Feld drin.\par
Oder sind solche F\'e4lle dann vom Entwickler eigenverantwortlich in Form von expliziten Mappings abzubilden? Eigentlich schon ...\par
Oder anders gesagt: Das "genau passt" basiert ja auf den expliziten Mappings. Wenn dort was nicht angegeben ist ... \'af\\_(\f1\'83\'63\f0 )_/\'af.\par
Passt.\par
\par
Und da f\'e4llt mir gerade noch auf: wenn es einen Custom Handler gibt, dann ist mit einer generischen L\'f6sung sowieso nix mehr, weil die ja nicht zu der Custom Logik passt.\par
Es gibt also f\'fcr Typen mit Custom Handler nur zwei M\'f6glichkeiten:\par
1.) Der aktuelle kann weiterverwendet werden, weil sich nur Benamungen ge\'e4ndert haben.\par
2.) Es muss ein passender CustomLegacyTypeHandler registriert sein, der das alte custom Format auf das neue Custom Format umformt.\par
Die ganze Membermatcherei geht nur f\'fcr generisch behandelte Typen, die mit reflect Fields arbeiten.\par
\par
Alles soweit eingebaut. Weiter testen.\par
\par
Ah, die extra gebaute Testklasse w\'fcrde viel sogar das richtige Verhalten haben, wenn man die Refactorings Datei mit einbinden w\'fcrde ... ^^.\par
Damit siehts gut aus, was die abgedeckten Tests angeht.\par
\par
Als n\'e4chstes muss der Similator her, um das Matching abzuschlie\'dfen.\par
\par
\par
\par
2018-09-14\par
\par
Die Custom Handler k\'f6nnten auch ohne legacy custom handler mit einem zwischenschritt bedient werden:\par
Wieder ein LegacyTypeHandler Wrapper, der beim builden die Bytes von der alten auf die aktuelle Struktur umkopiert und dann an den aktuellen Custom Handler weiterreicht.\par
Ist vielleicht ein klein bisschen unsch\'f6n, aber das w\'fcrde ja nur auf ganz seltene Sonderf\'e4lle zutreffen und falls es performancetechnisch ein Problem sein sollte, muss man halt einen Custom Legacy Handler schreiben, dann l\'e4uft es direkt.\par
Das bau ich noch mit ein.\par
\par
Es muss noch eine Datenstruktur geben, die das ganze Member Mapping Zeug letztendlich zusammenfasst.\par
Und es muss eine Logik geben, die diese Zusammenfassung macht. Am besten Modular, damit man sie customizen kann, um eingreifen zu k\'f6nnen.\par
\par
Result und Resultor bauen.\par
\par
Verschiedene F\'e4lle in der Logik strukturieren.\par
\par
Foundation f\'fcr die ganzen neuen Module erweitern.\par
\par
FIXMEs durchschauen.\par
PersistenceTypehandler#validateFields untersuchen ... das wird nie benutzt. Rausl\'f6schen.\par
\par
Das mit dem Translating LegacyHandler f\'fcr CustomHandlers wird nicht so einfach, weil das ja ein konkreter BinaryHandler werden muss.\par
Wobei der f\'fcr die Reflection Fields auch ein konkreter BinaryHandler werden muss. Ab irgendeinem Punkt muss es ja mal konkret mit dem Medium zu Tun haben, anstatt nur abstrakte Persistence Management Logik zu sein.\par
\par
BinaryLegacyTypeTranslatingMapper bauen.\par
\par
Hm. Das ist gar nicht so einfach: Man kann keine neue Binary Instanz machen und im builder registrieren, weil es im create() keine Referenz auf den Builder gibt.\par
Mal \'fcberlegen.\par
Ist auch gar nicht n\'f6tig, sondern einfach nur die entityContentAddress im medium neu setzen auf den umgebogenen Datenbereich.\par
Aber woher kommt die Gesamtl\'e4nge? \par
Mal recherchieren. Varying length, minimum, maximum Zeug. Da war doch was...\par
Achja. So implmentieren.\par
Da fehlt jetzt aber der Header vorne dran. Falls die Custom Logik den auslesen will, w\'fcrde es momentan krachen. Das darf nicht sein. Muss rekonstruiert werden.\par
\par
\par
\par
\par
2018-09-17\par
\par
BinaryLegacyTypeTranslatingMapper weiterbauen: fehlende Header Bytes einbauen.\par
\par
Dabei dar\'fcber gestolpert, dass BinaryPersistence#entityDataOffset die Header Length abzieht anstatt draufaddiert. Wenn ich mich nicht sehr t\'e4usche ist das ein fataler Bug, durch den eigentlich nie ein OGS Load ohne exception durchgehen d\'fcrfte.\par
Hm okay, die Formulierung spricht jetzt daf\'fcr, dass ich mich doch t\'e4usche. Jedenfalls ist das unkommentiert und crazy und das muss ich jetzt recherchieren und dann fixen oder kommentieren.\par
Und au\'dferdem mal konsistent auf "~content~" umbenennen.\par
\par
Ah, jetzt endlich verstanden:\par
Da wird an einer Stelle unsinnig + header length drauf gez\'e4hlt und an der Verwendungsstelle wird dann buggerweise wieder - header length gerechnet.\par
Beide Methoden werden nur an jeweils genau einer Stelle verwendet, darum haben beide Fehler sonst nirgends Probleme gemacht. Und hier gleichen sie sich gegenseitig aus, darum funktioniert trotzdem alles.\par
Ich muss jetzt mal diese ganzen header length offset Methoden konsolidieren. Da steigt ja sonst niemand mehr durch und irgendwann ergibt sich durch einen vermeintlichen Bugfix ein fehlerhaftes Verhalten.\par
So. Jetzt ist das ordentlich.\par
\par
Weiter beim BinaryLegacyTypeTranslatingMapper.\par
\par
Hm: Problem: Wenn ich einfach so direkt ein allocateMemory mach, muss ich das sp\'e4ter auch wieder freigeben.\par
Aber falls es eine Exception geben sollte, w\'fcrde der Aufruf zum Freigeben nie stattfinden.\par
Hei\'dft: Memory Leak. Nicht gut.\par
\par
Also m\'fcsste es \'fcber einen DirectByteBuffer laufen. Der gibt im Cleaner seinen Memory auf jeden Fall wieder frei.\par
Das Problem daran ist aber wieder: im create() gibt es keine Referenz auf den Builder, in dem man den DBB als helper registrieren k\'f6nnte.\par
\'c4h, shit.\par
\par
Hm, Idee: Wieso ist die helper Registry eigentlich \'fcberhaupt im Builder drin anstatt direkt in Binary? Die Binary Instanz h\'e4lt den State zum builden, also kann die doch auch den helper state mit halten.\par
Damit leben auch beide strukturen immer genau gleich lang.\par
Wenn die HashTable Instanz lazy instanziert wird, dann beschr\'e4nkt sich der Overhead im Normalfall auf eine Referenzgr\'f6\'dfe pro Binary Instanz.\par
Passt, so mach ich das.\par
\par
BinaryValueCopier anlegen, 1,2,4,8 Varianten. Referenzen (OIDs) sind in binary Form auch nur 8 Byte. Kein Grund f\'fcr eine Sonderbehandlung.\par
Algorithmus bauen zum Ableiten eines BinaryValueCopier[] aus einem bestehenden Mapping.\par
\par
Es muss noch einen PersistenceLegacyTypeHandlerCreator geben, analog zu normalen TypeHandlerCreatoren. Einerseits wegen modularisierung, andererseits wegen loser Koppelung von Binary~ Implementierung und abstraktem Peristence~ Framework. Die ganzen isCustom~ check-Stub-Methoden kommen dann dort rein. Genauer gesagt in eine Abstrakte Persistence~ Rumpfimplementierung.\par
\par
Foundation Klassen um die \'fcbliche Infrastruktur erweitern.\par
\par
\par
2018-09-18\par
\par
Nach Confluence Post von RF mal Inventur \'fcber sun.misc.Unsafe Verwendungen in OGS machen.\par
XVM geringf\'fcgig ausmisten und TODOs schreiben.\par
\par
Weiter mit OGS-3: Erkennung von generischen TypeHandlern (= nur Field Reflection, ohne Logik) bauen.\par
Mal recherchieren, wie das am saubersten gemacht werden sollte.\par
Dabei auf PersistenceTypeHandlerGeneric gesto\'dfen. Sinnvolles Interface, aber wird gar nicht verwendet. Einbauen. JavaDoc aktualisieren.\par
Paar Ableitungshiarachien zu AbstractBinaryHandlerNativeCustom konsolidieren.\par
\par
Dabei wieder mal auf BinaryHandlerNativeClass Problem gesto\'dfen.\par
Durchdenken. FIXME Kommentar erweitern.\par
Hm, gute Idee gefunden: defaultm\'e4\'dfig exception, aber wenn jemand einen custom handler f\'fcr Class Instanzen registriert (und damit die Verantwortung \'fcbernimmt), gehts.\par
So umbauen und kommentieren.\par
\par
\par
Jetzt wieder weiter mit OGS-3: PersistenceLegacyTypeHandlerCreator#isUnchangedStructure implementieren.\par
Hm. Das ist gar nicht so leicht:\par
- Da muss f\'fcr declaring class names ja das Type Mapping wieder rein. Sonst ist das ein verwirrendes Verhalten: Typen k\'f6nnen gemappt werden, aber Felder von gemappten Typen werden auf einmal nicht mehr erkannt.\par
- Eigentlich k\'f6nnte/m\'fcsste Vererbungskovarianz ber\'fccksichtigt werden. Aber das w\'e4re was f\'fcr eine sp\'e4tere Verbesserung, die erst mal ignoriert werden kann.\par
\par
Ne Moment, Quatsch:\par
Die ganze Mapperei wurde ja schon gemacht und steckt im Result drin.\par
Hier geht es nur noch um die Frage: Ist Feld #1 auf Feld #1 gemappt, #2 auf #2, usw.? Wenn ja, dann ist scheiss egal, welche Typen die Felder haben. Das Mapping sagt aus, dass der normale TypeHandler direkt verwendet werden kann.\par
Fertig.\par
\par
Aber im Similator muss das Mapping f\'fcr die Declaring Class dann mit rein. Dort ja, aber nicht hier. Das hier ist ein total trivialer Check auf gleiche Reihenfolge.\par
\par
Implementieren. Passt.\par
\par
Jetzt BinaryLegacyTypeTranslatingMapper#deriveValueCopiers machen.\par
Plan:\par
- map mit binary offsets der current members erstellen.\par
- legacy members durchlaufen.\par
- binary offset der legacies ergibt sich durch das iterieren\par
- je nach type passenden copier ausw\'e4hlen und mit offsets instanzieren.\par
- copier zu collection adden.\par
\par
OMG, es m\'fcsste ja Konverter zwischen den Primitive Types geben. Hei\'dft 8*8=64 verschiedene Implementierungen ... o_0.\par
Da mach ich erst mal eine Exception mit TODO hin.\par
\par
So, fertig.\par
Damit ist jetzt noch zu tun:\par
- Similator implementieren\par
- Resultor implementieren\par
- ReflectiveMapper implementieren.\par
\par
Und dann nat\'fcrlich testen.\par
\par
Eigentlich muss die BinaryValueTranslator Erstellung Modularisiert werden. F\'fcr die Primitive Converter und f\'fcr einfaches Customizing.\par
Mal machen.\par
\par
Und eigentlich ist die binaryLength auch schon im TypeHandler verf\'fcgbar. Mal recherchieren, bissl refactoren usw.\par
\par
\par
2018-09-19\par
\par
ContentLength in PersistenceTypeHandler nachziehen und damit Code vereinfachen.\par
\par
Dabei aufgefallen: in PersistenceTypeHandler sind getter f\'fcr Field Members. Die haben erstens dort nichts verloren und werden zweitens nie verwendet.\par
Aufr\'e4umen:\par
Eigenen Type PersistenceTypeHandlerReflective machen und dorthin verschieben. Der kann dann auch gleich die Member Typen spezifischer definieren. Nice.\par
\par
Paar Refactorings auf dem Weg.\par
\par
Jetzt halt doch gleich noch das primitive converter mapping schreiben. Sonst gibts da sofort beim Ausprobieren gro\'dfes Geheule, wieso man das selber mache muss.\par
Bissl rumbauen f\'fcr m\'f6glichst kompakte Syntax, sonst wird das seitenweise Spaghetticode...\par
\par
Jetzt die TODOs zu persistentOrder vs declaration Order anschauen. Das f\'e4llt auf ein uraltes TODO von 2014 zur\'fcck.\par
Dabei gleich AbstractBinaryHandlerReflective umbenennen, verschieben, elendslangen Konstruktur aufr\'e4umen.\par
\par

\pard Besprechung mit CK zu OGS IO-Abstrahierung, z.B. f\'fcr Speichern in S3. Notizen zu aktuellem Konzept bzw. Anforderung machen.\par

\pard\sl276\slmult1\par
Damit sind nun noch 5 OGS-3 TODOs \'fcbrig. Noch immer Similator, Resultor und ReflectiveMapper plus 2 Checks auf ein potenzielles Problem.\par
\par
BinaryLegacyTypeHandlerCreator#deriveValueTranslators nochmal durchschauen/durchdenken als Ausgangspunkt f\'fcr den ReflectiveMapper.\par
Dabei aufgefallen: der total offset wird ja gar nicht hochgez\'e4hlt und gel\'f6schte legacy Members werden nicht ber\'fccksichtigt.\par
Beides noch fixen.\par
\par
\par
2018-09-20\par
\par
BinaryValueTranslator doch lieber umbauen auf stateless Funktionen so wie bei BinaryValueStorer usw.\par
Das gleiche in gr\'fcn kann dann auch gleich f\'fcr den ReflectiveMapper verwendet werden, nur dass da die offsets anders sind.\par
\par
Der BinaryLegacyTypeTranslatingMapper und der BinaryLegacyTypeReflectiveMapper k\'f6nnen sich sogar eine gemeinsame Superklasse teilen. Refactoren.\par
\par
Hm. Man braucht ja eine instance als Basis f\'fcr den field offset. D.h. ich m\'fcsste f\'fcr den Reflective Mapper alle translators nochmal schreiben.\par
Oder ich bau alles so um, dass gleich einheitlich ValueSetters verwendet werden. Dann werden halt ein Haufen nulls nutzlos rumgereicht, aber ansonsten w\'e4r alles super.\par
Jup. ValueSetter Vereinheitlichung.\par
\par
Dabei f\'e4llt mir auf: hier k\'f6nnte einiges an Performance Optimierung m\'f6glich sein.\par
Mal einen Kommentar in BinaryValueSetter schreiben, damit das dokumentiert ist.\par
\par
\par
2018-09-21\par
\par
BinaryValueTranslators auf BinaryValueSetter umbauen.\par
BinaryLegacyTypeReflectiveMapper fertig bauen.\par
Hm. In PersistenceTypeDescriptionMemberField fehlt das reflect.Field. Wieso eigentlich? Zumindest f\'fcr den ReflectiveMapper sind die n\'f6tig bzw allgemein sinnvoll.\par
Mal nachr\'fcsten. Sollte sich mal ein Problem daraus ergeben, kann man es ja wieder rausnehmen und die Felder im LegacyTypeHandler Creator redundant nach Namen aufl\'f6sen.\par
Damit BinaryLegacyTypeReflectiveMapper fertig bauen.\par
\par
Jetzt noch PersistenceLegacyTypeMappingResultor implementieren.\par
\par
Similator Stub auch gleich.\par
\par
Dann fehlt jetzt nur noch die Similator Logik und die zwei abcheck-TODOs.\par
\par
Erst mal ein Konzept. Es gibt:\par
- Name\par
- Type\par
- DeclaringType\par
\par
Position darf keine Rolle spielen, weil sie in java Klassen keine Rolle spielt. W\'fcrde sie ber\'fccksichtigt werden, w\'fcrde das hei\'dfen, dass ein weniger gut passendes target Feld einem besser passenden vorgezogen wird, nur weil es an einer \'e4hnlichen Stelle wie das source Feld steht. Das w\'e4re Bl\'f6dsinn. F\'fcr alle anderen F\'e4lle braucht man es nicht. Einfacher gesagt ist es so: ein Feld wird fachlich \'fcber alles m\'f6gliche definiert und identifiziert, aber nicht \'fcber seine Position.\par
\par
Type muss unterschieden werden in Primitive und Nicht-Primitive. Zwischen diesen beiden ist die \'c4hnlichkeit zwangsweise 0.\par
Hm, oder stimmt das? W\'e4re es nicht sinnvoll, erst mal die Felder m\'f6glichst zuverl\'e4ssig zuzuordnen und dann kann man immer noch eine Exception werfen, dass ein Mapping nicht geht?\par
Z.B. "long amount" wird vom Entwickler ge\'e4ndert auf "Long amount". Technisch ist das inkompatibel, aber designm\'e4\'dfig/logisch/fachlich ist das das selbe Feld, nur abge\'e4ndert, also sollte es erst mal gematcht werden.\par
\par
Davon abgesehen seh ich schon die Heulerei kommen: Auch das muss gehen, blablab, muss man halt einen Wrappertyp instanzieren, blabla.\par
Das Problem daran ist: Diese vom Mapper erzeugte Instanz hat dann keine OID und ist nicht f\'fcr eine solche registriert.\par
Muss das dann der Mapper auch noch machen, oder ist hier eine Grenze, wo man sagt, dass das der Mapper nicht generisch macht?\par
Hm ... mal recherchieren.\par
Also das \'fcbergebene SwizzleObjectIdResolving wird eh (nur) vom Builder implementiert und der macht eh auch Registrierungsstuff. Wenn das um eine zweite Methode zum registrieren erweitert w\'fcrde, w\'fcrde es gehen.\par
Das Problem ist aber: Wo kommt die neue OID her? M\'fcsste der mapper dann auch den OID-Provider kennen? Das wird ganz sch\'f6n kompliziert daf\'fcr, dass Leute ignorant gegen\'fcber dem Unterschied von Primitives und References sind.\par
\par
Hm. Es w\'fcrde aber reichen, wenn die SwizzleObjectIdResolving  ein #register(Object) hat und intern eine OID vergibt und f\'fcr die registriert. Im TypeHandler selbst interessiert die OID ja niemanden. Der Builder br\'e4uchte nur eine Referenz auf einen ObjectManager. Der PersistenceManager, der den Builder baut, kennt den eh. Also letztendlich w\'e4re es eine an den Builder \'fcbergebene Referenz mehr. Die Methode st\'f6rt im Normalfall niemanden.\par
\par
Oh, beim Durchdenken Bug entdeckt:\par
F\'fcr den ReflectiveMapper darf das handeln von OIDs nicht einfach den long wert umkopieren, so wie das beim Rerouting korrekt ist. Da muss der object Lookup rein.\par
\par
\par
\par
\par
2018-09-24\par
\par
JetstreamDB Sampler Test\par
\par
Dabei auf einige Fl\'fcchtigkeitsfehler gesto\'dfen (notNull statt mayNull bei zwei neuen Parts, Pr\'fcfung auf Class.class war falsch).\par
Au\'dferdem aufgefallen: Die vielen Factory Methoden f\'fcr StorageFoundation und StorageManager sind zu wirr und teilweise ungen\'fcgend dadurch, dass an zwei unterschiedlichen Stellen ein File n\'f6tig ist, aber es nicht redundant angegeben m\'fcssen werden soll. Das muss ich mal \'fcberarbeiten.\par
\par
EmbeddedStorage\par
.createFoundation: komplette StorageFoundation \par
\tab - mit default verzeichnis\par
\tab - mit StorageConnectionFoundation basierend auf dem verzeichnis\par
.start: createStorageManager mit Initialisierung und thread start\par
\par
\par
EmbeddedStorage(RootResolver, Configuration)\par
.createStorageManager:\par
\tab - createFoundation(Configuration): blanke StorageFoundation mit gesetzter Configuration\par
\tab - dort gesetzter RootResolver, aber exception wegen fehlender StorageConnectionFoundation\par
\tab - createStorageManager mit Initialisierung.\par
\tab\par
\tab\par
StorageFoundation\par
- StorageConnectionFoundation (mit File)\par
- Configuration (mit File)\par
- RootResolver Setter, der aber eigentlich an StorageConnectionFoundation weiterleitet\par
\par
Es muss also geben:\par
\par
createFoundation():\par
- holt default File\par
< leitet weiter an createFoundation(File)\par
\par
createFoundation(File):\par
- erzeugt FileProvider mit File\par
- erzeugt ConnectionFoundation aus File\par
< leitet weiter an createFoundation(FileProvider, ConnectionFoundation) \par
\par
\par
createFoundation(FileProvider, ConnectionFoundation):\par
- erzeugt Configuration mit FileProvider und ansonsten Defaults\par
> leitet weiter an createFoundation(Configuration, ConnectionFoundation)\par
- setzt ConnectionFoundation\par
\par
createFoundation(Configuration, ConnectionFoundation):\par
- erzeugt blank StorageFoundation\par
- setzt configuration\par
- setzt ConnectionFoundation\par
\par
So bau ich das.\par
\par
\par
2018-09-25\par
\par
OGS-3 Design Checks anschauen:\par
Der LegacyTypeHandler verwendet zum iterieren der persistenten Daten (alte Struktur) den TypeHandler der aktuellen Struktur. Das ist - fast - immer ein Bug. Das muss auf der alten Struktur basieren.\par
\par
Puh, das ist gar nicht so einfach:\par
Man darf nicht davon ausgehen, dass alle References am Anfang zusammen sind, so wie bei GenericType Handlern, denn es gibt ja auch Custom geschriebene Handler und die halten sich potenziell nicht an die Optimierungsstrategie.\par
Also muss ein Array an Reference Offsets ermittelt werden, das dann durchlaufen wird.\par
\par
Hm, aber auch das reicht nicht bei variable length references.\par
Gut, die w\'e4ren durch die "not supported, yet" Exception eh schon abgefangen.\par
Aber irgendwie ist das komisch: Das muss doch z.B. im Storage GC auch richtig funktionieren, sonst w\'fcrde der ja Referenzen auslassen...\par
Mal nachsehen und sei es nur als Sicherheit.\par
Achja: Es gibt schon die ultra-komplexe, alle (bisher n\'f6tigen) F\'e4lle abdeckende Logik in BinaryReferenceTraverser.Static#deriveReferenceTraversers.\par
Mal durchschauen.\par
Hm. Das m\'fcsste eigentlich perfekt passen f\'fcr den LegacyTypeHandler.\par
\par
Einbauen.\par
\par
Alle anderen Methoden auf Unterscheidung old/current type pr\'fcfen und kommentieren.\par
\par
Damit w\'e4re das ald/neu Design-check TODO fertig.\par
\par
\par
}
 