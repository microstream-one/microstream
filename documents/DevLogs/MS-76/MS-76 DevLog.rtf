{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 MS-76 DevLog\par
\par
2019-03-18\par
\par
Review f\'fcr Pull Request Code von FH.\par
\par
XMemory wurde erweitert um field offset hacks f\'fcr java.util Collections, analog zu bestehenden.\par
Das sieht soweit erst mal gut aus.\par
Die Frage ist, ob die Felder wirklich alle gebraucht werden.\par
\par
Erste Klasse: ArrayDeque.\par
hack-accessors f\'fcr head und tail.\par
Warum sind die n\'f6tig?\par
Mal recherchieren.\par
Ahja, das sind f\'fcr den state wichtige Indizes. Warum die JDK Kaspern s\'e4mtliche nicht-transiente Felder trotzdem transient machen, wissen wohl nur sie. Wahrscheinlich wegen ihrem verpfuschten Custom Serialization Gebl\'f6del.\par
\par
Hm, aber da passt was nicht im TypeHandler:\line Die L\'e4nge wird nur in create ausgelesen, aber nicht in update und auch kein ensureCapacity gemacht.\par
Wenn eine existierende Instanz mit geladenen Daten aktualisiert werden soll (z.B. bei Communication), dann krachts hier.\par
\par
ensureCapacity() gibts hier nat\'fcrlich nicht.\par
Dann darf man sowieso nicht direkt in das Array reinschreiben.\par
Hei\'dft: updaten muss clear aufrufen und dann jedes Element einzeln adden.\par
Als Konsequenz m\'fcsste man dann auch \'fcberhaupt nicht head und tail explizit speichern und setzen.\par
Soweit ich sehe sind das ja keine ver\'e4nderbaren Indizes, sondern das sind nur interne Marker, von wo bis wo das Array gef\'fcllt ist.\par
\par
store speichert einfach das gesamte Array bis zur size, analog zu ArrayList. Das ist bei der ArrayDeque aber falsch, weil es die null slots logisch gar nicht gibt. Darum ja head und tail index.\par
\par
Fazit:\par
- Alle field offset hacks f\'fcr ArrayDeque raus\par
- Handler benutzt nur public API der ArrayDeque.\par
\par
\par
Zweite Klasse: Hashtable.\par
\par
Die sollte sehr \'e4hnlich zu HashSet und HashTable funktionieren. Mal sehen.\par
\par
Paar Code Tyle Probleme:\par
\'dcberfl\'fcssiges else\par
Fehlendes this.\par
?: in einer Zeile.\par
Kein Leerzeichen um Operatoren\par
\par
Abbruch.\par
\par
Merge Ablehnung und selber \'fcberarbeiten.\par
\par
\par
Wie mach ich das am besten, falls da nochmal neue Commits von FH kommen...?\par
Ich mach mal ~2 Kopien der Klassen und schreib die \'c4nderungen in die.\par
\par
Zun\'e4chst mal die, die CK braucht. Mal genauer recherchieren im TypeDictionary und aufschreiben:\par
java.util.LinkedHashSet\par
java.util.HashMap\par
java.util.LinkedHashMap\par
java.util.Hashtable\par
\par
\par
Erst mal den mehrfach redundanten Code zum EntrySet Referenzen iterieren in eine zentrale Klasse packen.\par
Code Qualit\'e4t verbessern.\par
Und dann auch noch gleich ordentlich typisieren, dann f\'e4llt auch das plumpe Casten weg.\par
\par
Handler Klassen migrieren.\par
Hash Inconsistency Check fehlt. Nachr\'fcsten.\par
Fehlende Binary Offsets nachtragen (auch wenn der 0 ist. Irgendwann wird es mal ge\'e4ndert und dann, schwups, Fehler, JVM Crash).\par
\par
ArrayDeque Klasse migrieren.\par
Hm. Die XMemory-Accessor-Methoden sind doch n\'f6tig, weil ja der interne Storage-Zustand wiederhergestellt werden soll, genau wie bei ArrayList.\par
Aber dass die Logik von 0 bis size anstatt von head bis tail (bzw. offset bis offset + size) l\'e4uft, ist nach wie vor ein Bug.\par
\par
Dann war noch die Sache mit dem fehlenden Capacity ensuring. Das bei\'dft sich damit, dass ja die interne Storage wiederhersgestellt werden soll.\par
Da muss ich mal ein TODO hinmachen und dr\'fcber nachdenken. Evtl. muss man das storage Array setzen, wobei das eigentlich nicht so toll ist.\par
\par
Da f\'e4llt mir auf: da werden ja XMemory.bitSize_int() usw. Werte verwendet. Bitsize ist f\'fcr int 32! Was hier gebraucht wird, ist die byte Size, 4!.\par
Also das auch \'fcberall checken und ausbessern.\par
\par
BinaryHandlerArrayDeque#iterateInstanceReferences ist auch ein bug: iteriert das interne storage array von 0 bis size.\par
\par
\par
2019-03-19\par
\par
Branches im Home Office auschecken und alte Branches aufr\'e4umen.\par
Kurz mal recherchieren zu besserem Begriff f\'fcr "ByteMultiple": {{\field{\*\fldinst{HYPERLINK https://en.wikipedia.org/wiki/Metric_prefix }}{\fldrslt{https://en.wikipedia.org/wiki/Metric_prefix\ul0\cf0}}}}\f0\fs28\par
Hm. Da ist "Multiple" tats\'e4chlich als Fachbegriff verwendet.\par
Aber trotzdem ist es seltsam. Das Ding hei\'dft ja dann "ByteVielfaches". Sollte es nicht sowas wie "ByteEinheit" oder "ByteDimension" oder so hei\'dfen?\par
Egal, weitermachen.\par
\par
Teams Nachricht an FH f\'fcr Abstimmung des aktuellen Stands.\par
Zweiten Branch f\'fcr MS-76 machen, um die restlichen Handler zu migrieren bzw. nachzuarbeiten, ohne st\'e4ndig den Master zu ver\'e4ndern, falls die den zum Testen/Deployen verwenden wollen.\par
\par
Evtl. "Magnitude".\par
Siehe {{\field{\*\fldinst{HYPERLINK https://en.wikipedia.org/wiki/Megabyte }}{\fldrslt{https://en.wikipedia.org/wiki/Megabyte\ul0\cf0}}}}\f0\fs28  und {{\field{\*\fldinst{HYPERLINK https://en.wikipedia.org/wiki/Orders_of_magnitude_(data) }}{\fldrslt{https://en.wikipedia.org/wiki/Orders_of_magnitude_(data)\ul0\cf0}}}}\f0\fs28\par
Aber jetzt MS-76.\par
\par
\par
LinkedList Handler kopieren, durchschauen.\par
Oh, dabei aufgefallen: in Binary#storeIterableContentAsList fehlt ein Check auf mehr Elemente als erwartet.\par
Einbauen, Kommentar anpassen.\par
\par
\par
Nachricht von FH. Untersuchen.\par
Grund schnell gefunden. Fixen.\par
MS-120 mit Problem #3 updaten und Nachricht an FH.\par
\par
Verwirrung \'fcber durchgedrehte \'c4nderungsanzeige in Sourcetree. Bissl rumklicken. Auf einmal passts wieder. Wirr.\par
\par
Kurz Chat mit FH zu Stand von MS-76 und release f\'fcr Allianz Projekt.\par
\par
Handlers weitermachen.\par
BinaryHandlerLinkedList.\par
\par
LinkedList ist keine Hash-Collection, dementsprechend braucht sie auch keinen Zwischenschritt mit dem Helper. Also raus und Elemente direkt adden.\par
\par
Dabei aufgefallen: Das Elemente iterieren sollte in eine gemeinsame Util-Methode verschoben werden.\par
Ah: so wie das bei XIterable Instanzen ja schon gemacht wird.\par
F\'fcr Maps auch gleich.\par
Bissl allgemein Code konsolidieren.\par
\par
N\'e4chster Handler: Vector.\par
Dabei aufgefallen: Benamungen der Accessor-Methoden in XMemory \'fcberarbeiten:\par
- Zugriffe auf Instanzen (Array) mit access~\par
- Arrays nenn ich immer "Array", weil mir das ganze "elementData" oder "value" Ged\'f6ns zu dumm und teilweise missverst\'e4ndlich ist. (Was hei\'dft schon "value", wenn eine Array Instanz mit Identit\'e4t gemeint ist)\par
- Getter f\'fcr Primitive Werte nenn ich "get~"\par
- Setter bleiben f\'fcr beide F\'e4lle "set".\par
\par
Au\'dferdem die "setData" f\'fcr die beiden StringBuilder Methoden besser benennen. Vor allem die Parameternamen.\par
\par
Jetzt zum eigentlichen Handler.\par
Da steht nat\'fcrlich erst mal wieder eine Bitsize Methode drin. Fixen.\par
Start-Capacity und Capacity ensuring fixen.\par
Konstantennamen vereinheitlichen.\par
Jetzt sollte es passen.\par
\par
N\'e4chster Handler: Stack.\par
Ach, der leitet ja von Vector ab.\par
\par
Accessor-Methoden anpassen an neue Benamungen.\par
ensureCapacity Aufruf f\'fcr den capacityIncrement Wert entfernen (Bug).\par
Wieder Konstantenname und Wert fixen.\par
Sollt fertig sein.\par
\par
N\'e4chster Handler: Properties\par
\par
FIELD_DEFAULTS raus. Wozu, wenn es den Accessor eh in XMemory gibt?\par
Kommentar in store() ist falsch. Raus.\par
\par
complete() ist nat\'fcrlich wieder falsch, so wie bei den anderen Map-Typen.\par
Au\'dferdem: "castedInstance" ist gar nicht gecastet. Dann kann die gleich raus.\par
\par
Moment mal: Da f\'e4llt mir gerade erst auf: Bei allen Map-Types werden die Key-value Paare als simple List gespeichert. Das bildet zwar die Daten korrekt ab, aber nicht die Struktur.\par
Richtig w\'e4re, es so zu machen wie z.B. in BinaryHandlerHashTable.\par
\par
Das muss ich morgen umbauen...\par
\par
\par
\par
2019-03-20\par
\par
Map-Logik umbauen.\par
MS-120 und MS-76 updaten.\par
Gemeinsame Logik konsolidieren. Das ist alles endlos redundanter Code f\'fcr dieselbe Sache.\par
Au\'dferdem: IdentityHashMap braucht kein elements helper, weil es identity hashing macht.\par
\par
Da f\'e4llt mir gerade auf:\par
Es gibt bisher noch in keiner update() Methode von BinaryHandler f\'fcr Collections einen Aufruf von clear(). Auch nicht f\'fcr die X-Collections.\par
Ups. Hehe.\par
Schnell nachr\'fcsten.\par
Bei Arrays und Const~ Implementierungen gibt es immerhin schon eine Validierung.\par
Wobei die interessante Frage ist: Sollte eine immutable instanz von au\'dfen evtl. doch updatebar sein? Aber warum eigentlich?\par
\par
Weitermachen.\par
java.util.Properties ist auch noch eine Map-artige Collection. Auch noch umbauen.\par
Mal im TypeDictionary von CK schauen, ob ich die alte Implementierung daf\'fcr bestehen lassen muss.\par
\'d6h ... WTF ...? Da werden nur threshold und loadFactor gespeichert.\par
Mal den TypeHandler daf\'fcr in der jar suchen.\par
Aaach, da gibts keinen. Darum wurde das Ding generisch analysiert und weil das hashing array in Hashtable transient ist ... tja. Dumm gelaufen.\par
Mail an CK mit Hinweis darauf.\par
\par
\par
}
 