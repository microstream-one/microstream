{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red204\green204\blue204;\red255\green0\blue0;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-07-19\par
\par
BinaryHandlerClass bauen und die NativeTypeHandler Definitionsmethode entsprechend der Issue Idee erweitern.\par
\par
Da taucht auch schon wieder eine bisher nicht bedachte Verkomplizierung auf:\line Was ist, wenn eine Class Instanz eines Typs, der nicht handlebar ist, gespeichert werden soll?\par
Beispiel:\par
Thread.class an sich, bis den Identifier daf\'fcr nat\'fcrlich nur, kann man ja durchaus abspeichern, auch wenn Thread Instanzen bzw. Thread als Datenstruktur nicht gehandelt werden kann.\par
Der hat aber keine TypeId und selbst im TypeHandler eine Type Analyse starten w\'fcrde keine TypeId ergeben.\par
Ohne TypeId kann man den Type aber nicht mehr aufl\'f6sen.\par
\par
Dazu gibt es verschiedene L\'f6sungsm\'f6glichkeiten:\par
1.) TypeName doch wieder mit persistieren, aber das vermischt Daten und Metadaten, macht die Klassennamen im Dictionary nicht mehr (ohne weitere) \'e4nderbar, usw. Nicht sch\'f6n.\par
2.) TypeIds m\'fcssen IMMER vergeben werden k\'f6nnen. Das w\'fcrde aber auch hei\'dfen, dass immer zumindest eine leere/abstrakte Type Definition ins Dictionary geschrieben k\'f6nnen werden muss.\par
\par
#2 w\'fcrde aber Folgeprobleme mit sich bringen: Auf einmal w\'fcrde z.B. Thread doch wieder bei der Initialisierung aufgel\'f6st werden, ein TypeHander w\'fcrde erzeugt werden, um TypeDictionary und Runtime abzugleichen.\par
Also m\'fcsste auch hier sichergestellt werden, dass ein leerer TypeHandler erzeugt wird. Bzw. so ein unhandled, das w\'e4r noch besser. Ich denke, dann w\'fcrde #2 funktionieren.\par
Muss ich mal noch durchdenken.\par
\par
Ah, L\'f6sung:\par
Das kann einfach genauso gel\'f6st werden wie bisher schon abstrakte Typen:\par
Es wird ein BinaryHandlerUnpersistable erzeugt. Der bekommt eine TypeId, hat keine Felder und wirft bei jeder laden/speichern Methode eine Exception.\par
D.h. der ist nicht mehr als ein TypeDictionary-Eintrag-Dummy.\par
Genau das gleiche mach ich f\'fcr Class Instanzen auch.\par
\par
Am besten wird das gleich noch ein eigener Handler, dann kann man f\'fcr diesen Fall sehr einfach ein ver\'e4ndertes Verhalten bewirken, z.B. Warnings/Logging oder Abbruch mit Exception.\par
So mach ich das.\par
Das hei\'dft auch: Der BinaryHandlerClass muss den TypeHandlerManager kennen, um einen bisher unbekannten Typen auf normalem Weg analysieren und ggf. eintragen zu lassen.\par
Gleich mal entsprechend umbauen.\par
\par
Das Problem daran ist aber:\par
- Zum TypeHandlerManager bauen braucht man letztendlich die CustomTypeHandlerRegistry\par
- Um die CustomTypeHandlerRegistry initialisieren zu k\'f6nnen, br\'e4uchte man nun den TypeHandlerManager. Das ist ... schlecht.\par
\par
Was tun? Einen Supplier dazwischenklemmen? Der BinaryHandlerClass braucht den TypeHandlerManager ja garantiert erst nach dessen Instanzierung. Er muss nur vorher schon wissen, wie er sp\'e4ter an den rankommen wird.\par
Hei\'dft: Supplier. Hm. K\'f6nnte die sauberste L\'f6sung sein.\par
So einbauen.\par
Testen.\par
\par
Oh, interessant:\par
PersistenceObjectManager$Default#validate\par
Checkt nochmal extra auf Class mit FIXME, dass diese Stelle mit der TypeValidierung im HandlerCreator konsolidiert werden sollte.\par
\par
Das kann eigentlich raus, weil zwar eine OID allokiert wird, aber vor der Registrierung in der ObjectRegistry kommt ja die TypeHandler Analyse und Validierung.\par
\par
Hm, aber moment mal: wenn jetzt f\'fcr jeden Type ein Handler erzeugt wird, wo kommt dann bei einem nicht persistierbaren Typ die Exception her?\par
Mal \'fcberlegen ...\par
PersistenceTypeHandler#guaranteeInstanceViablity bauen und dort aufrufen.\par
So passt das.\par
\par
\par
\par
2019-07-22\par
\par
PersistenceTypeHandlerManager$Default#internalEnsureTypeHandler wirft noch eine exception bei einem unpersistable type.\par
Das muss nat\'fcrlich umgebaut werden.\par
Wobei knifflig ist: soll ein unpersistable type, f\'fcr den ja nur ein leerer dummy angelegt wird, wirklich auch ausl\'f6sen, dass sein super type (sinnlos) analysiert wird?\par
Wenn nicht, m\'fcsste der Algorithmus hier ge\'e4ndert werden...\par
\par
Wo ich so dr\'fcber nachdenke: Welchen Grund gibt es denn \'fcberhaupt, dass die Superklasse gleich mitanalysiert wird?\par
Fr\'fcher war die Idee mal: Falls der konkrete Typ bei der Analyse keine exception werfen w\'fcrde, aber einer seiner Supertypen, dann h\'e4tte das schon beim konkreten Typ auffallen m\'fcssen, damit rechtzeitig abgebrochen werden w\'fcrde.\par
\par
Aber inzwischen denk ich mir:\par
- Wenn ein Typ unpersistierbar ist, wird ja trotzdem in jedem Fall ein TypeHandler erzeugt, wenn auch nur ein leerer und dann per Logik die Instanz-Verwendbarkeit sichergestellt.\par
- Wenn ein konkreter Typ persistierbar ist, interessieren seine supertypen dann \'fcberhaupt noch? Es kann ja sein, dass jemand einen special TypeHandlerCreator setzt, der eine konkrete Klasse korrekt handelt, z.B. Felder aus der Superklasse einfach ignoriert, aber nicht die superklassen selbst. Konkrete Instanzen von denen kommen ja evtl. nie vor, sondern nur von dem konkreten, sehr wohl handlebaren Typ.\par
\par
Ist so eine automatische Superklassenanalyse dann nicht einfach nur unn\'f6tige Typ-Klugscheisserei?\par
Reicht es nicht v\'f6llig aus, wenn eine konkrete Klasse korrekt gehandelt werden kann, fertig aus?\par
Da muss ich jetzt mal dr\'fcber nachdenken ...\par
\par
Es ist ja auch nicht so, dass die TypeDescription f\'fcr eine Kindklasse auf die der Superklasse verweisen w\'fcrde, sondern jede Klasse enth\'e4lt komplett die f\'fcr sie g\'fcltige Beschreibung, unabh\'e4ngig von einer Beschreibung der Superklasse.\par
Das war von Anfang an Absicht so, damit Handler f\'fcr abgeleitete Klassen optimiert werden k\'f6nnen: Felder aus der Superklasse, die sie gar nicht brauchen (bzw. aus eigenen Feldern herleiten k\'f6nnen), brauchen sie auch nicht mitpersistieren.\par
Bestes Beispiel neulich erst:\par
Die d\'e4mliche SynchronizedList Implementierung im JDK hat ein Feld List<E>.\par
Da sie aber von SynchronizedCollection ableitet, hat sie auch noch ein Feld Collection<E> aus der Superklasse.\par
In beiden Feldern steht IMMER dasselbe drin, n\'e4mlich eine Referenz auf die gewrappte Instanz. Nur einmal so typisiert und einmal so.\par
Weil die JDK boum n\'e4mlich zu bl\'f6d sind, Objektorientierung ordentlich zu machen, sondern sich lieber redundante Felder bauen.\par
Ein Custom Type Handler k\'f6nnte das kompensieren, indem er nur die List Refrenez speichert und beim Laden als die Collection Referenz nochmal die List Referenz setzt.\par
\par
Also kurz gesagt: Klassen sind in der Persistence Typanalyse komplett unabh\'e4ngig von ihren Superklassen.\par
Beim Sammeln ihrer zu persistierenden Felder wird nochmal extra auf die Superklassen zugegriffen, das muss auch so bleiben, damit man alle Felder f\'fcr den kompletten State hat.\par
\par
\par
2019-07-23\par
\par
persistable check vorziehen und Analyselogik allgemein bissl aufr\'e4umen und besser strukturieren, auch gleich in Vorbereitung zum enums handeln.\par
\par
Testen.\par
Funktioniert, aber paar allgemeine Auff\'e4lligkeiten. Das LegacyTypeMapping macht nicht das, was es soll. Der aktuelle Runtime Type steht in der veralteten TypeDescription drin, das darf nicht sein.\par
\par
\par
TODO:\par

\pard PersistenceTypeHandlerManager#initializeFromDictionary:\par
\cf1 v warum ist die TypeDefinition f\'fcr den nicht mehr existierenden type "Person" ein TypeHandlerGeneric f\'fcr die aktuelle "Person1", aber mit alter TypeId? wenn, dann m\'fcsste das ein LegacyTypeHandler sein...\par
v warum werden immer noch Map usw. Typen im dictionary definiert? Denen d\'fcrfte die Typanalyse nie begegnen im simplen Class Beispiel\par

\pard\sl276\slmult1\cf0\par
\par
2019-07-24\par
\par
Untersuchen ...\par
\par
Ah:\par
#1 ist so, wenn der abgeleitete Handler noch genau auf die alte struktur passt. Dann hat sich sozusagen nur der Name ge\'e4ndert und es gibt keinen Grund, eine neue Typversion anzulegen.\par
\par
\par
2019-07-25\par
\par
Mir ist daheim eingefallen: was soll passieren, wenn eine typeId nicht mehr zu einer runtime type instanz aufgel\'f6st werden kann?\par
Das kann dann eigentlich nur ein vergessener Refactoring Eintrag sein, ansonsten h\'e4tte sich jemand ja sein Typegef\'fcge kaputt gemacht (und m\'fcsste zumindest wieder einen Dummytyp nachr\'fcsten).\par
Das Problem ist halt: Soll der Handler eine exception werfen und das ganzen Laden abbrechen, ggf. sogar einen ablauf der anwendungslogik damit ruinieren?\par
Oder soll er einfach null zur\'fcckgeben? Wenn die Instanz nicht gebraucht wird, super, wenn doch, dann ist das halt ein NPE, so als w\'fcrde man in einer "type()" Methode null zur\'fcckgeben, weil man den Typ gel\'f6scht hat.\par
Klingt eigentlich konsistent, oder?\par
\par
\cf2\b TODO: Hm... muss ich mal noch \'fcberlegen.\cf0\b0\par
\par
Weitertesten...\par
#1 mit ver\'e4nderter Feldstruktur\par
Passt: mit ge\'e4nderter Feldstruktur hat die alte TypeId nur noch eine Typedefinition und als Handler wird ein von der neu angelegten TypeDescription Handler verwendet und mit der neuen TypeId initialisiert.\par
\par
Das mit der neuen Class in der alten TypeDefinition passt auch schon so: Die alte TypeDescription mit alter TypeId und altem TypeName bekommt in der TypeDefinition die ge\'e4nderte Klasseninstanz, falls m\'f6glich, weil das ja ihre (neue) Identit\'e4t in der laufenden Anwendung ist.\par
\par
Jetzt schauen wegen #2: Wieso sind Feldtypen im Dictionary?\par
\par
Ach! Es gibt in PersistenceTypeHandlerManager$Default#internalRegisterTypeHandler ja doch schon so ein rekursives Feldtypen abklappern.\par
Hm. Das ist aber etwas naiv bzgl. der \'dcberlegungen von neulich. Mal suchen und untereinander verlinken ...\par
\par
Issue priv#122 erstellen...\par
\par
\par
\par
Morgen noch die 2 priv#109 TODOs und checkedCollections testen.\par
\par
\par
2019-07-26\par
\par
TODOs umsetzen, ist eigentlich nur ein Statement l\'f6schen und einen Kommentar schreiben.\par
Aach, dann kann der PersistenceRefactoringResolverProvider im Handler wieder rausfliegen, nice.\par
\par
Bei der Gelegenheit endlich mal priv#123 erstellen und umsetzen.\par
\par
CheckedCollections testen.\par
Erst mal wieder per reflection hack auf den CheckedCollection type zugreifen k\'f6nnen, weil die JDK Boum wieder mal zu bl\'f6d sind, interfaces zu benutzen.\par
\par
Jetzt testen:\par
Oh, interessant: Exception beim roots speichern:\par
Type not persistable: "interface java.util.Collection"\par
Muss ich dann mal debuggen ...\par
\par
Aaaach, mir ist beim D\'f6sen in der Mittagspause eingefallen, wieso: Felder mit abstraktem Typ d\'fcrfen nat\'fcrlich nicht hart gepr\'fcft werden, ob Instanzen von genau diesem Typ persistierbar sind, sondern Instanzen von Subtypen persistierbar sind. Das ist bei Abstrakten typen true, bei "echt unperstitable" Typen false. Also doch einen extra handler f\'fcr abstrakte typen bauen. Passt.\par
\par
Testen...\par
Bissl an dem reflection hacking rumbasteln, damit auch maps gehen ...\par
Funktioniert.\par
\par
Jetzt noch restliche Collections testen:\par
Collections.unmodifiable~\par
\par
Und gleich noch die restlichen collections mit rein.\par
CheckeQueue hab ich vergessen. Nachr\'fcsten.\par
Da f\'e4llt mir auf: ich hab bisher 2 Konstanten vergessen. Mal nachr\'fcsten.\par
Ach, Moment mal: Ne, die 2 zus\'e4tzlichen Methoden geben dieselbe Instanz zur\'fcck wie die anderen. Also wieder rausmachen und den Kommentar direkt in die Konstantenregistrierungszeilen rein...\par
\par
Weiterschauen ...\par
\par
Ah, interessant: \par
CopyOnWriteArrayList hat nur transient felder. Darum gibts bei der keine Exception (das Lock Feld ist eigentlich nicht persistable). Es wird einfach ein stateless handler erzeugt und nix gespeichert.\par
Hei\'dft: Die braucht auch einen explizit registrierten Handler. Halt dann einen generischen, der einfach den Konstruktor aufruft. Dann ist auch gleich das Lock wieder da. Passt.\par
\par
Next ...\par
Okay, die COWSubList wird ein Problem:\par
Wenn man sie generisch handelt, speichert sie ihr sinnlos bl\'f6dsinniges redundantes Array mit ab und beim Laden gibt es dann eine ConcurrentModificationException, weil die JDK Leute zu dumm zum programmieren sind.\par
Custom handeln kann man sie nicht, weil man, wie \'fcblich, nicht an die n\'f6tigen internenWerte (offset und l) rankommt.\par
Hm. Eigentlich gilt das f\'fcr alle SubList Implementierungen, die auf ihre parent collection zeigen und sich einen offset merken. Hm...\par
Vielleicht sollte ich alle Sub~ Typen als unpersistable registrieren. Wenn sich einer einen JDK-spezifischen CustomHandler schreibt, kann er den ja als Override registrieren.\par
Das mach ich so.\par
Erst mal zusammenfieseln, was es alles so an Deppenimplementierungen von SubLists gibt und dann rumfieseln, wie man an jede davon rankommt.\par
Z.B. lustig: Die RandomAccess ArrayList$SubList leitet NICHT von RandomAccessSubList ab. Das w\'e4re ja sinnvoll, das darf man auch keinen Fall machen.\par
\par
Rationale Kommentar der Unpersistable Typen um SubLists Punkt erweitern.\par
\par
Jetzt CopyOnWriteArraySet...\par
Aach, Moment: das wrappt ja nur eine CowrayList. Dann braucht das keinen special handler.\par
\par
Mal weiterschauen ...\par
Also SubMaps tu ich mir nicht an.\par
Die crazy Shit ProcessEnvironment HashMap auch nicht.\par
Ich w\'fcrd sagen, dann wars das.\par
Mal nochmal den Test laufen lassen ...\par
\par
Hm, PriorityQueue ist nach dem Laden leer.\par
Untersuchen ..\par
\par
\'d6h ... da fehlte die complete Methode ... ^^.\par
Nachr\'fcsten und gleich mal bei allen anderen checken.\line War der einzige Fall.\par
Testen. Passt.\par
\par
priv#109 und priv#101 updaten und schlie\'dfen.\par
Fertig.\par
\par
\par
\par
}
 