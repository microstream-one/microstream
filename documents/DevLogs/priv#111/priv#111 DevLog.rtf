{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-09-30\par
\par
Erst mal Brain Storming, was alles beteiligt ist:\par
\par
1.) Direkte Memory Allocation, z.B. um Entitydaten im Storage-Layer zu cachen.\par
-> k\'f6nnte gel\'f6st werden \'fcber ein simples byte[] bzw. evtl #3\par
ABER: wie gemeinsamen Nenner f\'fcr API?\par
\par
2.) ByteBuffer bef\'fcllen. (Wenn's kein DirectByteBuffer ist, wird intern vor dem Schreiben erst noch in einen DBB umkopiert. Kein Witz)\par
-> k\'f6nnte gel\'f6st werden, indem die ByteBuffer API aufgerufen wird, ggf. mit ByteOrder immer auf die System-Byteorder gesetzt, damit da nicht sinnlos rumgedreht wird und beim auslesen wieder zur\'fcck.\par
\par
3.) Direkte Memory-Zugriffe auf eine blanke Speicheradresse \par
-> byte[][] mit simulierter absoluter speicheradresse (siehe Issue Beschreibung)\par
? Oder evtl. einem gro\'dfen DirectByteBuffer unterteilt in mehrere Abschnitte? hm ...\par
\par
4.) Direkte Memory-Zugriffe auf eine Instanz mit offset\par
-> K\'f6nnte gel\'f6st werden mit ValueHandler Interface mit unterschiedlicher Implementierung intern (siehe Issue Beschreibung)\par
\par
5.) ValueSetter und ValueStorer Signaturen haben direkte Speicheradresse\par
-> k\'f6nnte gel\'f6st werden mit #4: \'dcbergeordnete Architekturschicht, die diese Typen gar nicht erst n\'f6tig macht.\par
ABER: wie sollen dann ValueTranslator und die ganzen um-map-Legacy-Handler geschrieben werden? Auch noch weiter abstrahieren?\par
\par
\par
\par
Ich denke, das einfachste w\'e4re erst mal, #4 und #5 umzusetzen und dann zu schauen, wie der performance Unterschied von Unsafe zu Reflection und von Unsafe zu direkten DirectByteBuffer methodenaufrufen w\'e4re.\par
\par
\par
\par
2019-10-01\par
\par
Mal im eclipse suchen, wo \'fcberall Unsafe vorkommt.\par
Kommt (immer noch) nur in der Klasse XMemory vor, das hab ich ja schon mal konsolidiert.\par
Sehr sch\'f6n.\par
Das WIP Projekt z\'e4hlt ja nicht, das wird nicht deployt.\par
\par
Also ist die Frage, wo XMemory \'fcberall vorkommt.\par
\par
Insgesamt 890 Vorkommen, die ersetzt werden m\'fcssen.\par
30 Vorkommen im JDK8Internals Projekt. Die z\'e4hlen nicht, denn die k\'f6nnen so bleiben, weil das JDK8 garantiert eine zug\'e4ngliche Unsafe Klasse hat und immer haben wird.\par
50 Vorkommen im WIP. Die sind komplett egal.\par
\par
Der Rest muss ersetzt werden:\par
\par
Ca. 130 Vorkommen im Base Projekt. Die sind erst mal nicht wichtig, m\'fcssten letztendlich aber auch ersetzt/modularisiert werden. Hm...\par
\par
6 Vorkommen im Communication Projekt. Ignorier ich erst mal. Sp\'e4ter ...\par
\par
1 ganzes Vorkommen im Persistence Projekt, n\'e4mlich f\'fcr den Instantiator.\par
Das l\'e4sst sich nat\'fcrlich irgendwie verschieben/ersetzen, wobei das schon eine interessante Frage aufwirft:\par
Ohne low-level Instantierung braucht man die "Es muss einen default Konstruktor ohne logik drin geben"-Seuche als Einschr\'e4nkung f\'fcr die Verwendung des Frameworks.\par
Oder nat\'fcrlich einen expliziten Instantiator.\par
\par
Ca. 100 Vorkommen im Storage Projekt.\par
Manche davon sind trivial, z.B. DefaultBufferSize. Oder primtive Byte sizes. Bzw. diese Aufrufe k\'f6nnen sogar bleiben. Oder man trennt die irgendwie raus, ist ja egal.\par
Der Rest sind lauter Operationen mit absoluter Speicheradresse.\par
\par
Ca. 650 Vorkommen im PersistenceBinary Projekt.\par
Lustig lustig: Davon ca. 400 in der BinaryValueTranslators Monsterklasse. Bzw. das sind alles nur Funktionsimplementierungen f\'fcr das BinaryValueSetter interface, das einen Wert von einer absoluten Adresse zu einer relativen oder absoluten Adresse setzt.\par
\par
Und dann noch 250 "sonstige" Vorkommen. In BinaryHandler Implementierungen usw.\par
\par
Puh ...\par
Da w\'e4re es fast sinnvoller, erst mal ein paar damit \'fcberschneidende Issues vorzuziehen, weil die auf saubere Art eine ansonsten eher provisorische L\'f6sung bringen w\'fcrden.\par
Z.B. Die gescheite Abstraktion von BinaryFields. Evtl. sogar das ValueAccessor Konzept.\par
\par
Diese 890 Vorkommen erzeugen unterschiedlichen Aufwand:\par
Ein paar davon (sagen wir pauschal 89) sind unproblematisch, weil sie einfach Konstanten sind (default buffer size, binary length von primitives, usw.)\par
Der eine Instantiator ist trivial ersetzbar, aber erzeugt damit ein riesen Problem: Ohne das braucht man in jeder Entityklasse einen "passenden" Konstruktor oder einen vom Entity Designer manuell zu bauenden Instantiator.\par
Die 400 f\'fcr die BinaryValueTranslators lassen sich alle nach Schema F ersetzen, sobald es ein passendes Ersatzkonzept gibt. Das ist dann nur eine Flei\'dfarbeit.\par
Die restlichen 400 m\'fcssen je nach Fall analysiert und passend ersetzt/abstrahiert werden. Das werden nat\'fcrlich keine 400 Einzelf\'e4lle, sondern vielleicht 10 oder so Kategorien an Modularisierung/Abstraktion und dann m\'fcssen alle 400 F\'e4lle auf die passende L\'f6sung umgebaut werden.\par
\par
Au\'dferdem knifflig:\par
Was immer an Modularisierung/Abstraktion gemacht wird, sollte ja m\'f6glichst so sein, dass der Normalfall keine oder kaum Performance oder gar Funktionalit\'e4t verliert.\par
Da muss ich viel analysieren, \'fcberlegen, rumprobieren.\par
\par
Mal Issue updaten ...\par
\par
\par
Jetzt mal \'fcberlegen zu BinaryValueSetter Abstraktion.\par
Gibt eigentlich nur zwei Stellen: in Binary f\'fcr #updateFixedSize und in BinaryLegacyTypeHandlerRerouting zum binary values translaten.\par
Das zweite verschieb ich mal in eine Binary#copyMemory Methode.\par
\par
\par
Hm... interessante Idee:\par
Das byte[][] w\'e4re wahrscheinlich gar nicht n\'f6tig. DirectByteBuffer gibt es \'fcberall (z.B. in Android hier: {{\field{\*\fldinst{HYPERLINK https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/java/nio/DirectByteBuffer.java }}{\fldrslt{https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/java/nio/DirectByteBuffer.java\ul0\cf0}}}}\f0\fs28 ). Muss es wahrscheinlich sogar geben, weil ja die JDK public API eine entsprechende Methode (ByteBuffer#allocateDirect) besitzt.\par
\par
Es k\'f6nnte also reichen, an den entsprechenden Stellen anstatt einer blanken Adresse ein Paar von DBB+Offset Werten zu \'fcbergeben. Die normale Implementierung kann sich daraus ihre absolut Adresse errechnen und gl\'fccklich arbeiten, wie bisher. Implementierungen ohne Unsafe m\'fcssen halt jedes mal einen Lookup \'fcber den Offset machen.\par
\par
Ich muss mal schauen, ob das irgendwo API-technisch Probleme macht.\par
\par
Mal daf\'fcr bissl umbauen:\par
BinaryEntityDataReader#readBinaryEntityData(long)\par
umbauen zu\par
BinaryEntityDataReader#readBinaryEntities(DirectByteBuffer)\par
Macht intern dann das gleiche wie bisher, aber evtl. kann man dann nach ein paar solcher Umformungen die LoadItemErstellung abstrahieren und modularisieren.\par
Aaach, da kommt wieder das byteOrderSwitching rein. Aber das macht nix. Da muss nur einmal ein boolean gecheckt werden f\'fcr mehrere Entities auf einmal.\par
Oh, dann f\'e4llt sogar der Check auf die ByteOrder bei jedem einzelnen LoadItem weg. Das ist super!\par
\par
Oh, beim refactoren aufgefallen:\par
Der ChunksBuffer (speichern) hat bisher die DBBs bis limit ausgelesen.\par
Der ChunksWrapper (laden) hat bisher die DBBs bis position ausgelesen.\par
\par
Dann kann ich das nicht so abstrahieren, dass beide Varianten immer bis limit auslesen.\par
Es sei denn, dass im zweiten Fall position immer gleich limit ist.\par
Muss ich recherchieren ...\par
- Also der ChunksWrapper wrapt einfach nur ein Array an ByteBuffers. Darum hei\'dft er ja wrapper.\par
- Der wird nur verwendet in der BinaryFileSource. Dort l\'e4uft das ganze sehr simpel: limit wird auf die File L\'e4nge gesetzt und es wird solange eingelesen, bis position gleich limit ist. Also kann auch limit verwendet werden.\par
- Bei der eigentlichen Storage werden zum lesen ChunkBuffers verwendet. Dort wird mit position gearbeitet und am ende geflipt (limit = position, position = 0). Darum wird dort limit verwendet.\par
Fazit: in beiden F\'e4llen passt limit als grenze. Sollte das mal ein Problem machen, muss eben das limit entsprechend gesetzt werden.\par
\par
So. Umgebaut. Testen. Passt.\par
\par
Mal weiter schauen wegen Abstraktion...\par
Also man k\'f6nnte eine zweite BinaryLoadItem Implementierung machen, die die address als Position im DBB interpretiert und sich den entsprechenden DBB dazu merkt.\par
\par
Was das ganze letztendlich ziemlich kompliziert bis unm\'f6glich macht, ist, dass Binary halt kein Interface, sondern eine Klasse ist.\par
Dadurch st\'f6ren ein paar Methoden und Modularisierung w\'fcrde bedeuten, dort interface-ierte Logikinstanzen reinzuh\'e4ngen. Dann kann man gleich das ganze Ding zu einem Interface machen und sich mit einem Provider f\'fcr eine plattform das passende geben lassen.\par
\par
Hei\'dft: Der Auftrag f\'fcr morgen ist, das Ding durch ein interface zu ersetzen und zu checken, wie sich die performance ver\'e4ndert.\par
\par
Davon unabh\'e4ngig muss die API mal aufger\'e4umt werden, damit die ganzen direkten Addressen als implementierungsdetails verschwinden. Mit 2-3 Methoden hab ich das schon gemacht. Geht ganz gut.\par
Da kommt dann auch wieder das BinaryField Konzept ins Spiel ...\par
\par
\par
\par
 2019-10-02\par
\par
Binary zu interface umbauen.\par
\par
Puh... das wird ... viel Arbeit. Die Klasse ist 2000 Zeilen lang. Darin befinden sich viele statische, private und public Methoden. Jeweils unterteilt in welche mit absolutem Memory-Address, die m\'fcssen intern implementierungsspezifisch bleiben. Und welche, die "schon" oder von Haus aus Memory-Address-unabh\'e4ngig sind, die m\'fcssen ins Interface rein.\par
Dazu muss ich erst mal Methode f\'fcr Methode durchk\'e4mmen, was wo dazugeh\'f6rt. Dann f\'fcr die eine Gruppe zu interface Methoden erstellen. Und dann Aufruferklassen entsprechend umbauen.\par
\par
Die updateFixedSize h\'e4tte noch MemoryOffsets in Instanzen rein, was f\'fcr eine Unabh\'e4ngigkeit von Unsafe nicht sein darf. Aber die m\'fcsst ich erst mal mitziehen und dann sp\'e4ter das Konzept \'e4ndern (ValueSetters, die intern den Offset halten - oder dann eben das Field direkt f\'fcr eine reflection Operation).\par
\par
Au\'dferdem stellt sich wieder mal die Frage, ob "Binary" wirklich ein unsauber typisierter Kombityp sein muss, weil die API Bestandteile wirklich nicht auf "BinaryStoring", "BinaryReading" und "? extends Binary" typisiert werden k\'f6nnen...\par
\par
... Mehrere Besprechungen, Support f\'fcr CK und FH sp\'e4ter ist der Tag irgendwie um. Kaum was am Issue gearbeitet ...\par
\par
Hm... Die \'c4nderungen commit ich mal nicht, sondern stash sie nur oder so.\par
\par
\par
\par
}
 