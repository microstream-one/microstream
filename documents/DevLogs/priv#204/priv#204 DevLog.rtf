{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 Auto-Recognize CSV Separator Character\par
priv#204\par
\par
\par
2020-02-04\par
\par
So. N\'e4chstes Thema. CSV Separator Automatisierung. Damit mal das Geheule aufh\'f6rt, wieso nicht der schwachsinnige Separator Character verwendet wird und wenn ein besserer verwendet wird ist es so unendlich verwirrend, dass man mit so einem File nicht mehr zurecht kommt. Trollololo.\par
\par
Also eigentlich ist es nur, die StringTable.Static#parse Methoden um Varianten f\'fcr einen vorgegebenen Separator zu erweitern und eine guessing Logik einzubauen.\par
Aber erst mal benenn ich alle "Csv~" Teile in "XCsv" um. Und JavaDoc schreib ich auch gleich. Zumindest den Class Header von XCSV, um kurz zu definieren, was das Format ist.\par
\par
\par
2020-02-05\par
\par
Weitermachen.\par
\'dcberlegung von dazwischen: XCSV braucht eine Liste an validen valueSeparators und die gegen die werden custom separators validiert und nur die werden dann auch f\'fcr den scan verwendet.\par
\par
Separator-guessing Scan einbauen.Daf\'fcr erst mal default XCsvConfiguration bestimmung umbauen.\par
Guessing Scan Algorithmus bauen.\par
\par
23:00\par
\par
Paar Ideen von zwischendurch einbauen.\par
Und jetzt ist die Frage: Wie mach ich die Auswertung?\par
Die verschiedenen Werte sollten wohl mit einem Faktor zu einem Gesamtevaluierungswert zusammenaddiert werden.\par
\par
Ein Problem wird:\par
Was ist, wenn man eine Datei aus vielen Dezimalzahlen hat. Z.B. so:\par
1.1, 1.2, 1.3, 1.4\par
\par
"." kommt 4 mal vor, "," kommt 3 mal vor.\par
Beide konsistent in jeder Zeile.\par
Oder so:\par
\par
1,1. 1,2. 1,3. 1,4\par
Also "." ist der valueSeparator, "," ist das Dezimaltrennzeichen\par
Man erkennt durch das konsistente Leerzeichen, was der Separator sein muss, aber ein simpler Z\'e4hlalgorithmus w\'fcrde hier immer das Dezimaltrennzeichen als value separator erkennen.\par
Doof.\par
\par
Oder noch krasser:\par
1,1.1,2.1,3.1,4\par
Jetzt tun sogar wir uns schwer, die Zahlen richtig zu interpretieren.\par
Aber der Ersteller der Datei, der den "." als Value Separator gew\'e4hlt hatte, versteht es ganz eindeutig.\par
\par
Wobei das mit dem "." als valueSeparator schon ein sehr spezieller Fall ist. Eigentlich unrealistisch konstruiert.\par
Wenn jemand so krassen Schei\'df baut, dann m\'fcsste es wirklich zumutbar sein, dass er sein Schei\'df-Zeichen explizit vorgibt.\par
\par
Vielleicht m\'fcsste das untersuchte zeichen einen Bonus- bzw. Malusfaktor liefern:\par
"\\t" = 1.3\par
";" = 1.2\par
"," = 1.1\par
"*" = 0.9\par
"#" = 0.9\par
"-" = 0.8\par
"." = 0.8\par
\par
Hei\'dft:\par
Wenn mehrere Zeichen \'e4hnlich oft vorkommen, wird eher das bevorzugt, das typischer f\'fcr Trennzeichen ist.\par
Das sollte dann bis auf die obigen Schei\'dff\'e4lle alles korrekt abdeckten.\par
\par
2020-02-08\par
\par
Jetzt mal wieder hier weitermachen.\par
Den Evaluierungsalgorithmus muss ich noch weitermachen, aber erst mal was ganz einfaches:\par
Bekannte Dateiendungen und welche value separators sie haben.\par
\par
Hm... oder vielleicht nur bevorzugte Gewichtungen? Dann m\'fcssten diese Gewichtungen aber in eine ordentliche Datenstruktur rein, mit Builder usw.\par
Oder ich mach einfach ein komplettes Gewichtungsarray je Dateiendung. So mach ichs.\par
\par
Dazu doch einen ordentlichen Typ ValueSeparatorWeight bauen.\par
Und je ein Array davon per File Suffix\par
\par
FileSuffix besser umbenennen zu data type und ohne Punkt vorn dran.\par
\par
Parser und Builder Zeugs erweitern um einen entsprechenden Parameter f\'fcr den Datatype.\par
Das Mapping auf die Weights passiert dann erst ganz innen.\par
\par
HM. Evtl. sollte der dataType String doch besser eine enum sein.\par
Und die k\'f6nnte das ValueSeparatorWeight[] dann gleich enthalten.\par
Aber dann w\'e4r es wieder bl\'f6d, wenn das ein array w\'e4r, weil das mutable ist.\par
Muss ich als TODO machen und sp\'e4ter dann nacharbeiten.\par
\par
File Suffix auslesen einbauen. Hm. Das mach ich gleich als generische Funktionalit\'e4t in XIO.\par
Und alle '.' Vorkommen, die file suffix separator sein sollen, durch die entsprechende XIO Methode ersetzen.\par
\par
Ach, was solls. Mach ich die TODOs gleich noch:\par
Schnell ValueSeparatorWeight Klasse zu interface umbauen.\par
String dataType zu XCSV.DataType. Inklusive Mapping-Table.\par
\par
Gleich soweit in den eigentlichen Algorithmus eingebaut, dass der direkt in der Rechnung das weight auslesen kann.\par
\par
Den bau ich aber wan anders.\par
Dann ist die automatische ValueSeparator Erkennungsmagic schon wieder fertig zum testen...\par
\par
\par
2020-02-12\par
\par
Nach wieder mal dazwischengeschobenen Issues jetzt wieder hier weitermachen.\par
Erst mal wieder in bestehende Code f\'fcr Algorithmus eindenken.\par
Benamung verbessern.\par
Inneren Loop auslagern in Methode.\par
Dabei aufgefallen: Die lines jedes mal redundant mitz\'e4hlen ist Quatsch.\par
Ich mach einen vorangestellten extra Loop, der nur die recordSeparators (seit Kommentare erlaubt sind, eigentlich doch "Line Separators") z\'e4hlt.\par
Dann f\'e4llt das aus dem komplizierteren Algorithmus raus und macht nicht redundant Zeug.\par
\par
Das mit dem line und record muss ich jetzt wirklich mal konsolidieren. An vielen Stellen im XCSV Framework hei\'dft es schon line, aber noch nicht einheitlich.\par
\par
Ach: es g\'e4be ja doch einen Unterschied zwischen recordSeparator und lineSeparator. Aber lineSeparator ist nur eine interface default methode mit hardgecodet '\\n' als R\'fcckgabewert.\par
Also streng genommen k\'f6nnte man sich ja vorstellen:\par
Eine XCSV Datei enth\'e4lt beliebig viele Zeilen, etwa Kommentare, Leerzeilen, usw. und dann kommt EINE Zeile mit den Daten und in dieser wird irgendein anderes Zeichen als recordSeparator verwendet.\par
Das wird dann aber alles ziemlich knifflig: Was ist, wenn zwischen Records auf einmal ein Zeilenumbruch kommt? Und wer wei\'df, was noch alles.\par
Darum macht es schon Sinn, hier zu vereinfachen:\par
Ein Record wird IMMER von einem Zeilenumbruch Zeichen beendet. Welches das ist, ist konfigurierbar. Normalerweise \\n. F\'fcr die Idioten \\r. Und wenn einer unbedingt meint, dann auch | oder sonstwas.\par
Aber record separator und line separator sind erst mal identisch.\par
\par
Jetzt wieder Algorithmus \'fcberlegen ...\par
Wie mach ich das am besten... direkt in die Counter Klasse rein? Oder au\'dferhalb? Oder extra Klasse?\par
Da das ganze ein rein lokaler Algorithmus ist, muss das alles nicht so super sauber strukturiert und modular sein. Direkt in den Counter rein, fertig.\par
\par
Am besten einfach ein "score" Wert, in den alle gesammelten/gez\'e4hlten Werte reingemanscht und zum Schluss noch mit dem konfigurierten weight multipliziert werden.\par
\par
Dann gleich noch eine orderByScore Methode dazu. Gesammtelte Counters damit sortieren. Letzten ausw\'e4hlen, character zur\'fcckgeben, Config draus bauen.\par
\par
Jetzt fehlt nur noch das "reinmanschen", dann ist das Issue fertig zum testen.\par
Mal schauen ..\par
\par
averageCountPerLine macht Sinn.\par
emptyLineRatio macht Sinn.\par
Ah: minCountPerLines darf nicht 0 werden k\'f6nnen, daf\'fcr gibts ja die emptyLines. Muss ich gleich \'e4ndern.\par
\par
So. Iirgendwie m\'fcssen jetzt die Ausschl\'e4ge von maxCount und minCount gegen\'fcber avgCount zusammengerechnet werden.\par
Und lineCountChange auch noch. Hm.\par
\par
Verh\'e4ltnis von maxCount zu avgCount macht Sinn.\par
Verh\'e4ltnis von minCount zu avgCount macht Sinn.\par
\par
Jetzt ist die Frage: Wie normalisiert man den lineCountChange Wert ordentlich?\par
Gerade der w\'e4r so interessant. Denn beim richtigen separator w\'e4re der SEHR klein. Nicht unbedingt 0, weil es ja auch string literals gibt, in denen z.B. "," oder ";" vorkommen, aber nahe bei 0.\par
Achso, hm. Nat\'fcrlich auch einfach durch die Gesamtzahl der Zeilen teilen. Das ist dann die durchschnittliche Abweichung "pro Zeile".\par
\par
Aach, hehe. Und nat\'fcrlich eine ganz triviale Regel: Wenn totalCount == 0, dann score 0.0.\par
\par
Jetzt noch die ganzen Ratios in ]0.0;1.0]-Faktoren umrechnen.\par
Und dann einfach mal alles zusammenmultiplizieren mit dem average line count als Basiswert.\par
\par
Jup. Fertig zum Testen.\par
Debugausgaben einbauen.\par
Und bevor ich das einlesen nochmal nachbau, schieb ich es lieber als static util methode in XCSV direkt rein.\par
\par
Testdaten bauen.\par
\line Testen.\par
Erst mal alle 0.0, haha.\par
Debuggen.\par
\par
Aufgefallen:\par
v lineCountChange darf in der ersten Zeile nicht gez\'e4hlt werden.\par
v anscheinend wird eine zeile nicht mitgez\'e4hlt. erste oder letzte. Ach! Ich hab ja das updaten nach der schleife vergessen. Das vergess ich jedes mal ...\par
v f\'fcr alle Z\'e4hlvariablen long hernehmen ist herzlich d\'e4mlich bei einem auf int begrenzten array. Wie komm ich auf sowas...?\par
\par
Alles gefixt, wieder testen.\par
Debugausgaben fixen und verbessern.\par
\par
Jo, sieht gut aus.\par
Evtl. test ich abends noch ein paar F\'e4lle, aber der erkennt das soweit getestet einwandfrei.\par
Fertig.\par
\par
\par
2020-02-13\par
\par
00:20\par
Leider schon wieder mal zu sp\'e4t dran f\'fcr den Vortag.\par
\par
Eine Idee zum Testen ist nat\'fcrlich noch:\par
File-suffix-bedingt einen bias f\'fcr den einen Separator, aber tats\'e4chlich einen anderen verwenden.\par
Am besten gleich was fieses, n\'e4mlich "," Trennzeichen erwartet, das tats\'e4chliche Trennzeichen ist ";", aber "," kommt fast genauso oft vor als Dezimaltrennzeichen.\par
\par
Hm. Dazu erst mal recherchieren, was jetzt WIRKLICH das Standardtrennzeichen f\'fcr CSV ist. ";" oder ",".\par
Der Name w\'fcrde immerhin "," sagen, aber man kennt es meist mit ";". Neulich hab ich aber wieder "," gesehen.\par
Die Beispiele in {{\field{\*\fldinst{HYPERLINK https://en.wikipedia.org/wiki/Comma-separated_values }}{\fldrslt{https://en.wikipedia.org/wiki/Comma-separated_values\ul0\cf0}}}}\f0\fs28  sind auch alle mit ",".\par
Dann mach ich jetzt doch lieber "," als Standard f\'fcr die "csv" Endung. Hei\'dft ja immerhin "CSV" und nicht "SCSV".\par
\par
Also Test bauen ...\par
\par
Echt interessant:\par
- Bias f\'fcr ","\par
- Trennzeichen ist aber ";". 3x2 in header und den beiden Datenzeilen.\par
- "," kommt als Dezimaltrenner vor. 2x3 nur in den beiden Datenzeilen.\par
\par
D.h. Bias spricht f\'fcr ",". Anzahl ist die gleiche. Aber trotzdem ist der Score am Ende krass unterschiedlich:\par
"," = 0.975 (weight = 1.3)\par
";" = 2.4 (weight = 1.2)\par
\par
Das macht die empty line und der line count change. Also perfekt genau wie beabsichtigt.\par
\par
Noch Testdaten in die Main Klasse reinschreiben. Ist ja eh nur winzig.\par
Debug-Code auskommentieren.\par
\par
Und dann w\'fcrd ich sagen: Das Issue ist abgeschlossen.\par
\par
\par
13:00\par
Jetzt weiter, mit noch paar Kleinigkeiten, die mir zwischendrin eingefallen sind:\par
\par
v XCSV.DataType in eigenes File schieben mit Namen XCsvDataType. Muss ja nicht immer diese Nesterei sein.\par
v Jede XCsvDataType Instanz sollte gleich eine configuration Instanz haben. Die jetzige default Instanz ist dann einfach die der XCsv enum.\par
v Achja und die Testdateien in die Main Klasse schreiben.\par
Aber es war noch irgendwas ... noch irgendeine wichtige Kleinigkeit...\par
\par
Dabei gleich mal den XCsvConfiguration.Builder.Default Konstruktor package-private machen.\par
v Jetzt wei\'df ichs wieder: Die Reihenfolge der valid Separators umstellen und ":" von 0.9 auf 1.0 setzen.\par
Hm... oder ist das wirklich so gut? Immerhin haben Uhrzeiten haufenweise ":" drin... \par
Also Reihenfolge umstellen ja, Gewichtung nein.\par
\par
Nochmal Test durchlaufen lassen mit allen 4 aktuellen Testdateien.\par
Oh, Exception.\par
Ach, wegen der ge\'e4nderten Initialisierungsreihenfolge durch die Erweiterung um die Config.\par
Hm, ne, das liegt daran, dass die Config Instanz vor den enum Instanzen erzeugt wird.\par
Dann mach ich das anders: Ich filter aus den definierten Weights den char mit dem h\'f6chsten weight raus und instanziert die config gleich nur intern.\par
Ne, das wird auch nicht gehen, weil um die XCsvDataType.XCSV Instanz anlegen die Instanz schon fertig sein m\'fcsste.\par
L\'f6sung: valid separators Liste doch nochmal extra statisch in XCSV definieren.\par
Dann kann ich umgekehrt die Gewichtungen der enum Instanzen dagegen validieren. Auch nicht schlecht.\par
So, jetzt passts.\par
\par
Ah, noch alte dataType String Methoden l\'f6schen.\par
\par
Ach und dann war noch die Sache, dass XCsvConfiguration auch gleich Schalter f\'fcr Headlines, Metacharacter line usw enthalten sollte.\par
Aber das w\'e4r dann was f\'fcr #218.\par
\par
Aber die parse und assemble Methoden vereinfach ich noch. Das ist gut zum Testen bzw. allgemein sinnvoll.\par
Hm. Eigentlich haben die ganzen XCsv~ Dinger in StringTable gar nix verloren. Die schieb ich alle nach XCSV r\'fcber...\par
\par
So, jetzt ist das sauber. Und das Issue ist fertig.\par
}
 