{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-06-12\par
\par
\par
F\'fcr den Anfang mal genau zusammenschreiben, wie das intern technisch l\'e4uft.\par
\par
EmbeddedStorageFoundation#createEmbeddedStorageManager(Object explicitRoot)\par
erzeugt intern ein Reference<Object> root\par
Regeln:\par
1.) Falls explicitRoot != null\par
Falls es schon eine Reference ist, dann casten, als root setzen und zur\'fcckgeben.\par
Ansonsten wrappen mit Reference\par
\par
Falls explicitRoot == null:\par
2.) Falls es einen RootResolver gibt, dann null zur\'fcckgeben\par
\par
Falls explicitRoot == null UND RootResolver == null:\par
3.) Reference<Object> mit inhalt null erzeugen, als root setzen und zur\'fcckgeben.\par
\par
"als root setzen":\par
- von der ConnectionFoundation einen neuen PersistenceRootResolver erzeugen, der auf die Root Instanz verweist (\'fcber die Indirektion eines Suppliers)\par
- den als RootResolver in die ConnectionFoundation setzen\par
\par
Erzeugt eine neue EmbeddedStorageManager Instanz mit der definierten "root" Root-Referenz-Instanz (potenziell null).\par
Die Referenz vom EmbeddedStorageManager ist nur soetwas wie eine "convenience" Referenz f\'fcr die dortigen Zugriffsmethoden. Die eigentliche Verkn\'fcpfung (zum Laden/Initialisieren) findet \'fcber den RootResolver statt.\par
\par
\par
EmbeddedStorageManager#root:\par
Gibt trivial this.root zur\'fcck (potenziell null).\par
Typ "Reference<Object>"\par
\par
EmbeddedStorageManager#storeRoot:\par
Ruft EmbeddedStorageManager.root() auf.\par
Falls zur\'fcckgegebene Instanz null ist, wird 0 als ID zur\'fcckgegeben, ansonsten wird die Instanz gespeichert und ihre ID zur\'fcckgegeben.\par
\par
\par
Das hat mehrere Probleme:\par
- storeRoot() impliziert, dass die \'fcbergebene Root Instanz gespeichert wird. Das ist aber nicht der Fall.\par
- Je nachdem, ob man eine Reference oder etwas anderes \'fcbergibt, ver\'e4ndert sich das verhalten der beiden root-bezogenen Methoden. Implizit, ohne es nachvollziehen zu k\'f6nnen (schei\'df casten).\par
- Falls es einen RootResolver gibt, gibt #root trotzdem null zur\'fcck und #storeRoot tut gar nichts. Das ist nicht konsistent.\par
- Falls ein expliziter supplier registriert wird, k\'f6nnte der evtl. eine andere root instanz zur\'fcckliefern, als der EmbeddedStorageManager sich gemerkt hat.\par
\par
\par
Fragen:\par
Warum kann nicht ein Object direkt als root referenziert werden?\par
Eine Reference<Object> zur\'fcckzugeben bringt typisierungsm\'e4\'dfig keinen Vorteil und wenn man eine expliziten Rootinstanz registriert, hat man die Typisierung so oder so.\par
\par
\par
2019-06-13\par
\par
Warum muss nochmal ein Supplier dazwischengeschaltet werden?\par
Ich glaube, die Idee war damals dass die Instanz noch nicht zur Erzeugungszeit des RootResolvers existieren muss, sondern auch erst nachtr\'e4glich erzeugt werden kann.\par
Z.B. wenn man erst den Storage Stuff aufsetzt und konfiguriert und danach erst die Anwendungsebene-Rootinstanz, weil die evtl. von irgendwelchen Configs o.\'c4. abh\'e4ngt.\par
Allerdings muss man sich fragen:\par
- Kommt das so wirklich praktikabel vor?\par
- Wenn ja, ist es wirklich nicht workaroundbar, z.B. einfach durch eine eigene Instanz, die Indirektion macht.\par
- Ist das den potenziellen Fehler wert, dass ein registrierter selbstgebauter Supplier mal mittendrin eine andere Instanz zur\'fcckliefert?\par
\par
Wenn man nur das Registrierten eines selbstgebauten Suppliers verbietet, dann braucht man den gleich nicht, weil er dann einfach nur eine sinnlose Zwischeninstanz ist.\par
\par
Oder es m\'fcsste so gemacht werden, dass der Supplier nur ein einziges mal aufgerufen wird und was immer der zur\'fcckgibt, wird dann "fest" als Rootinstanz referenziert.\par
Hm, das steht so sogar schon in PersistenceRoots$Defalt#setResolvedRoots.\par
\par
Das Problem ist, dass es hier einen Konflikt gibt:\line Es gibt den RootResolver mit PersistenceRoots usw, der n Roots behandelt und aufl\'f6st (n\'e4mlich f\'fcr Konstanten auch noch). Dort, wo die aufgel\'f6st/gesammelt werden, soll jeder Supplier nur einmalig aufgerufen werden.\par
Dann kann er davor/danach aber nicht nochmal aufgerufen werden, um die Referenz auf die "Haupt"-Root-Instanz zu produzieren.\par
Der StorageManager m\'fcsste sich den Namen der "Haupt"-Root Instanz merken und sich diese aus der Map mit den aufgel\'f6sten rausholen. Dann ginge es.\par
\par
Weiter recherchieren:\par
PersistenceRoots wird erzeugt (und damit die konkreten Root Instanzen aufgel\'f6st) in EmbeddedStorageFoundation#createEmbeddedStorageManager\par
Also VOR der Erzeugung des EmbeddedStorageManager.\par
\par
Aber Problem:\par
Zu diesem Zeitpunkt gibt es den Root Identifier nicht mehr.\par
Falls es nicht der Default ist, wurde der gewrappt in einem custom RootResolver.\par
Und der macht nichts anderes, als den Root unter dem Identifier als einen von vielen zu registrieren.\par
\par
Nun k\'f6nnte man nat\'fcrlich sagen:\par
Das explizite Roothandling funktioniert halt dann nur, wenn man auch eine explizite Instanz \'fcbergeben hat.\par
Das w\'e4re aber unvollst\'e4ndig und logisch falsch, denn:\par
Einen eigenen Root Supplier und/oder eigenen Identifier usw. \'fcbergeben, ist eigentlich nur eine API-Variante, die nicht zu anderem bzw. auf einmal ausbleibendem Verhalten f\'fchren sollte.\par
Z.B. das storeRoot w\'fcrde in diesem Fall gar nichts mehr machen. Das kann irgendwie nicht sein.\par
\par
Viel besser ist:\par
Der RootResolver muss eben das Feature, eine "Haupt-" oder "bevorzugte" Instanz zu haben, auch in seiner API reflektieren.\par
\par
Als ersten Schritt ersetz ich mal den BiFunction<String, Supplier<?>, PersistenceRootEntry> durch einen gescheiten PersistenceRootEntry.Provider.\par
Die \'c4nderung war trivial. Weiter im Text.\par
\par
\par
2019-06-14\par
\par
Dabei Problem aufgefallen:\par
PersistenceRootResolver$Builder$Default#registerRoot ruft auch nochmal den supplier auf und das zum Storage-Setup-Zeitpunkt, was den Supplier Ansatz de Facto \'fcberfl\'fcssig macht.\line Das muss ge\'e4ndert werden.\par
\par
\par
Ne Moment:\par
Der Supplier wird nur zusammen mit seinem Identifier in einen Entry gepackt, aber NICHT aufgerufen. Also genau so soll es sein. Passt.\par
War ich gestern schon so ersch\'f6pft von der W\'e4rme? :-D\par
\par
\par
Achja, der Supplier ist n\'f6tig, um Konstanten "dynamisch genug" (bzw. sp\'e4t genug) aufl\'f6sen zu k\'f6nnen.\par
Wichtig!\par
\par
\par
Also es gibt zwei Stellen, wo PersistenceRootEntry#instance, d.h. das .get() vom Supplier, aufgerufen wird:\par
1.) PersistenceRootResolver$Default#getRootInstances\par
\tab - BinaryPersistenceRootsProvider$Default#provideRoots\par
\tab\tab - 1a) EmbeddedStorageFoundation$Default#createEmbeddedStorageManager\par
\tab\tab - 1b) EmbeddedStorageFoundation$Default#ensureRootTypeIdProvider\par
2.) PersistenceRoots$Default#setResolvedRoots\par
\tab - BinaryHandlerPersistenceRootsDefault#update\par
\tab\tab - 2) [implizit beim roots laden in der Initialisierung]\par
\par
Also vom Ablauf her eigentlich drei Aufrufstellen:\par
- Zur Setupzeit: Beim Roots zusammenstellen\par
- Zur Setupzeit:  Beim TypeId sicherstellen (eigentlich nur als Dummy, um die PersistenceRoots Implementierung Class dynamisch auslesen zu k\'f6nnen)\par
- Zur Initialisierungszeit: Beim Roots laden und synchen\par
\par
Ahja: \par
BinaryPersistenceRootsProvider$Default#provideRoots cacht die Instanz, d.h. sie wird nur einmal erzeugt, also auch nur ein Aufruf von Supplier#get.\par
Trotzdem bleibt nat\'fcrlich: Das ist zur Setupzeit und damit zu fr\'fch. (also doch!)\par
\par
Und eigentlich auch unn\'f6tig fr\'fch:\par
1b braucht eh nur irgendeine Instanz des PersistenceRoots Typs, da sind Root Instanzen gar nicht n\'f6tig.\par
1a soll eigentlich auch erst mal nur die Instanz produzieren, um sie weitergeben zu k\'f6nnen, ohne dass sie verwendet wird.\par
\par
Ausprobiert:\par
Mit leerer Datenbank: 1 Aufruf: 1a\par
Mit existierender Datenbank: 2 Aufrufe: 1a, 2\par
Also wie erwartet. Passt.\par
\par
Umgebaut m\'fcsste es werden zu:\par
- PersistenceRoots d\'fcrfte intern zun\'e4chst mal nur die map mit den persistenceEntries halten.\par
- Dann, beim ersten Abfragen der Roots, wird daraus erst die Map mit den tats\'e4chlichen root instanzen gebaut\par
Das entfernt auch automatisch die Aufrufe 1a und 1b: Dort wird dann zwar eine Instanz erzeugt, aber keine Root Instanz abgefragt, d.h. der supplier wird nie aufgerufen.\par
\par
Das (plus ausf\'fchrliche Kommentare) in Kombination mit der Spezialbehandlung f\'fcr den Anwendungs-Root\par
\par
\par
Und das notier ich mir hier, weil ich es jedes mal wieder nicht find!\par
PersistenceMetaIdentifiers#defineConstantSuppliers\par
\par
\par
2019-06-17\par
\par
Nochmal durchlesen. Ja, das passt so. Darauf \'e4nder ich das um.\par
\par
PersistenceRoots Implementierung und Erzeugung ge\'e4ndert.\par
Jetzt wird die Supplier Logik nur noch einmal aufgerufen und das erst beim Laden/Synchen. Nicht vorher.\par
\par
Hm... Benamungen verbessern und zumindest paar Methoden JavaDocen, damit ich deren Verwendungszweck nicht jedes mal neu recherchieren muss.\par
\par
So. Jetzt nochmal nachlesen, wie das mit dem Hintergrund bzw. der Ersatzbarkeit der Reference<> ist.\par
\par
\par
Ach JETZT wei\'df ich wieder, wieso das eine Reference<> ist:\par
Wenn man keinen expliziten Root angibt, w\'e4re es sinnlos, als defautl ein new Object() zu machen, weil man dem nix setzen kann.\par
Also muss es etwas sein, dem man was setzen kann und das einfachste Ding daf\'fcr ist eine XReference<Object>.\par
Wenn dann der R\'fcckgabetyp von EmbeddedStorageManager#root nur Object w\'e4re, m\'fcsste man jedes mal casten und zwar auf was, das von internem Code definiert wird.\par
Hei\'dft: Das w\'e4re SEHR "magic".\par
\par
Mir f\'e4llt keine einheitliche L\'f6sung daf\'fcr ein:\par
- Beliebiger expliziter root setzbar, ohne in eine verwirrende und potenziell fehleranf\'e4llige XReference<Object> gewrappt (und zur\'fcckgegeben) zu werden.\par
- Defaultroot muss zwangsweise eine XReference<Object> sein, die richtig typisiert zur\'fcckgegeben werden muss.\par
\par
Nur daf\'fcr den StorageManager typisieren w\'e4r bl\'f6d.\par
Man kann auch nicht einfach eine neue Root Instanz setzbar machen, denn dann m\'fcsste man mit jedem setzen die kompletten PersistenceRoots neu abspeichern.\par
Also das ginge zwar, aber das ist ja irgendwie eine d\'e4mliche L\'f6sung. Noch dazu, weil ein scheinbar transienter Vorgang (root setzen) dann zu einer Persistierung f\'fchren w\'fcrde.\par
So Tricksereien anfangen wie die OID gleich lassen und eine neue Instanz unter der alten OID abspeichern, fang ich nicht an, weil das die Konsistenzgarantie killt.\par
\par
Vielleicht ginge folgendes:\par
- Typisierung nach au\'dfen auf Object anstatt XReference\par
- Intern wird IMMER eine XReference gehalten. Die h\'e4lt entweder den expliziten Root oder man gettet/settet da defaultm\'e4\'dfig rein. Die default root instanz ist dann null, weil man ja setten kann.\par
- Die interne XReference ist das Ding, das immer dieselbe OID hat.\par
- storeroot speichert IMMER explizit die XReference (falls sie einen neuen referent hat) und immer auch ihren Referent, falls nicht bzw. falls die Referent instanz schon ID-m\'e4\'dfig bekannt ist und darum beim impliziten rekursieren geskippt werden w\'fcrde. Die redundant mitgespeicherten 32 Byte sind nicht der Rede wert. Und wie oft speichert man so einen root schon au\'dferhalb eines Tests?\par
\par
Das sollte beide Anforderungen abdecken...\par
Mal nochmal durchdenken...\par
\par
Ach, aber was ist, wenn man nur einen RootsResolver registriert...?\par
\par
Genau. Darum braucht schon der PersistenceRootResolver einen "main root" oder "application root" oder sowas. Und der wird dann an die PersistenceRoots weitergegeben.\par
Oh, und: Dann muss das auch beim Synchen der loaded/defined roots nachgezogen werden: Loaded Roots haben keinen "main root". Aber die defined Roots definieren einen. Die loadedRoots ist aber die ma\'dfgebliche Instanz, weil die auch wieder gespeichert wird. D.h. der muss vom definedRoots aus der main root gesetzt werden, falls vorhanden.\par
\par
Dann m\'fcsste aber eine Ver\'e4nderung des roots im EmbeddedStorageManager auch eine andere Instanz in der PersistenceRoots Instanz bewirken, d.h. man m\'fcsste den roots dort setzen.\par
Hm. Oder evtl. gleich nur dort?\par
\par
Oder moment mal: Die XReference ist dort ja schon von anfang an gesetzt. Und die \'e4ndert sich auch nicht mehr. Wenn sich ihr Inhalt \'e4ndert, dann ist das ja unabh\'e4ngig von der PersistenceRoots instanz bzw. gilt dort automatisch mit.\par
Funktionweise von Referenzen und so.\par
\par
So mach ich das.\par
\par
\par
2019-06-18\par
\par
Commit gestern vergessen. Nachholen.\par
\par
\par
\par
}
 