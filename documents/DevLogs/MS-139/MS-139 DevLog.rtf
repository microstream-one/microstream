{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-06-12\par
\par
\par
F\'fcr den Anfang mal genau zusammenschreiben, wie das intern technisch l\'e4uft.\par
\par
EmbeddedStorageFoundation#createEmbeddedStorageManager(Object explicitRoot)\par
erzeugt intern ein Reference<Object> root\par
Regeln:\par
1.) Falls explicitRoot != null\par
Falls es schon eine Reference ist, dann casten, als root setzen und zur\'fcckgeben.\par
Ansonsten wrappen mit Reference und als root setzen.\par
\par
Falls explicitRoot == null:\par
2.) Falls es einen gesetzten RootResolver gibt, dann null zur\'fcckgeben\par
\par
Falls explicitRoot == null UND RootResolver == null:\par
3.) Reference<Object> mit inhalt null erzeugen, als root setzen und zur\'fcckgeben.\par
\par
"als root setzen":\par
- von der ConnectionFoundation einen neuen PersistenceRootResolver erzeugen, der auf die Root Instanz verweist (\'fcber die Indirektion eines Suppliers)\par
- den als RootResolver in die ConnectionFoundation setzen\par
\par
Erzeugt eine neue EmbeddedStorageManager Instanz mit der definierten "root" Root-Referenz-Instanz (potenziell null).\par
Die Referenz vom EmbeddedStorageManager ist nur soetwas wie eine "convenience" Referenz f\'fcr die dortigen Zugriffsmethoden. Die eigentliche Verkn\'fcpfung (zum Laden/Initialisieren) findet \'fcber den RootResolver statt.\par
\par
\par
EmbeddedStorageManager#root:\par
Gibt trivial this.root zur\'fcck (potenziell null).\par
Typ "Reference<Object>"\par
\par
EmbeddedStorageManager#storeRoot:\par
Ruft EmbeddedStorageManager.root() auf.\par
Falls zur\'fcckgegebene Instanz null ist, wird 0 als ID zur\'fcckgegeben, ansonsten wird die Instanz gespeichert und ihre ID zur\'fcckgegeben.\par
\par
\par
Das hat mehrere Probleme:\par
- storeRoot() impliziert, dass die \'fcbergebene Root Instanz gespeichert wird. Das ist aber nicht der Fall.\par
- Je nachdem, ob man eine Reference oder etwas anderes \'fcbergibt, ver\'e4ndert sich das verhalten der beiden root-bezogenen Methoden. Implizit, ohne es nachvollziehen zu k\'f6nnen (schei\'df casten).\par
- Falls es einen RootResolver gibt, gibt #root trotzdem null zur\'fcck und #storeRoot tut gar nichts. Das ist nicht konsistent.\par
- Falls ein expliziter supplier registriert wird, k\'f6nnte der evtl. eine andere root instanz zur\'fcckliefern, als der EmbeddedStorageManager sich gemerkt hat.\par
\par
\par
Fragen:\par
Warum kann nicht ein Object direkt als root referenziert werden?\par
Eine Reference<Object> zur\'fcckzugeben bringt typisierungsm\'e4\'dfig keinen Vorteil und wenn man eine expliziten Rootinstanz registriert, hat man die Typisierung so oder so.\par
\par
\par
2019-06-13\par
\par
Warum muss nochmal ein Supplier dazwischengeschaltet werden?\par
Ich glaube, die Idee war damals dass die Instanz noch nicht zur Erzeugungszeit des RootResolvers existieren muss, sondern auch erst nachtr\'e4glich erzeugt werden kann.\par
Z.B. wenn man erst den Storage Stuff aufsetzt und konfiguriert und danach erst die Anwendungsebene-Rootinstanz, weil die evtl. von irgendwelchen Configs o.\'c4. abh\'e4ngt.\par
Allerdings muss man sich fragen:\par
- Kommt das so wirklich praktikabel vor?\par
- Wenn ja, ist es wirklich nicht workaroundbar, z.B. einfach durch eine eigene Instanz, die Indirektion macht.\par
- Ist das den potenziellen Fehler wert, dass ein registrierter selbstgebauter Supplier mal mittendrin eine andere Instanz zur\'fcckliefert?\par
\par
Wenn man nur das Registrierten eines selbstgebauten Suppliers verbietet, dann braucht man den gleich nicht, weil er dann einfach nur eine sinnlose Zwischeninstanz ist.\par
\par
Oder es m\'fcsste so gemacht werden, dass der Supplier nur ein einziges mal aufgerufen wird und was immer der zur\'fcckgibt, wird dann "fest" als Rootinstanz referenziert.\par
Hm, das steht so sogar schon in PersistenceRoots$Defalt#setResolvedRoots.\par
\par
Das Problem ist, dass es hier einen Konflikt gibt:\line Es gibt den RootResolver mit PersistenceRoots usw, der n Roots behandelt und aufl\'f6st (n\'e4mlich f\'fcr Konstanten auch noch). Dort, wo die aufgel\'f6st/gesammelt werden, soll jeder Supplier nur einmalig aufgerufen werden.\par
Dann kann er davor/danach aber nicht nochmal aufgerufen werden, um die Referenz auf die "Haupt"-Root-Instanz zu produzieren.\par
Der StorageManager m\'fcsste sich den Namen der "Haupt"-Root Instanz merken und sich diese aus der Map mit den aufgel\'f6sten rausholen. Dann ginge es.\par
\par
Weiter recherchieren:\par
PersistenceRoots wird erzeugt (und damit die konkreten Root Instanzen aufgel\'f6st) in EmbeddedStorageFoundation#createEmbeddedStorageManager\par
Also VOR der Erzeugung des EmbeddedStorageManager.\par
\par
Aber Problem:\par
Zu diesem Zeitpunkt gibt es den Root Identifier nicht mehr.\par
Falls es nicht der Default ist, wurde der gewrappt in einem custom RootResolver.\par
Und der macht nichts anderes, als den Root unter dem Identifier als einen von vielen zu registrieren.\par
\par
Nun k\'f6nnte man nat\'fcrlich sagen:\par
Das explizite Roothandling funktioniert halt dann nur, wenn man auch eine explizite Instanz \'fcbergeben hat.\par
Das w\'e4re aber unvollst\'e4ndig und logisch falsch, denn:\par
Einen eigenen Root Supplier und/oder eigenen Identifier usw. \'fcbergeben, ist eigentlich nur eine API-Variante, die nicht zu anderem bzw. auf einmal ausbleibendem Verhalten f\'fchren sollte.\par
Z.B. das storeRoot w\'fcrde in diesem Fall gar nichts mehr machen. Das kann irgendwie nicht sein.\par
\par
Viel besser ist:\par
Der RootResolver muss eben das Feature, eine "Haupt-" oder "bevorzugte" Instanz zu haben, auch in seiner API reflektieren.\par
\par
Als ersten Schritt ersetz ich mal den BiFunction<String, Supplier<?>, PersistenceRootEntry> durch einen gescheiten PersistenceRootEntry.Provider.\par
Die \'c4nderung war trivial. Weiter im Text.\par
\par
\par
2019-06-14\par
\par
Dabei Problem aufgefallen:\par
PersistenceRootResolver$Builder$Default#registerRoot ruft auch nochmal den supplier auf und das zum Storage-Setup-Zeitpunkt, was den Supplier Ansatz de Facto \'fcberfl\'fcssig macht.\line Das muss ge\'e4ndert werden.\par
\par
\par
Ne Moment:\par
Der Supplier wird nur zusammen mit seinem Identifier in einen Entry gepackt, aber NICHT aufgerufen. Also genau so soll es sein. Passt.\par
War ich gestern schon so ersch\'f6pft von der W\'e4rme? :-D\par
\par
\par
Achja, der Supplier ist n\'f6tig, um Konstanten "dynamisch genug" (bzw. sp\'e4t genug) aufl\'f6sen zu k\'f6nnen.\par
Wichtig!\par
\par
\par
Also es gibt zwei Stellen, wo PersistenceRootEntry#instance, d.h. das .get() vom Supplier, aufgerufen wird:\par
1.) PersistenceRootResolver$Default#getRootInstances\par
\tab - BinaryPersistenceRootsProvider$Default#provideRoots\par
\tab\tab - 1a) EmbeddedStorageFoundation$Default#createEmbeddedStorageManager\par
\tab\tab - 1b) EmbeddedStorageFoundation$Default#ensureRootTypeIdProvider\par
2.) PersistenceRoots$Default#setResolvedRoots\par
\tab - BinaryHandlerPersistenceRootsDefault#update\par
\tab\tab - 2) [implizit beim roots laden in der Initialisierung]\par
\par
Also vom Ablauf her eigentlich drei Aufrufstellen:\par
- Zur Setupzeit: Beim Roots zusammenstellen\par
- Zur Setupzeit:  Beim TypeId sicherstellen (eigentlich nur als Dummy, um die PersistenceRoots Implementierung Class dynamisch auslesen zu k\'f6nnen)\par
- Zur Initialisierungszeit: Beim Roots laden und synchen\par
\par
Ahja: \par
BinaryPersistenceRootsProvider$Default#provideRoots cacht die Instanz, d.h. sie wird nur einmal erzeugt, also auch nur ein Aufruf von Supplier#get.\par
Trotzdem bleibt nat\'fcrlich: Das ist zur Setupzeit und damit zu fr\'fch. (also doch!)\par
\par
Und eigentlich auch unn\'f6tig fr\'fch:\par
1b braucht eh nur irgendeine Instanz des PersistenceRoots Typs, da sind Root Instanzen gar nicht n\'f6tig.\par
1a soll eigentlich auch erst mal nur die Instanz produzieren, um sie weitergeben zu k\'f6nnen, ohne dass sie verwendet wird.\par
\par
Ausprobiert:\par
Mit leerer Datenbank: 1 Aufruf: 1a\par
Mit existierender Datenbank: 2 Aufrufe: 1a, 2\par
Also wie erwartet. Passt.\par
\par
Umgebaut m\'fcsste es werden zu:\par
- PersistenceRoots d\'fcrfte intern zun\'e4chst mal nur die map mit den persistenceEntries halten.\par
- Dann, beim ersten Abfragen der Roots, wird daraus erst die Map mit den tats\'e4chlichen root instanzen gebaut\par
Das entfernt auch automatisch die Aufrufe 1a und 1b: Dort wird dann zwar eine Instanz erzeugt, aber keine Root Instanz abgefragt, d.h. der supplier wird nie aufgerufen.\par
\par
Das (plus ausf\'fchrliche Kommentare) in Kombination mit der Spezialbehandlung f\'fcr den Anwendungs-Root\par
\par
\par
Und das notier ich mir hier, weil ich es jedes mal wieder nicht find!\par
PersistenceMetaIdentifiers#defineConstantSuppliers\par
\par
\par
2019-06-17\par
\par
Nochmal durchlesen. Ja, das passt so. Darauf \'e4nder ich das um.\par
\par
PersistenceRoots Implementierung und Erzeugung ge\'e4ndert.\par
Jetzt wird die Supplier Logik nur noch einmal aufgerufen und das erst beim Laden/Synchen. Nicht vorher.\par
\par
Hm... Benamungen verbessern und zumindest paar Methoden JavaDocen, damit ich deren Verwendungszweck nicht jedes mal neu recherchieren muss.\par
\par
So. Jetzt nochmal nachlesen, wie das mit dem Hintergrund bzw. der Ersatzbarkeit der Reference<> ist.\par
\par
\par
Ach JETZT wei\'df ich wieder, wieso das eine Reference<> ist:\par
Wenn man keinen expliziten Root angibt, w\'e4re es sinnlos, als defautl ein new Object() zu machen, weil man dem nix setzen kann.\par
Also muss es etwas sein, dem man was setzen kann und das einfachste Ding daf\'fcr ist eine Reference<Object>.\par
Wenn dann der R\'fcckgabetyp von EmbeddedStorageManager#root nur Object w\'e4re, m\'fcsste man jedes mal casten und zwar auf was, das von internem Code definiert wird.\par
Hei\'dft: Das w\'e4re SEHR "magic".\par
\par
Mir f\'e4llt keine einheitliche L\'f6sung daf\'fcr ein:\par
- Beliebiger expliziter root setzbar, ohne in eine verwirrende und potenziell fehleranf\'e4llige Reference<Object> gewrappt (und zur\'fcckgegeben) zu werden.\par
- Defaultroot muss zwangsweise eine Reference<Object> sein, die richtig typisiert zur\'fcckgegeben werden muss.\par
\par
Nur daf\'fcr den StorageManager typisieren w\'e4r bl\'f6d.\par
Man kann auch nicht einfach eine neue Root Instanz setzbar machen, denn dann m\'fcsste man mit jedem setzen die kompletten PersistenceRoots neu abspeichern.\par
Also das ginge zwar, aber das ist ja irgendwie eine d\'e4mliche L\'f6sung. Noch dazu, weil ein scheinbar transienter Vorgang (root setzen) dann zu einer Persistierung f\'fchren w\'fcrde.\par
So Tricksereien anfangen wie die OID gleich lassen und eine neue Instanz unter der alten OID abspeichern, fang ich nicht an, weil das die Konsistenzgarantie killt.\par
\par
Vielleicht ginge folgendes:\par
- Typisierung nach au\'dfen auf Object anstatt Reference\par
- Intern wird IMMER eine Reference gehalten. Die h\'e4lt entweder den expliziten Root oder man gettet/settet da defaultm\'e4\'dfig rein. Die default root instanz ist dann null, weil man ja setten kann.\par
- Die interne Reference ist das Ding, das immer dieselbe OID hat.\par
- storeroot speichert IMMER explizit die Reference (falls sie einen neuen referent hat) und immer auch ihren Referent, falls nicht bzw. falls die Referent instanz schon ID-m\'e4\'dfig bekannt ist und darum beim impliziten rekursieren geskippt werden w\'fcrde. Die redundant mitgespeicherten 32 Byte sind nicht der Rede wert. Und wie oft speichert man so einen root schon au\'dferhalb eines Tests?\par
\par
Das sollte beide Anforderungen abdecken...\par
Mal nochmal durchdenken...\par
\par
Ach, aber was ist, wenn man nur einen RootsResolver registriert...?\par
\par
Genau. Darum braucht schon der PersistenceRootResolver einen "main root" oder "application root" oder sowas. Und der wird dann an die PersistenceRoots weitergegeben.\par
Oh, und: Dann muss das auch beim Synchen der loaded/defined roots nachgezogen werden: Loaded Roots haben keinen "main root". Aber die defined Roots definieren einen. Die loadedRoots ist aber die ma\'dfgebliche Instanz, weil die auch wieder gespeichert wird. D.h. der muss vom definedRoots aus der main root gesetzt werden, falls vorhanden.\par
\par
Dann m\'fcsste aber eine Ver\'e4nderung des roots im EmbeddedStorageManager auch eine andere Instanz in der PersistenceRoots Instanz bewirken, d.h. man m\'fcsste den roots dort setzen.\par
Hm. Oder evtl. gleich nur dort?\par
\par
Oder moment mal: Die Reference ist dort ja schon von anfang an gesetzt. Und die \'e4ndert sich auch nicht mehr. Wenn sich ihr Inhalt \'e4ndert, dann ist das ja unabh\'e4ngig von der PersistenceRoots instanz bzw. gilt dort automatisch mit.\par
Funktionweise von Referenzen und so.\par
\par
So mach ich das.\par
\par
\par
2019-06-18\par
\par
Commit gestern vergessen. Nachholen.\par
\par
Jetzt die mainRoot Logik einbauen.\par
Auch in Builder.\par
\par
Jetzt die RootResolver und RootResolverBuilder Methoden in Persistence anpassen.\par
Das wird jetzt knifflig: Wie kann man den default Identifier String "root" m\'f6glichst nur einmal vorkommen lassen?\par
\par
Hm, Moment mal:\par
Was genau steckt f\'fcr den main root nun in der resolvedRoots hashtable drin?\par
Das muss ja dann eigentlich der wrappende Singleton sein, damit OID usw. zusammenpassen.\par
Dann m\'fcsste das aber gespecial-caset beim roots resolven eingebaut werden, sonst steckt der loop die root instanz selbst dort rein...\par
Hm, oder der mainRoot br\'e4uchte eine spezielle Art RootEntry, der die Aufl\'f6sung anders macht.\par
\par
Oder die Aufl\'f6sung l\'e4uft einfach normal durch und am Ende wird die Root Instanz durch den Singleton gewrappt und der ersetzt dann den eigentlichen Eintrag.\par
Das w\'e4re eine ganz elegante L\'f6sung, glaub ich.\par
\par
Aber ein Problem f\'e4llt mir bei meinem Reference-L\'f6sungskonzept gerade noch auf:\par
Die Roots werden ja gesyncht. Es wird aber nur die Identit\'e4t gesyncht, nicht irgendwie "deep" mit den Daten.\par
Das hei\'dft:\par
- Man definiert eine Main Root Instanz, die in einer Reference (also einem Singleton) gewrappt wird.\par
- Durch den RootResolver und dem Main Root Namen wird dieser Instanz die Main Root OID zugewiesen.\par
- Die Initialisierung l\'e4dt die Roots, d.h. was immer in der Datenbank f\'fcr den main root singleton als Referent definiert ist, ersetz das Ding, das von der Anwendungslogik gesetzt wurde.\par
- Der Synch sagt der main root Singleton ist konsistent zur Datenbank (obviously), also passt alles.\par
Aber es passt nicht, sondern die eigentliche main root der Anwendung wird nicht mehr als Root referenziert. Die Instanz ist keine Root mehr.\par
\par
Vielleicht m\'fcsste dann einfach nur EmbeddedStorageManager#synchronizeRoots auch eine Sonderfallbehandlung machen: schauen, ob sich der Referent ge\'e4ndert hat.\par
Aber hm, moment mal: wenn der Referent der Reference kein Root mehr ist, wie wird dann die anwendungsdefinierte Instanz der OID in der Datenbank zugeordnet?\par
\par
W\'e4re es evtl. eine L\'f6sung, intern beide Instanzen als Root zu registrieren?\par
Die Reference/Singleton, damit der EmbeddeStorageManager seinen Ankn\'fcpftpunkt hat und die eigentliche Root, damit man eben die Instanz ordentlich verbunden kriegt ...\par
\par
\par
Irgendwie zieht das immer weitere Kreise und ich werd zunehmend verwirrt:\par
Wenn es nur ein Mapping '1000000007 <-> "root"' gibt, hei\'dft das ja: "Welche Instanz auch immer durch den Namen 'root' aufgel\'f6st wird, die wird f\'fcr die OID registriert."\par
Aber was ist, wenn man in der Anwendung die root Instanz \'e4ndert von z.B. einer blanken HashTable auf eine Instanz der Klasse "MyAppRoot", die intern eine HashTable mit gleicher Funktion h\'e4lt?\par
Dann hat die MyAppRoot Instanz auf einmal die OID einer HashTable und falls diese HashTable irgendwo anders referenziert wird (also eine R\'fcckreferenz auf die Root. Unwahrscheinlich aber nicht abwegig), dann bekommen Instanzen, die auf die HashTable zeigen, beim Laden auf einmal eine MyAppRoot Instanz gesetzt. Und zwar ohne irgendeinen type check durch die JVM, weil ja Unsafe verwendet wird.\par
Gilt nat\'fcrlich genauso f\'fcr alle anderen Roots, also Konstantenreferenzen auf Instanzen.\par
Hm...\par
Gut, man kann nat\'fcrlich sagen: Daf\'fcr gibts das Refactoring Mapping.\par
Wobei das ja nur die Refrenz umbiegen kann auf eine Instanz, die dann aufbaum\'e4\'dfig wieder passt. Aber was ist, wenn man ausdr\'fccklich eine andere Instanz mit anderem Aufbau haben will?\par
\par
Vielleicht w\'e4re der persistierte Doppelroot da sogar die L\'f6sung:\par
Die interne Reference bleibt OID- und Typm\'e4\'dfig immer gleich. Das ist verl\'e4sslich, das ist schon mal super.\par
Die eigentliche Root Instanz (mit irgendwie einem generierten identifier) kann beim roots resolven mal nicht mehr gefunden werden, dann wird einfach nicht resolvet und durch die aus den definedRoots ersetzt (ist jetzt auch schon so).\par
\par
Das Problem ist: welcher identifier soll generiert werden, der dann eine fachliche \'c4nderung erkennbar macht? Den full qualified Type name reingenerieren w\'e4re eine M\'f6glichkeit, aber dann stehen wieder Metadaten als Nutzdaten im Code und beim ersten Refactoring gibts wieder Probleme. Das ist nix.\par
\par
Das kann doch alles nicht so schwierig sein. Zumal auch jetzt schon Instanzen einfach mit einer Reference gewrappt werden.\par
Nochmal nachlesen, wie das aktuell mit dem Wrappen l\'e4uft ...\par
\par
Eine explizite Root Instanz wird mit einer Reference gewrappt und die wird dann gespeichert.\par
Moment mal: wie kann die dann \'fcberhaupt aktualisiert werden anstatt einfach durch eine generische ersetzt zu werden?\par
\par
Ach, das funktioniert dadurch, dass es gar keine explizite Root Instanz gibt, sondern nur eine Reference, die auf den passenden Typ typisiert ist.\par
D.h. die generisch erzeugte wird da reingesetzt, man ruft .get() auf und es passt alles.\par
Hm.\par
Das ist eigentlich dann doch recht elegant.\par
\par
Hab ich jetzt da tagelang umsonst rumrecherchiert und rumgeplant?\par
Eigentlich k\'f6nnte man wirklich einfach bei storeRoot einen doppel-store machen und fertig.\par
\par
Allerdings:\par
- Was war nochmal das potenziell gef\'e4hrliche?\par
- Es ist halt gerade f\'fcr den Einstieg ein bisschen schwer zu erkl\'e4ren, warum da eine Reference zur\'fcckgegeben wird.\par
Vielleicht kann man es trotzdem so machen, dass die Reference nur intern gehandelt wird mit der Logik wie bisher, es sei denn, man setzt explizit eine, dann hat man seine Typisierung.\par
\par
Das muss ich morgen mal checken.\par
\par
\par
2019-06-19\par
\par
Aber Moment mal: das mit der Reference, die den generisch geladenen Root reingeneriert wird, mag schon elegant sein, aber man \'fcbergibt ja auf verschiedenen Wegen eine konkrete Root Instanz.\par
Es wird aber nicht diese Instanz aus der Datenbank aktualisiert, sondern es wird eine neu generierte in die Reference gesetzt.\par
Das ist zwar nicht direkt eine Fehler, aber ein unerwartetes Verhalten und wenn man es nicht ber\'fccksichtigt, entsteht ein Fehler.\par
Das muss ich mal testen.\par
\par
Jup. Der wird momentan einfach ersetzt durch die geladene Instanz gleichen Typs.\par
Also stimmen die \'dcberlegungen von oben \'fcber die konflikteten Anforderungen schon und es ist bist einfach falsch gebaut.\par
Hmpfl.\par
Also wieder alles durchdenken.\par
Es muss doch m\'f6glich sein, eine Instanz zu \'fcbergeben und die dann aus der Datenbank als root updaten zu lassen.\par
\par
Vielleicht muss es statt einer generischen Reference (bzw. Singleton) eine spezifische StorageRoot Klasse sein und der Handler daf\'fcr special-handlet dann auch den Referenten.\par
\par
Oder es w\'e4re eine m\'f6glichkeiten, den main root per identifier zu registrieren, aber in dem die TypeId enthalten ist. Denn die \'e4ndert sich nicht und entspricht zwangsweise immer genau dem konkreten Datensatz, der abgespeichert wurde.\par
Die ist unabh\'e4ngig von Typnamenged\'f6ns.\par
\par
Dann m\'fcsste aber die TypeId von Anfang an, vom Registrieren des Roots an, feststehen.\par
Mit bissl trickserei sp\'e4testens beim Roots resolven.\par
Mal schauen ...\par
\par
Also der EmbeddedStorageManager h\'e4tte f\'fcr seine #synchronizeRoots schon mal eine singletonConnection zur Verf\'fcgung.\par
Die kennt den persistencemanager und der kennt den TypeHandlerManager.\par
Man kann zwar nicht direkt darauf zugreifen, aber das lie\'dfe sich \'e4ndern oder es reicht evtl. auch, einen Registerer zu erzeugen und den dann die main root Instanz anschn\'fcffeln zu lassen, damit er eine TypeId sicherstellt.\par
Oder es ist sowieso keine schlechte Idee, den PersistenceManager etwas zu \'f6ffnen und Zugriff auf den TypeHandlerManager zu erlauben, falls man jemand aus anderen Gr\'fcnden einen TypeHandler braucht. Eben f\'fcr die TypeId oder um an den registrierten selbstgebauten TypeHandler wieder ranzukommen.\par
Wobei es da eigentlich schon zu sp\'e4t ist, weil die loadedRoots da schon feststehen. Also in den aufrufenden Kontext schauen.\par
Ne, Moment mal: wenn schon was geladen wird, dann gibt es den Eintrag mit seiner TypeId ja eh schon. Die Frage ist ja, wenn zum ersten mal gespeichert wird bzw. wenn ein main Root eines neuen Typs dazukommt, wo kommt dann die TypeId her?\par
Das konkrete Aufl\'f6sen zu dem String->Instanz Mapping findet ja im RootResolver selber statt. Entweder muss der Zugriff auf den TypeHandler haben oder der entries() Aufruf muss um einen Zugang zum TypeHandlerManager erweitert werden.\par
Technisch w\'fcrde das so klappen.\par
Die Frage ist, ob es "sch\'f6n" ist, oder ob es nicht einfachere (auch zuk\'fcnftig wieder einfacher zu verstehende / einzulesende) Wege gibt ...\par
\par
Hmpfl...\par
\par
Wie w\'e4re denn folgende Idee:\par
Scheiss auf das Reference-Wrapping.\par
Root Instanzen werden immer direkt registriert. Unter dem Identifier "root" bzw. einem selbst definierten.\par
Dann darf die Methode root() nicht mehr Reference zur\'fcckgeben sondern entweder Object oder es gibt sie sogar gar nicht mehr\par
\par
Davon gibt es zwei Varianten:\par
\par
1.) Explizit \'fcbergebene Instanz.\par
Die ist dann direkt der root, wird vom Ladevorgang aktualisiert, alles super. Fertig.\par
root(), falls es sie noch gibt, gibt das Ding dann zur\'fcck, aber halt typisiert auf Object. Mei.\par
Wer nicht casten will, soll sich seine Instanz richtig typisiert im Kontext der Anwendung merken. Fertig.\par
Oder einen hauchd\'fcnnen Wrapper extenden, der diese eine Methode h\'fcbsch castet.\par
Das w\'e4re dann auch ein Argument daf\'fcr, die root() zu lassen.\par
\par
2.) Keine explizit \'fcbergebene Instanz.\par
Dann wird behelfsm\'e4\'dfig eine Reference (Singleton) Instanz erzeugt mit Referent null.\par
Dann gibt die Methode root() nat\'fcrlich auch die Reference zur\'fcck, nur halt typisiert als Object.\par
Um das ganze ein bisschen weniger "magic" und einsteigerfreundlicher zu machen, gibt es eine defaultRoot() Methode, die Reference<Object> zur\'fcckgibt.\par
Die Frage w\'e4r nur noch: wann wei\'df ein EmbeddedStorageManager nach dem Laden, ob eine root Instanz default ist oder nicht?\par
"instanceof Reference" w\'e4r bl\'f6d, denn falls ein selbstgebauter Root das Interface mal implementieren sollte, w\'fcrde der auf einmal zur\'fcckgegeben. Ist zwar nicht falsch und harmlos, aber bissl wirr.\par
Vielleicht k\'f6nnte f\'fcr diesen Fall der Identifier von "root" auf "defaultRoot" ge\'e4ndert werden und darauf gepr\'fcft werden.\par
\par
Die Frage ist, was dann passiert, wenn sich der root mal \'e4ndern soll.\par
Gut, man k\'f6nnte sagen: gleicher Root Identifier bedeutet es muss derselbe Typ der Root Instanz sein.\par
Wer den \'e4ndern will, soll halt einen anderen Identifier verwenden ("root2"), dann wird beim roots synchen der alte durch den neuen ersetzt.\par
Wenn der "root" dann frei ist, k\'f6nnte man den ja wieder umschreiben.\par
Evtl. muss es da mal noch ein bisschen support-callbacks geben (oldRoot, newRoot).\par
\par
Ne, moment mal: es muss beim laden \'fcberhauptnicht festgestellt werden, ob es sich um einen default root handelt oder nicht. Denn es wird ja bei jedem start eine neue Instanz erzeugt und dann dynamisch mit den zu ladenden Daten verbandelt.\par
Gut, aber was ist, wenn mal von defaultRoot auf nicht-default root gewechselt wird? Vielleicht sollte es daf\'fcr einen eigenen Identifier geben.\par
\par
Und, leider wieder mal das l\'e4stige Thema: Was ist mit der Migration bestehender Datenbanken?\par
Aktuell gibt es Datenbanken, die den default identifier "root" benutzen und darin ihr root ged\'f6ns haben.\par
\par
Es m\'fcsste aber relativ sicher sein, dass bisher gilt:\par
"root" = Reference<Object>\par
\par
Dann lass ich das und mach f\'fcr die custom roots den Identifier "customRoot".\par
\par
Und die beiden kommen dann aber in PersistenceRoots rein und nicht wieder lose/parallel in den EmbeddedStorageManager.\par
\par
\par
\par
2019-06-20\par
\par
Feiertag\par
\par
\par
2019-06-21\par
\par
Implementierung fortsetzen.\par
\par
\par
Wenn das alles \'fcber PersistenceRoots laufen soll, muss aber EmbeddedStorageFoundation#createEmbeddedStorageManager bzw. das setzen des Roots ein bisschen anders laufen. Das muss schon in den PersistenceRootResolver bzw. in den Builder daf\'fcr rein.\par
\par
Hmm... an welcher Stelle wird dann letztendlich entschieden und sichergestellt, dass es einen defaultRoot anstatt einer customRoot gibt und mit welchem Identifier? Das muss ja eigentlich im RootResolver.Builder passieren.\par
Aber dann h\'e4tte der spezifische Defaultlogik, was bl\'f6d ist.\par
Oder l\'e4sst man den einfach "blank", weil es evtl. ja mal gew\'fcnscht ist, gar keinen root zu haben? Beispiel: der eigentliche Root ist eine Konstante und das ganze Root ged\'f6ns wird gar nicht verwendet.\par
Ich glaub, so ist es am geschicktesten ...\par
\par
Eigentlich ist es ein Quatscht, dass PersistenceRoots eine interne Methode hat, roots zu resolven, wenn es extra einen RootsResolver gibt, der f\'fcr die Erstellung der PersistenceRoots "ausgeschlachtet" antatt \'fcbergeben wird.\par
Anstatt diese seltsame Konstruktion mit resolvableRoots und resolvedRoots in PersistenceRoots zu machen, k\'f6nnte die Instanz gleich nur den RootsResolver kennen und DER macht on demand die Aufl\'f6serei.\par
Dann w\'fcrde er sogar genau das machen, wie er benannt ist - unglaublich!\par
\par
So umbauen ...\par
\par
Hehe, witzig:\par
Einerseits hab ich den Grund gefunden, warum das nicht schon gemacht worden ist:\par
PersistenceRoots ist ja ein persistierbares Ding, das keine Referenz zu einem Laufzeit"bauteil" wie dem RootResolver haben soll/darf.\par
Andererseis gibts daf\'fcr eh schon einen custom handler und der hat eh schon - \'dcberraschung -  die RootResolver Instanz, weil er ja dessen Logik braucht.\par
Dann kann der die auch gleich wieder transient dazuweben und fertig.\par
Also passt so.\par
Ah, dann f\'e4llt sogar das "createUninitialized()" weg, weil das umgestaltet werden m\'fcsste zu dem gleichen, was schon der public pseudo-Konstruktor ist.\par
Wenn sich solche Vereinfachungen automatisch ergeben, ist das immer ein gutes Zeichen, dass Struktur verbessert worden ist.\par
\par
Aber das #setResolvableRoots k\'f6nnte bissl knifflig werden.\par
Man k\'f6nnte es zwar einfach durch #replaceEntries ersetzen, aber dann geht die "hasChanged" Evaluierung verloren. Als Logik des PersistenceRoots kann das resolven halt zwei Ergebnisse haben. Als rausgekapselte Methode wo anders nur einen. Oder man m\'fcsste einen Callback machen oder einen extra R\'fcckgabetyp. W\'e4r auch kein Beinbruch. Jetzt schau ich aber erst mal, wo das hasChanged wirklich mal relevant ist.\par
\par
Also man kann nat\'fcrlich einfach so machen:\par
- RootResolver die Identifier \'fcbergeben\par
- Dazu die bisherigen resolved Roots\par
- der macht intern die Aufl\'f6sung und den Abgleich\par
- Und dann gibt er einen Ergebnistyp zur\'fcck mit dem array und dem hasChanged flag. Und der Vollst\'e4ndigkeit halber auch noch den bisherigen ResolvedRoots als Referenz.\par
\par
Oder eigentlich noch einfacher:\par
Identifier Array rein, instances Array raus.\par
Danach dr\'fcber schleifen, ob das array eine null enth\'e4lt (was der aktuelle Algorithmus auch macht).\par
Wenn ja, dann changed, ansonsten nein.\par
Dann alle non-null eintr\'e4ge in eine HashTable packen und die in die Roots setzen.\par
Bzw. das kann intern passieren, damit der sich sein hasChanged selber in Ruhe und sicher berechnet anstatt von au\'dfen gesetzt zu bekommen.\par
\par
Dann bau ich das Array ged\'f6ns gleich noch auf eine collection um. Die Performance ist wirklich komplett irrelevant bei dem dutzend oder so root Eintr\'e4gen.\par
\par
Seltsam: das bisherige resolveRootInstances l\'f6st zu resolvable Entries auf und wirft exceptions bei nulls.\par
Sp\'e4ter werden die zu konkreten root instanzen aufgel\'f6st, dann bedeuten nulls nur eine \'c4nderung.\par
Also es gibt da schon einen logischen Unterschied (n\'e4mlich "gibt es \'fcberhaupt einen entry?"), aber ist der in der praxis wirklich relevant?\par
Was bedeutet es denn, wenn ein identifier nicht zu einem eintrag aufgefl\'f6st werden kann?\par
Achso, hm, im Code f\'fcrs konkrete aufl\'f6sen steht "explicitely removed entry". Also ist es durchaus ein relevanter Unterschied.\par
\par
Dann mach ich es so:\par
Zwei Schritte:\line - resolveEntries (darf kein null ergeben)\par
- resolveRoots (darf null ergeben). Kann eigentlich eine statische Methode sein. Oder ich machs mal ins interface mit statischer Umleitung, um es modular ersetzen zu k\'f6nnen.\par
\par
Jetzt w\'e4r das soweit umgebaut. Jetzt ist nur noch die Frage wo wann wie ich customRoot und defaultRoot setz.\par
\par
Nat\'fcrlich in EmbeddedStorageFoundation#createEmbeddedStorageManager.\par
\par
Aber da gibts jetzt ein Problem:\par
Dort wird ein expliziter Root \'fcbergeben. Anhand dessen kann entschieden werden, ob custom oder default root verwendet werden soll.\par
Setzen kann man den aber nur bei einem RootResolver.Builder. Den gibts hier aber nicht und einen erzeugen und in die ConnectionFoundation setzen w\'fcrde einen vorher gesetzten custom RootResolver ersetzen. Bl\'f6d.\par
Entweder muss ich dann den RootResolver selbst eine API zum setzen geben und damit mutable machen (doof) oder die ConnectionFoundation darf nur einen RootResolver.Builder halten, aus dem dann erst der RootResolver erzeugt wird.\par
Was aber irgendwie auch doof ist. Was ist, wenn man selber einen schreiben und setzen will?\par
Der Punkt ist wohl:\par
Die M\'f6glichkeit f\'fcr einen eigenen RootResolver und die M\'f6glichkeit, einen eigenen Root an bequemer Stelle definieren zu k\'f6nnen, erzeugen einen Konflikt.\par
\par
Da muss ich mal \'fcberlegen, wie ich das l\'f6s. Das w\'e4r dann der letzte Aspekt, damit das Feature fertig ist.\par
\par
\cf1 Achja und:\par
evtl. sollten die root~() Methoden im EmbeddedStorageManager doch ein shortcut f\'fcr defaultRoot().get() sein.\par
\cf0\par
\par
2019-06-24\par
\par
Eigentlich k\'f6nnte die L\'f6sung einfach folgendes sein:\par
- Die ConnectionFoundation h\'e4lt sich neben dem RootResolver auch einen Builder daf\'fcr.\par
- Wenn explicitRoot null ist und es noch keinen RootResolver gibt, dann wird dem Builder ein DefaultRoot gesetzt.\par
- Wenn explicitRoot null ist und es noch einen RootResolver gibt, dann wird der verwendet.\par
- Wenn explicitRoot nicht null ist und es noch keinen RootResolver gibt, dann wird dem Builder ein CustomRoot gesetzt.\par
- Wenn explicitRoot nicht null ist und es schon einen RootResolver gibt, dann wird ein Fehler geworfen mit dem Hinweis auf konfliktetes Roothandling.\par
\par
\par
Kurzer Einschub zu Produktivit\'e4t:\par
Jetzt sitzen nicht nur 3 Mann im winzigen 2-Mann-B\'fcro, sondern seit die Klimaanlage nicht mehr mir im R\'fccken steht, wo ich sie ausmachen "darf", sondern bei Felix, l\'e4uft die jetzt anscheinend durch.\par
Erstens ist das zu kalt (24.5\'b0. Daf\'fcr, dass ich nur ein kurzes Hemd ohne Unterhemd dran hab, ist das zu kalt. Mich friert.) und zweitens surrt es hier jetzt wie in einem Serverraum.\par
Zum einen versteh ich die Leute nicht: das dreiviertelte Jahr lang wird gejammert wie kleine Kinder, dass es nicht Sommer ist und dann, kaum wirds mal Sommer und die Temperaturen klettern \'fcber 22\'b0, schon wird gejammert und gek\'fchlt auf Teufel komm raus, als m\'fcsste man die Sahara vereisen. Hallo? Normale, warme, gute Temperaturen f\'fcr wenig Bekleidung gehen bei 25\'b0 los. Ab 28\'b0 wirds dann langsam m\'fchsam und ab 30\'b0 ist es zu warm, um produktiv zu arbeiten. Aber bis 28-30\'b0 kann man doch um Himmels Willen den sonst so herbeigejammerten Sommer Sommer sein lassen bzw. genie\'dfen und muss nicht gleich Serverraum\'e4hnliche K\'fchlungen anwerfen.\par
Und zum anderen ist es einfach so: Wir sollen hier hochkomplexe geistige T\'e4tigkeiten ausf\'fchren und das m\'f6glichst fehlerfrei und trotzdem m\'f6glichst schnell. Und dann wird eine Ger\'e4uschkulisse wie eine Mischung aus einem Gro\'dfraumb\'fcro und einem Serverraum aufgebaut. Was soll das? Wei wenig konzentriert/leistungsf\'e4hig m\'fcssen Leute denn arbeiten, dass sie so eine Ger\'e4uschkulisse nicht st\'f6rt? Ich vergleich das mit der Kontentration immer gern mit folgendem Beispiel: Ein Traktor ist super unempfindlich gegen Bodenunebenheiten, aber f\'e4hrt halt nur so seine 60 km/h. Formel-1-Autos fahren 300 km/h, daf\'fcr kann jede Bodenwelle fatal enden. Ich wei\'df schon: Vorgesetzte wollen nat\'fcrlich Traktoren (unempfindliche Mitarbeiter), die m\'f6glichst 1000 km/h fahren, aber das geht halt nicht. Wir sollen super geistige Leistungen vollbringen (nicht nur quantitativ, auch qualitativ), d.h. eine m\'f6glichst hohe Leistung (Geschwindigkeit in der Metapher) ist ein MUSS. Dann geht halt auch die Empfindlichkeit gegen\'fcber St\'f6rungen hoch. Wenn alles auf Geschwindigkeit optimiert ist, leidet die St\'f6rungstoleranz. Ich soll in der Entwicklung m\'f6glichst 1000 km/h fahren und drunter wird das Gesicht verzogen, aber dann kommen Kasperler daher und stellen zur besten Sommerzeit unn\'f6tig Gr\'e4ben und Steine auf die Stra\'dfe. Hei\'dft: Produktivit\'e4t geht runter. Nicht nur durch Texte wie diesen hier, sondern auch durch permanentes Genervtsein, Abgelenktsein, usw.\par
F\'fcr diese Woche nehm ich das mal hin, da rentiert es sich nicht, zu eskalieren. Wie es ab n\'e4chste Woche mit anderer Sitzordnung sein wird, wird sich dann zeigen.\par
Ich wollt nur mal den Produktivit\'e4tsverlust aufgrund von st\'f6rendem Irrsinn zu Protokoll geben.\par
\par
\par
Weiter im Text:\par
Dann muss auch die Logik, wie aktuell ein RootResolver in der Foundation erzeugt wird, angepasst werden.\par
Mal machen ...\par
\par
Hm. Die Bezeichnungen sind doch verwirrend:\par
Jeder vom user registrierte root ist ein "custom root". Was das "custom root" ja eigentlich aussagen soll ist, dass das ein spezieller "main root" ist, der an entsprechender Stelle in der API prominent mitgegeben bzw. definiert erden kann.\par
Also benenn ich das doch um auf "default root" und "main root".\par
\par
Aber das mit den verstreuten root identifiern passt mir nicht. Mal \'fcberlegen.\par
Ach ja: ich mach in den Builder \'fcberladene Varianten als defaultmethoden rein und das w\'e4r dann die einzige stelle, wo auf die Default Identifier Methoden gezeigt wird.\par
So gef\'e4llt mir das.\par
\par
Dann m\'fcssen aber die Persistence#RootResolver und ~Builder Methoden usw. \'fcberarbeitet werden.\par
\par
Damit fliegen auch ein paar umst\'e4ndliche Umwegsmethoden aus der Foundation raus, das ist super.\par
Und die createStoragaManager verliert einen Gro\'dfteil der "clumsy Detour" Logik. Immer sch\'f6n zu sehen, dass sich sauber geplante Strukturen implizit vereinfachend auswirken.\par
\par
Noch bissl TODOs durchschauen und aufr\'e4umen.\par
Achja und die storeRoot() special Logik noch schnell bauen. Das ist gar nicht mal so einfach. Sidn 4 F\'e4lle.\par
Fertig.\par
\par
Morgen noch bissl testen.\par
\par
\par
2019-06-25\par
\par
Testf\'e4lle:\par
\par
1.) Default Root\par
Es wird \'fcberhaupt keine Angabe zur Root Instanz gemacht.\par
EmbeddedStorageManager#defaultRoot wird verwendet, um eine fachliche Root Instanz zu setzen.\par
Beim Laden wird die fachliche Root Instanz generisch erzeugt. Es gibt keine explizit typisierte Referenz darauf.\par
Test:\par
v EmbeddedStorageManager#defaultRoot setzen, speichern, neustarten (laden) und dann get muss die in der ersten Ausf\'fchrung gesetzt Root Instanz zur\'fcckgeben.\par
v EmbeddedStorageManager#storeRoot muss den defaultRoot und den daranh\'e4ngenden Graph speichen.\par
\par
2.) Explicit Root\par
Es wird eine Instanz beliebigen Typs definiert und als explizite Root Instanz\par
Test:\par
v Instanz leer erzeugen, im ersten Durchlauf f\'fcllen, als explicit Root setzen, speichern, neustarten (laden) und dann muss im zweiten Durchlauf die Instanz gef\'fcllt sein\par
v EmbeddedStorageManager#root muss gleiche Identit\'e4t wie die Root instanz sein ("==")\par
\par
3.) Indirect Root\par
Es wird zur Setup Zeit der Storage nur ein Supplier f\'fcr eine Root Instanz \'fcbergeben, die aber noch gar nicht gibt. Erst vor dem Start wird diese erzeugt.\par
Test:\par
v Leeren Supplier registrieren, Instanz leer erzeugen, Datenbank starten, Instanz im ersten Durchlauf f\'fcllen, als explicit Root setzen, speichern, neustarten (laden) und dann muss im zweiten Durchlauf die Instanz gef\'fcllt sein\par
v EmbeddedStorageManager#root muss gleiche Identit\'e4t wie die Root instanz sein ("==")\par
\par
\par
\par
Noch zus\'e4tzliche Methode EmbeddedStorageManager#setRoot(Supplier) bauen.\par
JavaDoc anpassen an gestrige \'c4nderungen (geht's schon wieder los ... aber in geringem Umfang l\'e4sst sich das nicht vermeiden). JavaDoc f\'fcr neue Methode schreiben.\par
\par
Haha und jetzt \'e4nder ich die Benamung doch wieder von "mainRoot" auf "customRoot" zur\'fcck.\par
Denn:\par
Beide, default und custom, sind "main roots". Die Frage ist eben nur, ob die Defaultvariante, oder ob selbst vorgegeben. Da passt "custom" besser als "main".\par
\par
}
 