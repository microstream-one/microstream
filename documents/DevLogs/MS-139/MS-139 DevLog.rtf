{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-06-12\par
\par
\par
F\'fcr den Anfang mal genau zusammenschreiben, wie das intern technisch l\'e4uft.\par
\par
EmbeddedStorageFoundation#createEmbeddedStorageManager(Object explicitRoot)\par
erzeugt intern ein Reference<Object> root\par
Regeln:\par
1.) Falls explicitRoot != null\par
Falls es schon eine Reference ist, dann casten, als root setzen und zur\'fcckgeben.\par
Ansonsten wrappen mit Reference und als root setzen.\par
\par
Falls explicitRoot == null:\par
2.) Falls es einen gesetzten RootResolver gibt, dann null zur\'fcckgeben\par
\par
Falls explicitRoot == null UND RootResolver == null:\par
3.) Reference<Object> mit inhalt null erzeugen, als root setzen und zur\'fcckgeben.\par
\par
"als root setzen":\par
- von der ConnectionFoundation einen neuen PersistenceRootResolver erzeugen, der auf die Root Instanz verweist (\'fcber die Indirektion eines Suppliers)\par
- den als RootResolver in die ConnectionFoundation setzen\par
\par
Erzeugt eine neue EmbeddedStorageManager Instanz mit der definierten "root" Root-Referenz-Instanz (potenziell null).\par
Die Referenz vom EmbeddedStorageManager ist nur soetwas wie eine "convenience" Referenz f\'fcr die dortigen Zugriffsmethoden. Die eigentliche Verkn\'fcpfung (zum Laden/Initialisieren) findet \'fcber den RootResolver statt.\par
\par
\par
EmbeddedStorageManager#root:\par
Gibt trivial this.root zur\'fcck (potenziell null).\par
Typ "Reference<Object>"\par
\par
EmbeddedStorageManager#storeRoot:\par
Ruft EmbeddedStorageManager.root() auf.\par
Falls zur\'fcckgegebene Instanz null ist, wird 0 als ID zur\'fcckgegeben, ansonsten wird die Instanz gespeichert und ihre ID zur\'fcckgegeben.\par
\par
\par
Das hat mehrere Probleme:\par
- storeRoot() impliziert, dass die \'fcbergebene Root Instanz gespeichert wird. Das ist aber nicht der Fall.\par
- Je nachdem, ob man eine Reference oder etwas anderes \'fcbergibt, ver\'e4ndert sich das verhalten der beiden root-bezogenen Methoden. Implizit, ohne es nachvollziehen zu k\'f6nnen (schei\'df casten).\par
- Falls es einen RootResolver gibt, gibt #root trotzdem null zur\'fcck und #storeRoot tut gar nichts. Das ist nicht konsistent.\par
- Falls ein expliziter supplier registriert wird, k\'f6nnte der evtl. eine andere root instanz zur\'fcckliefern, als der EmbeddedStorageManager sich gemerkt hat.\par
\par
\par
Fragen:\par
Warum kann nicht ein Object direkt als root referenziert werden?\par
Eine Reference<Object> zur\'fcckzugeben bringt typisierungsm\'e4\'dfig keinen Vorteil und wenn man eine expliziten Rootinstanz registriert, hat man die Typisierung so oder so.\par
\par
\par
2019-06-13\par
\par
Warum muss nochmal ein Supplier dazwischengeschaltet werden?\par
Ich glaube, die Idee war damals dass die Instanz noch nicht zur Erzeugungszeit des RootResolvers existieren muss, sondern auch erst nachtr\'e4glich erzeugt werden kann.\par
Z.B. wenn man erst den Storage Stuff aufsetzt und konfiguriert und danach erst die Anwendungsebene-Rootinstanz, weil die evtl. von irgendwelchen Configs o.\'c4. abh\'e4ngt.\par
Allerdings muss man sich fragen:\par
- Kommt das so wirklich praktikabel vor?\par
- Wenn ja, ist es wirklich nicht workaroundbar, z.B. einfach durch eine eigene Instanz, die Indirektion macht.\par
- Ist das den potenziellen Fehler wert, dass ein registrierter selbstgebauter Supplier mal mittendrin eine andere Instanz zur\'fcckliefert?\par
\par
Wenn man nur das Registrierten eines selbstgebauten Suppliers verbietet, dann braucht man den gleich nicht, weil er dann einfach nur eine sinnlose Zwischeninstanz ist.\par
\par
Oder es m\'fcsste so gemacht werden, dass der Supplier nur ein einziges mal aufgerufen wird und was immer der zur\'fcckgibt, wird dann "fest" als Rootinstanz referenziert.\par
Hm, das steht so sogar schon in PersistenceRoots$Defalt#setResolvedRoots.\par
\par
Das Problem ist, dass es hier einen Konflikt gibt:\line Es gibt den RootResolver mit PersistenceRoots usw, der n Roots behandelt und aufl\'f6st (n\'e4mlich f\'fcr Konstanten auch noch). Dort, wo die aufgel\'f6st/gesammelt werden, soll jeder Supplier nur einmalig aufgerufen werden.\par
Dann kann er davor/danach aber nicht nochmal aufgerufen werden, um die Referenz auf die "Haupt"-Root-Instanz zu produzieren.\par
Der StorageManager m\'fcsste sich den Namen der "Haupt"-Root Instanz merken und sich diese aus der Map mit den aufgel\'f6sten rausholen. Dann ginge es.\par
\par
Weiter recherchieren:\par
PersistenceRoots wird erzeugt (und damit die konkreten Root Instanzen aufgel\'f6st) in EmbeddedStorageFoundation#createEmbeddedStorageManager\par
Also VOR der Erzeugung des EmbeddedStorageManager.\par
\par
Aber Problem:\par
Zu diesem Zeitpunkt gibt es den Root Identifier nicht mehr.\par
Falls es nicht der Default ist, wurde der gewrappt in einem custom RootResolver.\par
Und der macht nichts anderes, als den Root unter dem Identifier als einen von vielen zu registrieren.\par
\par
Nun k\'f6nnte man nat\'fcrlich sagen:\par
Das explizite Roothandling funktioniert halt dann nur, wenn man auch eine explizite Instanz \'fcbergeben hat.\par
Das w\'e4re aber unvollst\'e4ndig und logisch falsch, denn:\par
Einen eigenen Root Supplier und/oder eigenen Identifier usw. \'fcbergeben, ist eigentlich nur eine API-Variante, die nicht zu anderem bzw. auf einmal ausbleibendem Verhalten f\'fchren sollte.\par
Z.B. das storeRoot w\'fcrde in diesem Fall gar nichts mehr machen. Das kann irgendwie nicht sein.\par
\par
Viel besser ist:\par
Der RootResolver muss eben das Feature, eine "Haupt-" oder "bevorzugte" Instanz zu haben, auch in seiner API reflektieren.\par
\par
Als ersten Schritt ersetz ich mal den BiFunction<String, Supplier<?>, PersistenceRootEntry> durch einen gescheiten PersistenceRootEntry.Provider.\par
Die \'c4nderung war trivial. Weiter im Text.\par
\par
\par
2019-06-14\par
\par
Dabei Problem aufgefallen:\par
PersistenceRootResolver$Builder$Default#registerRoot ruft auch nochmal den supplier auf und das zum Storage-Setup-Zeitpunkt, was den Supplier Ansatz de Facto \'fcberfl\'fcssig macht.\line Das muss ge\'e4ndert werden.\par
\par
\par
Ne Moment:\par
Der Supplier wird nur zusammen mit seinem Identifier in einen Entry gepackt, aber NICHT aufgerufen. Also genau so soll es sein. Passt.\par
War ich gestern schon so ersch\'f6pft von der W\'e4rme? :-D\par
\par
\par
Achja, der Supplier ist n\'f6tig, um Konstanten "dynamisch genug" (bzw. sp\'e4t genug) aufl\'f6sen zu k\'f6nnen.\par
Wichtig!\par
\par
\par
Also es gibt zwei Stellen, wo PersistenceRootEntry#instance, d.h. das .get() vom Supplier, aufgerufen wird:\par
1.) PersistenceRootResolver$Default#getRootInstances\par
\tab - BinaryPersistenceRootsProvider$Default#provideRoots\par
\tab\tab - 1a) EmbeddedStorageFoundation$Default#createEmbeddedStorageManager\par
\tab\tab - 1b) EmbeddedStorageFoundation$Default#ensureRootTypeIdProvider\par
2.) PersistenceRoots$Default#setResolvedRoots\par
\tab - BinaryHandlerPersistenceRootsDefault#update\par
\tab\tab - 2) [implizit beim roots laden in der Initialisierung]\par
\par
Also vom Ablauf her eigentlich drei Aufrufstellen:\par
- Zur Setupzeit: Beim Roots zusammenstellen\par
- Zur Setupzeit:  Beim TypeId sicherstellen (eigentlich nur als Dummy, um die PersistenceRoots Implementierung Class dynamisch auslesen zu k\'f6nnen)\par
- Zur Initialisierungszeit: Beim Roots laden und synchen\par
\par
Ahja: \par
BinaryPersistenceRootsProvider$Default#provideRoots cacht die Instanz, d.h. sie wird nur einmal erzeugt, also auch nur ein Aufruf von Supplier#get.\par
Trotzdem bleibt nat\'fcrlich: Das ist zur Setupzeit und damit zu fr\'fch. (also doch!)\par
\par
Und eigentlich auch unn\'f6tig fr\'fch:\par
1b braucht eh nur irgendeine Instanz des PersistenceRoots Typs, da sind Root Instanzen gar nicht n\'f6tig.\par
1a soll eigentlich auch erst mal nur die Instanz produzieren, um sie weitergeben zu k\'f6nnen, ohne dass sie verwendet wird.\par
\par
Ausprobiert:\par
Mit leerer Datenbank: 1 Aufruf: 1a\par
Mit existierender Datenbank: 2 Aufrufe: 1a, 2\par
Also wie erwartet. Passt.\par
\par
Umgebaut m\'fcsste es werden zu:\par
- PersistenceRoots d\'fcrfte intern zun\'e4chst mal nur die map mit den persistenceEntries halten.\par
- Dann, beim ersten Abfragen der Roots, wird daraus erst die Map mit den tats\'e4chlichen root instanzen gebaut\par
Das entfernt auch automatisch die Aufrufe 1a und 1b: Dort wird dann zwar eine Instanz erzeugt, aber keine Root Instanz abgefragt, d.h. der supplier wird nie aufgerufen.\par
\par
Das (plus ausf\'fchrliche Kommentare) in Kombination mit der Spezialbehandlung f\'fcr den Anwendungs-Root\par
\par
\par
Und das notier ich mir hier, weil ich es jedes mal wieder nicht find!\par
PersistenceMetaIdentifiers#defineConstantSuppliers\par
\par
\par
2019-06-17\par
\par
Nochmal durchlesen. Ja, das passt so. Darauf \'e4nder ich das um.\par
\par
PersistenceRoots Implementierung und Erzeugung ge\'e4ndert.\par
Jetzt wird die Supplier Logik nur noch einmal aufgerufen und das erst beim Laden/Synchen. Nicht vorher.\par
\par
Hm... Benamungen verbessern und zumindest paar Methoden JavaDocen, damit ich deren Verwendungszweck nicht jedes mal neu recherchieren muss.\par
\par
So. Jetzt nochmal nachlesen, wie das mit dem Hintergrund bzw. der Ersatzbarkeit der Reference<> ist.\par
\par
\par
Ach JETZT wei\'df ich wieder, wieso das eine Reference<> ist:\par
Wenn man keinen expliziten Root angibt, w\'e4re es sinnlos, als defautl ein new Object() zu machen, weil man dem nix setzen kann.\par
Also muss es etwas sein, dem man was setzen kann und das einfachste Ding daf\'fcr ist eine Reference<Object>.\par
Wenn dann der R\'fcckgabetyp von EmbeddedStorageManager#root nur Object w\'e4re, m\'fcsste man jedes mal casten und zwar auf was, das von internem Code definiert wird.\par
Hei\'dft: Das w\'e4re SEHR "magic".\par
\par
Mir f\'e4llt keine einheitliche L\'f6sung daf\'fcr ein:\par
- Beliebiger expliziter root setzbar, ohne in eine verwirrende und potenziell fehleranf\'e4llige Reference<Object> gewrappt (und zur\'fcckgegeben) zu werden.\par
- Defaultroot muss zwangsweise eine Reference<Object> sein, die richtig typisiert zur\'fcckgegeben werden muss.\par
\par
Nur daf\'fcr den StorageManager typisieren w\'e4r bl\'f6d.\par
Man kann auch nicht einfach eine neue Root Instanz setzbar machen, denn dann m\'fcsste man mit jedem setzen die kompletten PersistenceRoots neu abspeichern.\par
Also das ginge zwar, aber das ist ja irgendwie eine d\'e4mliche L\'f6sung. Noch dazu, weil ein scheinbar transienter Vorgang (root setzen) dann zu einer Persistierung f\'fchren w\'fcrde.\par
So Tricksereien anfangen wie die OID gleich lassen und eine neue Instanz unter der alten OID abspeichern, fang ich nicht an, weil das die Konsistenzgarantie killt.\par
\par
Vielleicht ginge folgendes:\par
- Typisierung nach au\'dfen auf Object anstatt Reference\par
- Intern wird IMMER eine Reference gehalten. Die h\'e4lt entweder den expliziten Root oder man gettet/settet da defaultm\'e4\'dfig rein. Die default root instanz ist dann null, weil man ja setten kann.\par
- Die interne Reference ist das Ding, das immer dieselbe OID hat.\par
- storeroot speichert IMMER explizit die Reference (falls sie einen neuen referent hat) und immer auch ihren Referent, falls nicht bzw. falls die Referent instanz schon ID-m\'e4\'dfig bekannt ist und darum beim impliziten rekursieren geskippt werden w\'fcrde. Die redundant mitgespeicherten 32 Byte sind nicht der Rede wert. Und wie oft speichert man so einen root schon au\'dferhalb eines Tests?\par
\par
Das sollte beide Anforderungen abdecken...\par
Mal nochmal durchdenken...\par
\par
Ach, aber was ist, wenn man nur einen RootsResolver registriert...?\par
\par
Genau. Darum braucht schon der PersistenceRootResolver einen "main root" oder "application root" oder sowas. Und der wird dann an die PersistenceRoots weitergegeben.\par
Oh, und: Dann muss das auch beim Synchen der loaded/defined roots nachgezogen werden: Loaded Roots haben keinen "main root". Aber die defined Roots definieren einen. Die loadedRoots ist aber die ma\'dfgebliche Instanz, weil die auch wieder gespeichert wird. D.h. der muss vom definedRoots aus der main root gesetzt werden, falls vorhanden.\par
\par
Dann m\'fcsste aber eine Ver\'e4nderung des roots im EmbeddedStorageManager auch eine andere Instanz in der PersistenceRoots Instanz bewirken, d.h. man m\'fcsste den roots dort setzen.\par
Hm. Oder evtl. gleich nur dort?\par
\par
Oder moment mal: Die Reference ist dort ja schon von anfang an gesetzt. Und die \'e4ndert sich auch nicht mehr. Wenn sich ihr Inhalt \'e4ndert, dann ist das ja unabh\'e4ngig von der PersistenceRoots instanz bzw. gilt dort automatisch mit.\par
Funktionweise von Referenzen und so.\par
\par
So mach ich das.\par
\par
\par
2019-06-18\par
\par
Commit gestern vergessen. Nachholen.\par
\par
Jetzt die mainRoot Logik einbauen.\par
Auch in Builder.\par
\par
Jetzt die RootResolver und RootResolverBuilder Methoden in Persistence anpassen.\par
Das wird jetzt knifflig: Wie kann man den default Identifier String "root" m\'f6glichst nur einmal vorkommen lassen?\par
\par
Hm, Moment mal:\par
Was genau steckt f\'fcr den main root nun in der resolvedRoots hashtable drin?\par
Das muss ja dann eigentlich der wrappende Singleton sein, damit OID usw. zusammenpassen.\par
Dann m\'fcsste das aber gespecial-caset beim roots resolven eingebaut werden, sonst steckt der loop die root instanz selbst dort rein...\par
Hm, oder der mainRoot br\'e4uchte eine spezielle Art RootEntry, der die Aufl\'f6sung anders macht.\par
\par
Oder die Aufl\'f6sung l\'e4uft einfach normal durch und am Ende wird die Root Instanz durch den Singleton gewrappt und der ersetzt dann den eigentlichen Eintrag.\par
Das w\'e4re eine ganz elegante L\'f6sung, glaub ich.\par
\par
Aber ein Problem f\'e4llt mir bei meinem Reference-L\'f6sungskonzept gerade noch auf:\par
Die Roots werden ja gesyncht. Es wird aber nur die Identit\'e4t gesyncht, nicht irgendwie "deep" mit den Daten.\par
Das hei\'dft:\par
- Man definiert eine Main Root Instanz, die in einer Reference (also einem Singleton) gewrappt wird.\par
- Durch den RootResolver und dem Main Root Namen wird dieser Instanz die Main Root OID zugewiesen.\par
- Die Initialisierung l\'e4dt die Roots, d.h. was immer in der Datenbank f\'fcr den main root singleton als Referent definiert ist, ersetz das Ding, das von der Anwendungslogik gesetzt wurde.\par
- Der Synch sagt der main root Singleton ist konsistent zur Datenbank (obviously), also passt alles.\par
Aber es passt nicht, sondern die eigentliche main root der Anwendung wird nicht mehr als Root referenziert. Die Instanz ist keine Root mehr.\par
\par
Vielleicht m\'fcsste dann einfach nur EmbeddedStorageManager#synchronizeRoots auch eine Sonderfallbehandlung machen: schauen, ob sich der Referent ge\'e4ndert hat.\par
Aber hm, moment mal: wenn der Referent der Reference kein Root mehr ist, wie wird dann die anwendungsdefinierte Instanz der OID in der Datenbank zugeordnet?\par
\par
W\'e4re es evtl. eine L\'f6sung, intern beide Instanzen als Root zu registrieren?\par
Die Reference/Singleton, damit der EmbeddeStorageManager seinen Ankn\'fcpftpunkt hat und die eigentliche Root, damit man eben die Instanz ordentlich verbunden kriegt ...\par
\par
\par
Irgendwie zieht das immer weitere Kreise und ich werd zunehmend verwirrt:\par
Wenn es nur ein Mapping '1000000007 <-> "root"' gibt, hei\'dft das ja: "Welche Instanz auch immer durch den Namen 'root' aufgel\'f6st wird, die wird f\'fcr die OID registriert."\par
Aber was ist, wenn man in der Anwendung die root Instanz \'e4ndert von z.B. einer blanken HashTable auf eine Instanz der Klasse "MyAppRoot", die intern eine HashTable mit gleicher Funktion h\'e4lt?\par
Dann hat die MyAppRoot Instanz auf einmal die OID einer HashTable und falls diese HashTable irgendwo anders referenziert wird (also eine R\'fcckreferenz auf die Root. Unwahrscheinlich aber nicht abwegig), dann bekommen Instanzen, die auf die HashTable zeigen, beim Laden auf einmal eine MyAppRoot Instanz gesetzt. Und zwar ohne irgendeinen type check durch die JVM, weil ja Unsafe verwendet wird.\par
Gilt nat\'fcrlich genauso f\'fcr alle anderen Roots, also Konstantenreferenzen auf Instanzen.\par
Hm...\par
Gut, man kann nat\'fcrlich sagen: Daf\'fcr gibts das Refactoring Mapping.\par
Wobei das ja nur die Refrenz umbiegen kann auf eine Instanz, die dann aufbaum\'e4\'dfig wieder passt. Aber was ist, wenn man ausdr\'fccklich eine andere Instanz mit anderem Aufbau haben will?\par
\par
Vielleicht w\'e4re der persistierte Doppelroot da sogar die L\'f6sung:\par
Die interne Reference bleibt OID- und Typm\'e4\'dfig immer gleich. Das ist verl\'e4sslich, das ist schon mal super.\par
Die eigentliche Root Instanz (mit irgendwie einem generierten identifier) kann beim roots resolven mal nicht mehr gefunden werden, dann wird einfach nicht resolvet und durch die aus den definedRoots ersetzt (ist jetzt auch schon so).\par
\par
Das Problem ist: welcher identifier soll generiert werden, der dann eine fachliche \'c4nderung erkennbar macht? Den full qualified Type name reingenerieren w\'e4re eine M\'f6glichkeit, aber dann stehen wieder Metadaten als Nutzdaten im Code und beim ersten Refactoring gibts wieder Probleme. Das ist nix.\par
\par
Das kann doch alles nicht so schwierig sein. Zumal auch jetzt schon Instanzen einfach mit einer Reference gewrappt werden.\par
Nochmal nachlesen, wie das aktuell mit dem Wrappen l\'e4uft ...\par
\par
Eine explizite Root Instanz wird mit einer Reference gewrappt und die wird dann gespeichert.\par
Moment mal: wie kann die dann \'fcberhaupt aktualisiert werden anstatt einfach durch eine generische ersetzt zu werden?\par
}
 