{\rtf1\ansi\ansicpg1252\deff0\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\lang7\f0\fs28 StorageEntityCache#clearState throws an NPE\par
priv#230\par
\par
\par
2020-02-20\par
\par
Da muss ich mir ein DevLog machen, damit ich den \'dcberblick behalt.\par
\par
Also StorageEntityCache#clearState wird von zwei Methoden aufgerufen:\par
1.) StorageChannel#clear\par
2.) StorageFileManager#clearState\par
\par
Das ist schon mal komisch, denn warum ruft der file manager die clearing Methode eines Teils des StorageChannels direkt auf anstatt direkt StorageChannel#clear aufzurufen?\par
Das muss ich mal anschauen ...\par
\par
Ahja: Der Grund ist: StorageFileManager hat keine Referenz auf seinen parent StorageChannel, sondern nur umgekehrt: Der StorageChannel hat einen FileManager.\par
Aber es verbietet ja eigentlich keiner, dass der StorageChannel beim initializeStorage sich selber als Argument \'fcbergibt, damit der FileManager im Exceptionfall sauber das \'fcbergeordnete #clear aufrufen kann.\par
Hm, naja gut: es gibt im StorageChannel nix zu clearen, weil das FileManager#initializeStorage das erste ist, was der Channel aufruft.\par
Aber das ist jetzt nur "zuf\'e4llig" so. Das kann sich durchaus auch mal \'e4ndern und dann schummelt sich der FileManager auf einmal an der \'fcbergeordnet koordinierenden Instanz vorbei.\par
Da muss ich morgen mal genauer dr\'fcber nachdenken ...\par
\par
\par
2020-02-21\par
\par
Also eigentlich m\'fcsste es in der interface API aller Channel-Teil-Typen ein "reset()" geben.\par
Alle au\'dfer dem StorageChannel rufen immer nur das zentrale reset des StorageChannels auf und nur der StorageChannel selbst ruft dann die resets seiner Teile auf.\par
Die reset() Aufrufe leeren alle gesammelten variablen Daten (Caches, Registries, usw.) und resetten den internen Zustand aller Felder auf den Anfangszustand.\par
Der FileManager kriegt f\'fcr sein initialize() senien parent StorageChannel \'fcbergeben und ruft im Exceptionfall dessen reset auf.\par
Da das wiederum den FileManager resettet, darf die danach noch aufgerufen "Restlogik" in seinem initialize() nat\'fcrlich damit keine Probleme machen. Normalerweise sollte das dann aber eh nur noch ein "throw ... " sein.\par
UND: alle reset Methoden d\'fcrfen nat\'fcrlich nicht von Annahmen ausgehen, das irgendwas von dem internen State schon auf eine bestimmte Weise vorhanden ist oder so, bzw. man muss darauf pr\'fcfen.\par
Also eben f\'fcr den Fall: FileManager ruft im exception-Fall ein reset auf, das den EntityCache resettet, bevor dieser \'fcberhaupt initialisiert worden ist. Das muss die Reset-Logik abdecken.\par
\par
Strukturell soweit alles umgebaut, das ging ja leicht.\par
Jetzt noch reset() f\'fcr FileManager und f\'fcr EntityCache implementieren.\par
Erst mal FileManager.\par
Alle final Felder bleiben, obviously.\par
Die ganzen TransactionsFile Entry Buffers m\'fcssten auch resettet werden. Oder? Mal schauen...\par
\par
\'c4h ... warum werden die nur beim FileManager initialisieren initialisiert, aber bei jeder verwendung gecleart, aber es funktioniert trotzdem richtig?\par
Oder tut es das gar nicht?\par
Ne, muss eigentlich, weil die TransactionsFile Entries ja bei jedem Start geparst werden ...\par
Muss ich untersuchen. Check ich nicht.\par
\par
...\par
...\par
\par
Ach, ich depp:\par
Denen wird einmal zu Beginn ihr unver\'e4nderlicher Header gesetzt.\par
Bei jeder Verwendung wird gecleart, aber das ist nur f\'fcrs Rauschreiben. Das Bef\'fcllen passiert ja nicht \'fcber die interne position, sondern low-level per Adresse.\par
Jetzt kann ich mich auch wieder daran erinnern.\par
Und daf\'fcr hab ich jetzt 20 Minuten lang verwirrt im Code rumgesucht. Top.\par
\par
Okay das hei\'dft: Buffers m\'fcssen nicht resettet werden, denn:\par
- Der erste Teil ist quasi "immutable", der wird niemals ver\'e4ndert.\par
- Der Rest wird eh vor jedem Schreiben neu gesetzt. Was davor drin stand, ist egal.\par
\par
Muss ich aber mal bissl notieren mit Kommentaren.\par
\par
\par
2020-02-23\par
\par
Also ich hab ja im FileManager die verschiedenen Felder schon in 5 Kategorien bzgl. Resetting eingeteilt und kommentiert.\par
Die erste 2 sind schon erledigt. Die restlichen drei Kategorien sind 6 Felder. Manche davon sind schon klar. Manche muss ich noch schauen. Dann ist der FileManager fertig.\par
\par
Es w\'e4r nat\'fcrlich sinnvoll, im reset nicht einfach nur pendingFileDeletes auf 0 zu setzen, sondern gleich alle pending file deletes auszuf\'fchren, bzw. zumindest nochmal zu checken, ob pending delete files deleted werden k\'f6nnen.\par
Ach. Das wird in clearRegisteredFiles ja eh schon gemacht. Jedes file wird wird #unregisterUsageClosing geschlossen.\par
\par
Achja: die eigentliche Ursache f\'fcr das Issue w\'e4re auch noch: der NPE in #clearState (jetzt #reset).\par
Mal anschauen.\par
Das kann eigentlich nur in #clearRegisteredFiles sein.\par
Aber ... wenn ich mir das so anschaue ... kann da eigentlich kein NPE auftreten.\par
- this.headfile wird schon auf null gepr\'fcft.\par
- die \'fcbergebene closingAction wird auch auf null gepr\'fcft.\par
- this ist niemals null\par
- ganz unten stehen nur zwei Zuweisungen bzw. auch hier wieder: this ist niemals null\par
- bleibt nur noch, dass file.next auf null zeigt, was durch die while Pr\'fcfung nicht abgedeckt wird, weil die auf == headFile pr\'fcft, nicht auf == null.\par
\par
Also ist die Frage: Kann .next vom headFile aus jemals auf null zeigen?\par
Und dazu steckt die Antwort eigentlich in #registerStorageHeadFile:\par
if(this.headfile == null)\par
storageFile.next = storageFile.prev = storageFile;\par
\par
Also beim HeadFile setzen ist es schon mal technisch unm\'f6glich.\par
\par
else\line [storageFile in die Kette einklinken mit dem entsprechenden setzen der 4 Referenzen. headFile.next zeigt auf das neue storageFile, daf\'fcr zeigt storageFile.next auf das bisherige headfile.next.\par
Zusammen mit dem Initialisierungsfall (wo headFile auf sich selbst zeigt) hei\'dft das: .next kann niemals null sein.\par
\par
Hm. Wo kommt dann jetzt der NPE her?\par
Muss ich testen mit einer debugm\'e4\'dfig erzeugten Exception in der FileManager Initialisierung, die ja dann im catch das reset aufruft.\par
\par
Mit der neuen #reset Benamung sollte ich #resetFileCleanupCursor besser umbenennen zu #restart... oder sowas in der Art. \par
\par
Exception-test gemacht: Hm. Da tritt kein NPE auf. War die Situation bei ZJ ein Sonderfall, der im StorageManager eine Inkonsistenz erzeugt hat?\par
Oder hab ich einen NPE-Bug durch die Umstrukturierung schon implizit gefixt?\par
\par
Noch ein anderes catch-TODO anschauen.\par
Brauch ich nicht, weil der Kontext das eh macht. Wegl\'f6schen und kommentieren.\par
\par
Damit w\'e4r der StorageFileManager jetzt fertig.\par
Morgen muss ich noch StorageEntityCache#reset machen, dann ist das abgeschlossen.\par
Bzw. dann muss ich nochmal schauen, wie/wo Zj die Exception hatte und ob das noch auftritt.\par
\par
\par
2020-02-24\par
\par
Ach! Wer Issues lesen kann, ist klar im Vorteil:\par
Der NPE kam ja im StorageEntityCache, nicht im FileManager.\par
Wobei das letztendlich keine Rolle spielt: ich hab im FileManager#initialize eine Exception fliegen lassen und der reset-Aufruf im Catch ruft das Reset BEIDER Teile auf.\par
Das Reset des EntityCache wird zuerst aufgerufen und da bin ich beim testen einfach dr\'fcber. Ohne Exception. Also gilt die Aussage doch wieder, dass die Exception nicht reproduzierbar ist.\par
Hm.\par
\par
Auf jeden Fall jetzt erst mal genauso strukturiert allen EntityCache State kategorisieren und resetten.\par
\par
Nummerierung der 5 Kategorien vereinheitlichen...\par
\par
StorageEntityMarkMonitor wird f\'fcr sich state-m\'e4\'dfig auch nochmal so komplex wie die anderen beiden.\par
Also auch kategorisieren usw.\par
\par
Ups, StorageReferenceMarker gibts ja dann auch wieder mit eigenem mutable state ...\par
Daf\'fcr sollte es besser noch ein Registrierungsarray im MarkMonitor geben, damit bei einem Reset der sein Zeug sauber resetten kann und nicht irgendwelche Teile von ihm unerreichbar drau\'dfen "rumliegen" und dort explizit resettet werden m\'fcssen.\par
Bau ich mal noch ein.\par
\par
Puh, da hat sich noch einiges ergeben. Z.B. die \'fcber zwei Arrays aufgeteilte Datenstruktur zu einem ordentlichen "ChannelItem" zusammenfassen, code entsprechend refactoren.\par
Nebenbei kleine Recherche und Kommentare zu einem m\'f6glichen Grund f\'fcr den GC-Bug (Yippie!).\par
\par
Dann wieder Recherche und Kommentar zum eigentlichen NPE. Evtl. ist das FileManager headFile null, wenn der cache check vorzeitig ausgef\'fchrt wird ...\par
\par
Von der Reset-Logik her sollte nun alles fertig sein. Muss ich nochmal durchschauen und testen, zusammen mit den anderen gemachten Tasks.\par
Dann ist das fertig.\par
\par
\par
23:15\par
Ich bau jetzt die "getFirstReachableEntity" Methode einfach gleich so um, dass kein NPE mehr passieren kann.\par
Und gleich verschoben in den FileManager, wo sie hingeh\'f6rt.\par
\par
Jetzt testen.\par
Ups, NPE, weil nat\'fcrlich zur Initialisierungszeit die ReferenceMarker noch nicht da sind.\par
Dann trenn ich das jetzt doch auf in initialize() und reset(). Aber den null-check bei den ReferenceMarkern brauch ich trotzdem.\par
\par
Jetzt also testen mit der erzwungenen Exception.\par
Hm, kein NPE (mehr?)\par
\par
Mal die Exception an ein paar verschiedenen Stellen innerhalb von #initializeForExistingFiles setzen.\par
Ne, wieder nix.\par
Also damit w\'fcrd ich dieses Issue mal als erledigt bezeichnen.\par
Resetting der Kern-Teile ist jetzt sauber und vollst\'e4ndig.\par
NPE ist nicht (mehr?) reproduzierbar.\par
Fertig.\par
\par
01:30\par
Ups. Commit vergessen. Schnell noch machen ...\par
}
 