{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 MS-130\par
\par
2019-04-17 \par
\par
Einlesen in Entwurf von neulich.\par
Code \'fcbernehmen und weitermachen.\par
\par
\par
2019-04-18\par
\par
Sammel- und Initialisieralgorithmus w\'e4r soweit fertig.\par
Jetzt ist aber noch die Frage, wie das mit PersistenceTypeDefinitionMember verbandelt wird ...\par
Genauer gesagt PersistenceTypeDefinitionMemberPseudoField.\par
\par
Das ist im Detail aber schon wieder knifflig:\par
1.) Wenn es eine Delegate Instanz davon wrappt, dann braucht die f\'fcr den Konstruktor einen Namen. Evtl. m\'fcsste dann die Namensinitialisierung eine neue Instanz davon machen.\par
2.) Namen sollen unique sein. Sind sie aber nicht zwangsweise bei PseudoFields \'fcber eine Vererbungshierarchie.\par
3.) Es m\'fcsste dann auch noch eine M\'f6glichkeit geben, Variable Length nested Members zu definieren. Hm, wobei das dann ja ausdr\'fccklich keine BinaryFields sein m\'fcssen, da reicht das bisherige. Passt.\par
\par
#1 l\'f6sen: umbauen auf delegate. PersistenceTypeDefinitionMemberPseudoField erweitern um "copyForName".\par
Testen. Bissl fixen. Passt.\par
\par
Noch Varianten f\'fcr [char] und [byte] machen.\par
Testen.\par
Wirre Exception.\par
Ah, das war ein Dreher in einer der neuen copyForName() Methoden.\par
Testen. Passt.\par
\par
Hm, aufgefallen: wenn das jetzt das alte konzept ersetzen soll, ist die Initialisierung in der TypeId-Initialisierung zu sp\'e4t, weil ja schon vorher X-mal die members abgefragt und analysiert werden.\par
Aber eigentlich ist die L\'f6sung ganz einfach: members leer lassen und on-demand initialisieren. \par
\par
\par
2019-05-06\par
\par
Test.\par
\par
\par
2019-05-07\par
\par
Wieder eingelesen und durchgedacht, was auskommentiert werden muss, damit der unvollst\'e4ndige Zustand gefahrlos in den Master Branch gemerget werden kann, um mit JavaDoc schreiben anzufangen.\par
\par
\par
\par
2020-01-05\par
\par
Dreiviertel Jahr sp\'e4ter und schon gehts weiter!\par
\par
Wieder bissl orientieren. Code durchschauen.\par
Paar TODOs implementieren.\par
\par
Hm. Erst mal muss ein gescheites Beispiel her. Mit Vererbung in den Entityklassen und analog dann in den BinaryHandler Klassen.\par
\par
St\'fcck f\'fcr St\'fcck implementieren ...\par
Ich glaub, ich mach 9 Mini-Ableitungen f\'fcr die 8 Primitives und Referenzen.\par
Jo, das ist gut so.\par
\par
Achso, hm, primitive arrays und die variable Length Dinger brauch ich dann auch noch. Der Complex Fall wird ... komplex.\par
Das mach ich sp\'e4ter. Erst mal die einfachen F\'e4lle als Proof-of-Concept.\par
\par
Da f\'e4llt mir auf: Wenn man f\'fcr Wert holen und Wert setzen noch Lambdas direkt in die BinaryField Erzeugung reinsetzen w\'fcrde, dann k\'f6nnte die eigentliche Logik generisch laufen und man br\'e4uchte unten gar keine Implementierung mehr...\par
Hm. Dar\'fcber muss ich mal nachdenken ...\par
\par
Jo. Das w\'fcrde einwandfrei gehen. W\'e4re sogar recht kurz zu schreiben.\par
\par
Dann mach ich aus den Getter und Setter Typen aber gleich allgemeine .reflect. Typen ...\par
\par
\par
\par
2020-01-07\par
\par
Implementierungen f\'fcr die 9 verschiedenen Typen (8 Primitives + 1 Reference) erstellen.\par
\'dcberlegungen zu implementierung von #create. \par
Hm... einen PersistenceTypeInstantiator<Binary, T> mit \'fcbergeben m\'fcssen w\'fcrde alles ziemlich verkomplizieren.\par
Immer hardgecodet die generische Variante aufrufen ist aber auch nicht gut.\par
Jede Pseudo-Konstruktor Methode doppelt machen m\'fcssen aber auch nicht. Aber ist wahrscheinlich das geringste \'fcbel von allen.\par
Aber wenn in der Foundation schon ein custom Instantiator gesetzt w\'e4re, k\'f6nnte der hier nicht verwendet werden, weil die Pseudo-Konstruktor Methoden statisch sind. Aber alles \'fcber eine Art "Builder" dr\'fcberschleifen w\'fcrde die Convenience zerst\'f6ren ... Alles Mist. Auf jeden Fall mal FIXME hinmachen.\par
Erst mal Feierabend und sp\'e4ter weitermachen.\par
\par
Sp\'e4ter:\par
DevLog nachtragen.\par
Und \'dcberlegung vom Weg zum Auto:\par
Das mit dem Custom Instantiator wird gar nicht so einfach. Wenn der direkt einige BinaryFields nutzen soll, muss man entweder den offset doch wieder manuell verwenden k\'f6nnen, oder es m\'fcssen doch wieder die tausend verschiedenen getter (aber immerhin ohne Setter) f\'fcr verschiedene Typen ins interface, die dann im falschen Fall nur mit runtime-check eine exception werfen.\par
Und wie bringt man die generische Logik dazu, diese Felder dann in #initializeState nicht nochmal zu verwenden? Hm, evtl. indem der Getter null ist. Das w\'fcrde gehen.\par
#canRad einbauen.\par
\par
Und bl\'f6d ist halt, dass es jetzt doch "Field_int" usw. anstatt nur \'fcberladen "Field" hei\'dfen muss, weil die Nachsicht des Compilers zwischen den primitives Mehrdeutigen erzeugt, wo eigentlich gar keine sind. Doof.\par
Aber mei, Convenience-m\'e4\'dfig ist es gar nicht so schlecht, den Primitive Type nochmal explizit dort zu haben.\par
Mal die aktuellen Compilerfehler weiter rausmachen ...\par
\par
Es gibts noch ein Problem, das eigentlich nur Schall und Rauch ist: Benamung.\par
Was bei TypeHandlern bisher "Custom" hei\'dft, ist eigentlich "Tailored" oder so. Und "Custom" w\'e4re dann "extends Tailored" und w\'fcrde den ganzen BinaryField Grusch enthalten.\par
Wenn ich den in die allgemeinere Klasse reinsteck, dann wird die \'fcberfrachtet mit allen m\'f6glichen Feldern, die im nicht-Custom-Tailored Fall null/0 sind. Sowas ist bl\'f6d. Unsaubere Abstraktion.\par
Aber sollt ich jetzt wirklich alles bisherige "Custom" umbenennen zu "Tailored"?\par
Das klingt irgendwie zu seltsam. Gibts da nix besseres...?\par
\par
\par
2020-01-08\par
\par
So. Im B\'fcro bin ich heute wieder mal nicht dazu gekommen, an meinem eigentlichen Thema zu arbeiten. Darum jetzt noch ein wenig.\par
Mir ist gestern abend beim Z\'e4hneputzen aufgefallen: Den Instantiator braucht man ja nur einmal pro Typ, nicht einmal pro BinaryField.\par
Den kriegt man schon irgendwie unter, evtl. on-demand versp\'e4tet gesetzt. Das wird kein Stress. Passt.\par
\par
Dann zur\'fcck zur Benamung.\par
Evtl. "~Specific~" anstatt "~Tailored~"?\par
\par
Also ich mach jetzt erst mal eine dumm benannte "Custom2" Klasse, um mal die Struktur weiterzubringen und mach mir \'fcber die Benamung sp\'e4ter Gedanken ...\par
\par
\par
2020-01-09\par
\par
Und wieder mal 0 dazugekommen vor lauter anderem Zeug, also mach ich jetzt noch bissl...\par
Erst mal wieder einlesen. Es ist echt nichts so einfach, an einem Thema immer nur kurz st\'fcckchenweise kurz vor Mitternacht zu arbeiten ...\par
\par
Fehlende Generics einf\'fcgen.\par
#initializeInstanceMembers Basisimplementierung und Implementierung f\'fcr BinaryFields.\par
\par
\par
2020-01-10\par
\par
Und wieder bissl weitermachen...\par
\par
\par
2020-01-13\par
\par
Wieder marginal weitermachen. Primitive und Reference fields cachen f\'fcr Verwendung in #create und #update/#initialize.\par
\par
Hm. Ne Moment: nicht primitive und reference, sondern: reference und non-reference.\par
Es gibt ja n\'e4mlich\par
- Primitive Fields\par
- Reference Fields\par
- list/complex Fields mit References\par
- list/complex Fields ohne References\par
\par
Und der Witz an der Unterscheidung ist: Wenn die Zahl der hasReference() fields 0 ist, dann ist der Typ ein ValueType, f\'fcr den updateState entsprechend validieren kann/muss anstatt updaten.\par
Muss ich gleich mal entsprechend verbessern.\par
\par
Oh. Problem:\par
Es gibt ja auch noch "hasInstanceReferences". Bl\'f6d ist: Das kann man bei CustomHandlern nicht ableiten. Denn: Es kann gut sein, dass ein BinaryField_int ein Reference Field der Instanz repr\'e4sentiert.\par
Man k\'f6nnte die Klasse direkt durchiteriere und nach Referenz-Feldern scannen, aber das killt irgendwie den Sinn von Custom Handlers: wer wei\'df, was der Autor des CustomHandlers mit den Referenzen seines Entity Typs anstellt? Sie k\'f6nnten einfach immer null bleiben oder aus primitive Werten erzeugt werden oder was auch immer.\par
Das Interessante an dem Thema ist: Die Methode PersistenceTypeHandler#hasInstanceReferences wird niemals verwendet. Sie ist nie n\'f6tig. Wahrscheinlich genau aus dem Grund, dass es f\'fcr die Persistierung nie relevant sein darf, ob eine Instanz Referenzen hat, sondern nur, wie man Instanzen in einen persistenten Zustand bringt.\par
Hei\'dft: Wahrscheinlich w\'e4re die beste L\'f6sung, die Methode einfach zu l\'f6schen. Die Alternative w\'e4re, f\'fcr eine \'fcberfl\'fcssige Methode den Entwickler mit der manuelles Vorgabe eines boolean Werts zu nerven...\par
Achja: es gibt aber auch noch #iterateInstanceReferences. Und die wird ... zwar 4 mal aufgerufen, aber 1 davon ist debug stuff. 2 sind nur wrapper. Und das letzte ist ... der registerer, der wiederum selbst eigentlich irrelevant ist.\par
HMMM...\par
Alles raus?\par
\par
\par
2020-01-15\par
\par
Wieder hier weitermachen.\par
Paar Compilerfehler schnell wegmachen.\par
\par
Achja: Die Frage "Alles raus?"\par
Also das einzige, was mich noch z\'f6gern l\'e4sst, ist: Was ist, wenn man doch mal dieses Registering braucht?\par
Hm. Eigentlich k\'f6nnte man das \'fcber die instanceMembers l\'f6sen.\par
Wobei das Problem hier wieder das gleiche ist: Wenn man an die instanceReference rankommen soll, kann es nicht ein einziger Getter sein, sondern dann m\'fcssen es zwei sein:\par
1.) Wert aus der Instanz holen\par
und\par
2.) Geholten Wert in persistente Form bringen.\par
Das verkompliziert aber die Definition eines BinaryFields und macht manche Konvertierungslogik schwierig bis unm\'f6glich, die mit einem einzelnen, monolithischen Getter ein Kinderspiel w\'e4re.\par
Also bleibt letztendlich so oder so, wie man es dreht: Wenn BinaryFields einfach machbar sein soll, kann es kein #iterateInstanceReferences geben.\par
\par
Oder Moment mal: Z\'e4hlen eigentlich nur die Instanz-Referenzen, die auch als Referenzen persistiert werden?\par
Sagen wir, eine Instanz zeigt auf einen String. Dieser String wird aber nie als Referenz auf eine echte String Instanz gespeichert, sondern als nested char sequence. "Z\'e4hlt" der String dann \'fcberhaupt als zu iterierende Instanz in einem Graph?\par
Die Natur dieses Strings ist ja, dass es eine internenes "unshared" reference ist.\par
Hm...\par
War das einfach ein Denkfehler von mir?\par
Dann also dich einfach alle reference members iterieren und fertig aus?\par
Hm. Ich glaube ja.\par
\par
Das w\'fcrde dann aber trotzdem hei\'dfen, dass die Methode #hasInstanceReferences \'fcberfl\'fcssig ist, wenn es #hasPersistedReferences schon gibt.\par
Es z\'e4hlen ja quasi nur die "persisted" (= "peristence-relevanten") Referenzen.\par
\par
Jetzt hab ich nur rum\'fcberlegt und nix programmiert, aber wichtige \'dcberlegungen. Muss ich morgen nochmal anschauen und dann refactoren.\par
\par
\par
2020-01-16\par
(eigentlich schon 2020-01-17 nach Mitternacht)\par
\par
Also dann l\'f6sch ich jetzt die #hasInstanceReferences weg und bau die iterate Methode auf persistierte Referenzen um.\par
Immerhin gehts bei einem PersistenceHandler ja schon irgendwie um genau die und nicht um alle Referenzen im allgemeinen, die irgendwo in einer Instanz rumflacken.\par
Und #iterateInstanceReferences  auch gleich implementieren.\par
\par
\par
2020-01-20\par
\par
Nach FirmentrennungsUmzug, Release und anderem Ged\'f6ns mal wieder weitermachen.\par
Wo war ich da eigentlich ...?\par
\par
\par
storeFields einf\'fcgen als performanceoptimierte Komplettliste mit korrekter Reihenfolge neben ref- und nonref-feldern.\par
Optimierung f\'fcr mitverwendete Arrays im reinen ref- oder nonref-Fall.\par
\par
initializationInvokingClass auskommentieren. Ich glaub, das braucht man nicht.\par
\par
Zwischendrin mal schnell Entwurf f\'fcr #store Implementierung einbauen.\par
\par
final PersistenceTypeInstantiator<Binary, T> instantiator \'fcbernehmen aus ~GenericType Implementierung.\par
\par
Hm. BinaryField Typisierung umstellen von <?> auf <T>. Dann werden an ein paar Stellen unsch\'f6ne suppressexceptions n\'f6tig.\par
Dabei aufgefallen: Ich k\'f6nnte bzw. muss ja mit field.getGenerticType() pr\'fcfen, ob das Field die passende Generics Typisierung hat. Auf der Reflection Ebene gibts die Informationen ja immerhin...\par
\par
Da passen die Initialisierungsmethoden noch nicht zusammen. Das sind verschiedene Konzepte, die mal zu einem konsolidiert werden m\'fcssen.\par
\par
Okay, wird schon langsam. Noch bissl konsolidieren, dann mit den generischen Mitteln die Instanz-handling-Methode implementieren, dann ist es fertig zum testen.\par
}
 