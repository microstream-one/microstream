{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 MS-130\par
\par
2019-04-17 \par
\par
Einlesen in Entwurf von neulich.\par
Code \'fcbernehmen und weitermachen.\par
\par
\par
2019-04-18\par
\par
Sammel- und Initialisieralgorithmus w\'e4r soweit fertig.\par
Jetzt ist aber noch die Frage, wie das mit PersistenceTypeDefinitionMember verbandelt wird ...\par
Genauer gesagt PersistenceTypeDefinitionMemberPseudoField.\par
\par
Das ist im Detail aber schon wieder knifflig:\par
1.) Wenn es eine Delegate Instanz davon wrappt, dann braucht die f\'fcr den Konstruktor einen Namen. Evtl. m\'fcsste dann die Namensinitialisierung eine neue Instanz davon machen.\par
2.) Namen sollen unique sein. Sind sie aber nicht zwangsweise bei PseudoFields \'fcber eine Vererbungshierarchie.\par
3.) Es m\'fcsste dann auch noch eine M\'f6glichkeit geben, Variable Length nested Members zu definieren. Hm, wobei das dann ja ausdr\'fccklich keine BinaryFields sein m\'fcssen, da reicht das bisherige. Passt.\par
\par
#1 l\'f6sen: umbauen auf delegate. PersistenceTypeDefinitionMemberPseudoField erweitern um "copyForName".\par
Testen. Bissl fixen. Passt.\par
\par
Noch Varianten f\'fcr [char] und [byte] machen.\par
Testen.\par
Wirre Exception.\par
Ah, das war ein Dreher in einer der neuen copyForName() Methoden.\par
Testen. Passt.\par
\par
Hm, aufgefallen: wenn das jetzt das alte konzept ersetzen soll, ist die Initialisierung in der TypeId-Initialisierung zu sp\'e4t, weil ja schon vorher X-mal die members abgefragt und analysiert werden.\par
Aber eigentlich ist die L\'f6sung ganz einfach: members leer lassen und on-demand initialisieren. \par
\par
\par
2019-05-06\par
\par
Test.\par
\par
\par
2019-05-07\par
\par
Wieder eingelesen und durchgedacht, was auskommentiert werden muss, damit der unvollst\'e4ndige Zustand gefahrlos in den Master Branch gemerget werden kann, um mit JavaDoc schreiben anzufangen.\par
\par
\par
\par
2020-01-05\par
\par
Dreiviertel Jahr sp\'e4ter und schon gehts weiter!\par
\par
Wieder bissl orientieren. Code durchschauen.\par
Paar TODOs implementieren.\par
\par
Hm. Erst mal muss ein gescheites Beispiel her. Mit Vererbung in den Entityklassen und analog dann in den BinaryHandler Klassen.\par
\par
St\'fcck f\'fcr St\'fcck implementieren ...\par
Ich glaub, ich mach 9 Mini-Ableitungen f\'fcr die 8 Primitives und Referenzen.\par
Jo, das ist gut so.\par
\par
Achso, hm, primitive arrays und die variable Length Dinger brauch ich dann auch noch. Der Complex Fall wird ... komplex.\par
Das mach ich sp\'e4ter. Erst mal die einfachen F\'e4lle als Proof-of-Concept.\par
\par
Da f\'e4llt mir auf: Wenn man f\'fcr Wert holen und Wert setzen noch Lambdas direkt in die BinaryField Erzeugung reinsetzen w\'fcrde, dann k\'f6nnte die eigentliche Logik generisch laufen und man br\'e4uchte unten gar keine Implementierung mehr...\par
Hm. Dar\'fcber muss ich mal nachdenken ...\par
\par
Jo. Das w\'fcrde einwandfrei gehen. W\'e4re sogar recht kurz zu schreiben.\par
\par
Dann mach ich aus den Getter und Setter Typen aber gleich allgemeine .reflect. Typen ...\par
\par
\par
\par
2020-01-07\par
\par
Implementierungen f\'fcr die 9 verschiedenen Typen (8 Primitives + 1 Reference) erstellen.\par
\'dcberlegungen zu implementierung von #create. \par
Hm... einen PersistenceTypeInstantiator<Binary, T> mit \'fcbergeben m\'fcssen w\'fcrde alles ziemlich verkomplizieren.\par
Immer hardgecodet die generische Variante aufrufen ist aber auch nicht gut.\par
Jede Pseudo-Konstruktor Methode doppelt machen m\'fcssen aber auch nicht. Aber ist wahrscheinlich das geringste \'fcbel von allen.\par
Aber wenn in der Foundation schon ein custom Instantiator gesetzt w\'e4re, k\'f6nnte der hier nicht verwendet werden, weil die Pseudo-Konstruktor Methoden statisch sind. Aber alles \'fcber eine Art "Builder" dr\'fcberschleifen w\'fcrde die Convenience zerst\'f6ren ... Alles Mist. Auf jeden Fall mal FIXME hinmachen.\par
Erst mal Feierabend und sp\'e4ter weitermachen.\par
\par
Sp\'e4ter:\par
DevLog nachtragen.\par
Und \'dcberlegung vom Weg zum Auto:\par
Das mit dem Custom Instantiator wird gar nicht so einfach. Wenn der direkt einige BinaryFields nutzen soll, muss man entweder den offset doch wieder manuell verwenden k\'f6nnen, oder es m\'fcssen doch wieder die tausend verschiedenen getter (aber immerhin ohne Setter) f\'fcr verschiedene Typen ins interface, die dann im falschen Fall nur mit runtime-check eine exception werfen.\par
Und wie bringt man die generische Logik dazu, diese Felder dann in #initializeState nicht nochmal zu verwenden? Hm, evtl. indem der Getter null ist. Das w\'fcrde gehen.\par
#canRead einbauen.\par
\par
Und bl\'f6d ist halt, dass es jetzt doch "Field_int" usw. anstatt nur \'fcberladen "Field" hei\'dfen muss, weil die Nachsicht des Compilers zwischen den primitives Mehrdeutigen erzeugt, wo eigentlich gar keine sind. Doof.\par
Aber mei, Convenience-m\'e4\'dfig ist es gar nicht so schlecht, den Primitive Type nochmal explizit dort zu haben.\par
Mal die aktuellen Compilerfehler weiter rausmachen ...\par
\par
Es gibts noch ein Problem, das eigentlich nur Schall und Rauch ist: Benamung.\par
Was bei TypeHandlern bisher "Custom" hei\'dft, ist eigentlich "Tailored" oder so. Und "Custom" w\'e4re dann "extends Tailored" und w\'fcrde den ganzen BinaryField Grusch enthalten.\par
Wenn ich den in die allgemeinere Klasse reinsteck, dann wird die \'fcberfrachtet mit allen m\'f6glichen Feldern, die im nicht-Custom-Tailored Fall null/0 sind. Sowas ist bl\'f6d. Unsaubere Abstraktion.\par
Aber sollt ich jetzt wirklich alles bisherige "Custom" umbenennen zu "Tailored"?\par
Das klingt irgendwie zu seltsam. Gibts da nix besseres...?\par
\par
\par
2020-01-08\par
\par
So. Im B\'fcro bin ich heute wieder mal nicht dazu gekommen, an meinem eigentlichen Thema zu arbeiten. Darum jetzt noch ein wenig.\par
Mir ist gestern abend beim Z\'e4hneputzen aufgefallen: Den Instantiator braucht man ja nur einmal pro Typ, nicht einmal pro BinaryField.\par
Den kriegt man schon irgendwie unter, evtl. on-demand versp\'e4tet gesetzt. Das wird kein Stress. Passt.\par
\par
Dann zur\'fcck zur Benamung.\par
Evtl. "~Specific~" anstatt "~Tailored~"?\par
\par
Also ich mach jetzt erst mal eine dumm benannte "Custom2" Klasse, um mal die Struktur weiterzubringen und mach mir \'fcber die Benamung sp\'e4ter Gedanken ...\par
\par
\par
2020-01-09\par
\par
Und wieder mal 0 dazugekommen vor lauter anderem Zeug, also mach ich jetzt noch bissl...\par
Erst mal wieder einlesen. Es ist echt nichts so einfach, an einem Thema immer nur kurz st\'fcckchenweise kurz vor Mitternacht zu arbeiten ...\par
\par
Fehlende Generics einf\'fcgen.\par
#initializeInstanceMembers Basisimplementierung und Implementierung f\'fcr BinaryFields.\par
\par
\par
2020-01-10\par
\par
Und wieder bissl weitermachen...\par
\par
\par
2020-01-13\par
\par
Wieder marginal weitermachen. Primitive und Reference fields cachen f\'fcr Verwendung in #create und #update/#initialize.\par
\par
Hm. Ne Moment: nicht primitive und reference, sondern: reference und non-reference.\par
Es gibt ja n\'e4mlich\par
- Primitive Fields\par
- Reference Fields\par
- list/complex Fields mit References\par
- list/complex Fields ohne References\par
\par
Und der Witz an der Unterscheidung ist: Wenn die Zahl der hasReference() fields 0 ist, dann ist der Typ ein ValueType, f\'fcr den updateState entsprechend validieren kann/muss anstatt updaten.\par
Muss ich gleich mal entsprechend verbessern.\par
\par
Oh. Problem:\par
Es gibt ja auch noch "hasInstanceReferences". Bl\'f6d ist: Das kann man bei CustomHandlern nicht ableiten. Denn: Es kann gut sein, dass ein BinaryField_int ein Reference Field der Instanz repr\'e4sentiert.\par
Man k\'f6nnte die Klasse direkt durchiteriere und nach Referenz-Feldern scannen, aber das killt irgendwie den Sinn von Custom Handlers: wer wei\'df, was der Autor des CustomHandlers mit den Referenzen seines Entity Typs anstellt? Sie k\'f6nnten einfach immer null bleiben oder aus primitive Werten erzeugt werden oder was auch immer.\par
Das Interessante an dem Thema ist: Die Methode PersistenceTypeHandler#hasInstanceReferences wird niemals verwendet. Sie ist nie n\'f6tig. Wahrscheinlich genau aus dem Grund, dass es f\'fcr die Persistierung nie relevant sein darf, ob eine Instanz Referenzen hat, sondern nur, wie man Instanzen in einen persistenten Zustand bringt.\par
Hei\'dft: Wahrscheinlich w\'e4re die beste L\'f6sung, die Methode einfach zu l\'f6schen. Die Alternative w\'e4re, f\'fcr eine \'fcberfl\'fcssige Methode den Entwickler mit der manuelles Vorgabe eines boolean Werts zu nerven...\par
Achja: es gibt aber auch noch #iterateInstanceReferences. Und die wird ... zwar 4 mal aufgerufen, aber 1 davon ist debug stuff. 2 sind nur wrapper. Und das letzte ist ... der registerer, der wiederum selbst eigentlich irrelevant ist.\par
HMMM...\par
Alles raus?\par
\par
\par
2020-01-15\par
\par
Wieder hier weitermachen.\par
Paar Compilerfehler schnell wegmachen.\par
\par
Achja: Die Frage "Alles raus?"\par
Also das einzige, was mich noch z\'f6gern l\'e4sst, ist: Was ist, wenn man doch mal dieses Registering braucht?\par
Hm. Eigentlich k\'f6nnte man das \'fcber die instanceMembers l\'f6sen.\par
Wobei das Problem hier wieder das gleiche ist: Wenn man an die instanceReference rankommen soll, kann es nicht ein einziger Getter sein, sondern dann m\'fcssen es zwei sein:\par
1.) Wert aus der Instanz holen\par
und\par
2.) Geholten Wert in persistente Form bringen.\par
Das verkompliziert aber die Definition eines BinaryFields und macht manche Konvertierungslogik schwierig bis unm\'f6glich, die mit einem einzelnen, monolithischen Getter ein Kinderspiel w\'e4re.\par
Also bleibt letztendlich so oder so, wie man es dreht: Wenn BinaryFields einfach machbar sein soll, kann es kein #iterateInstanceReferences geben.\par
\par
Oder Moment mal: Z\'e4hlen eigentlich nur die Instanz-Referenzen, die auch als Referenzen persistiert werden?\par
Sagen wir, eine Instanz zeigt auf einen String. Dieser String wird aber nie als Referenz auf eine echte String Instanz gespeichert, sondern als nested char sequence. "Z\'e4hlt" der String dann \'fcberhaupt als zu iterierende Instanz in einem Graph?\par
Die Natur dieses Strings ist ja, dass es eine internenes "unshared" reference ist.\par
Hm...\par
War das einfach ein Denkfehler von mir?\par
Dann also dich einfach alle reference members iterieren und fertig aus?\par
Hm. Ich glaube ja.\par
\par
Das w\'fcrde dann aber trotzdem hei\'dfen, dass die Methode #hasInstanceReferences \'fcberfl\'fcssig ist, wenn es #hasPersistedReferences schon gibt.\par
Es z\'e4hlen ja quasi nur die "persisted" (= "peristence-relevanten") Referenzen.\par
\par
Jetzt hab ich nur rum\'fcberlegt und nix programmiert, aber wichtige \'dcberlegungen. Muss ich morgen nochmal anschauen und dann refactoren.\par
\par
\par
2020-01-16\par
(eigentlich schon 2020-01-17 nach Mitternacht)\par
\par
Also dann l\'f6sch ich jetzt die #hasInstanceReferences weg und bau die iterate Methode auf persistierte Referenzen um.\par
Immerhin gehts bei einem PersistenceHandler ja schon irgendwie um genau die und nicht um alle Referenzen im allgemeinen, die irgendwo in einer Instanz rumflacken.\par
Und #iterateInstanceReferences  auch gleich implementieren.\par
\par
\par
2020-01-20\par
\par
Nach FirmentrennungsUmzug, Release und anderem Ged\'f6ns mal wieder weitermachen.\par
Wo war ich da eigentlich ...?\par
\par
\par
storeFields einf\'fcgen als performanceoptimierte Komplettliste mit korrekter Reihenfolge neben ref- und nonref-feldern.\par
Optimierung f\'fcr mitverwendete Arrays im reinen ref- oder nonref-Fall.\par
\par
initializationInvokingClass auskommentieren. Ich glaub, das braucht man nicht.\par
\par
Zwischendrin mal schnell Entwurf f\'fcr #store Implementierung einbauen.\par
\par
final PersistenceTypeInstantiator<Binary, T> instantiator \'fcbernehmen aus ~GenericType Implementierung.\par
\par
Hm. BinaryField Typisierung umstellen von <?> auf <T>. Dann werden an ein paar Stellen unsch\'f6ne suppressexceptions n\'f6tig.\par
Dabei aufgefallen: Ich k\'f6nnte bzw. muss ja mit field.getGenerticType() pr\'fcfen, ob das Field die passende Generics Typisierung hat. Auf der Reflection Ebene gibts die Informationen ja immerhin...\par
\par
Da passen die Initialisierungsmethoden noch nicht zusammen. Das sind verschiedene Konzepte, die mal zu einem konsolidiert werden m\'fcssen.\par
\par
Okay, wird schon langsam. Noch bissl konsolidieren, dann mit den generischen Mitteln die Instanz-handling-Methode implementieren, dann ist es fertig zum testen.\par
\par
\par
2020-01-21\par
\par
Mir ist eingefallen:\par
Falls man Wert eines BinaryFields direkt braucht, z.B. um sie an einen Konstruktor zu \'fcbergeben oder um davon was abzuleiten (z.B. eine Collection Instanz aus der persistierten Capacity), dann brauchen die BinaryFields ja doch Getter f\'fcr den Wert.\par
Und das hei\'dft: 8 primitives + 1 Reference.\par
Also muss ich doch solche redundanten Varianten machen. Aber immerhin nur 9 default methods mit jeweils UnsupportOperationException und dann nur je Implementierung eine Override Methode davon.\par
\par
Aufgefallen:\par
Wieso getter == null f\'fcr den #canRead Fall?\par
Aus der Instanz lesen muss man einen Wert doch immer k\'f6nnen. Aber in die Instanz setzen nicht (unbedingt), falls es ein reiner Initialisierungwert sein soll.\par
Also m\'fcsste doch eher der Setter null sein. Denn DER wird ja nur f\'fcr schon bestehende Instanz verwendet.\par
Und das #canRead m\'fcsste dementsprechend eher #canSet hei\'dfen.\par
\par
Die field Arrays m\'fcssen dementsprechend umgebaut werden.\par
\par
Damit endlich mal die ganzen state handling methoden implementieren.\par
\par
Hm: Sollte #update nicht validieren, falls es kein einziges canSet Feld gibt?\par
Damit k\'f6nnte man sich ganz einfach durch das weglassen der Setter einen value type definieren, der sogar voll generisch von der Handler Logik validiert werden w\'fcrde, konsistent zu den anderen value Type Handlern...\par
Das mach ich mal, das ist cool!\par
\par
So, fertig. War ja nicht viel Code.\par
\par
Jetzt mal das Initialisierungschaos konsolidieren ...\par
\par
Also es gibt:\par
\par
1.) #internalInitialize\par
Das wird aufgerufen vom allgemeinen PersistenceTypeHandler#initialize, wo eigentlich nur die TypeId gesetzt wird.\par
\par
2.) #initializeInstanceMembers\par
Das wird im "AbstractBinaryHandlerCustom" (Superklasse f\'fcr "tailored" Handlers mit noch altem Namen) on-demand im #instanceMembers aufgerufen.\par
Das w\'fcrde eigentlich schon vollkommen reichen.\par
\par
ALLERDINGS ist es so, dass es in AbstractBinaryHandlerCustom2 weitere Methoden gibt und die haben auch on-demand Initialisierungsbedarf, aber f\'fcr die binaryFields collection, nicht f\'fcr die Members.\par
Eine triviale L\'f6sung w\'e4re nat\'fcrlich, darin einmal this.instanceMembers() aufzurufen, um die Initialisierung zu garantieren.\par
Das ist aber hacky. Ohne Kommentar w\'fcrde das keiner verstehen und den Aufruf wegl\'f6schen. Das ist eigentlich ein klares Indiz f\'fcr schlechten Code.\par
Andererseits sollen alle internen Referenzen auf this.members nur in einer Methode stehen und nicht \'fcber 2 verteilt werden, etwa eine "#ensureInitializedMembers".\par
Hm. Oder ist das nicht der sehr viel kleinere "Preis", falls es denn \'fcberhaupt einer ist? Also gut, dann mach ich das so ...\par
\par
ODER ... w\'e4re es nicht doch geschickter, den Vererbungshook in initialize() zu verwenden?\par
Aber das Problem daran ist, dass das evtl. zu sp\'e4t aufgerufen wird. Ohne die on-demand initialisierung w\'e4ren so "~Custom2" TypeHandler bis zur Initialisierung in einem inkonsistenten Zustand. Das ist nat\'fcrlich ganz schlecht.\par
Also ne, Variante #1 ist nicht gut. Mach ich raus.\par
\par
Sch\'f6n. Dann ist das auch gel\'f6st.\par
Ich muss dann mal noch nach offenen TODOs suchen.\par
Achja und eine Convenience Methode bauen, die aus dem n\'f6tigsten Minimum an Vorgaben so eine Handler Klasse generisch erzeugt.\par
Dann kann ich testen.\par
\par
\par
23:00\par
Und weiter gehts.\par
TODOs checken.\par
\par
Ach, erst mal die WiP Handler Beispiele aufr\'e4umen. Endlich mal.\par
\par
Es muss noch eine M\'f6glichkeit geben, die BinaryFields direkt zu setzen. Das sind dann quasi gleich die Members f\'fcr die Superklasse.\par
Aber dann muss daraus noch die Map per Namen hergeleitet werden. Mit Validierung, dass der Name nicht null ist, weil ja keine Initialisierung per Reflection mehr m\'f6glich ist.\par
\par
\par
2020-01-22\par
\par
TODOs durchschauen und paar ausmisten.\par
\par
Ein neues machen f\'fcr unique identifier anstatt nur name.\par
Bzw. das mach ich jetzt gleich: das initialize Zeug muss qualifier und name handeln. Qualifier ist dann der full qualified class name des handlers. Ist bissl komisch, aber ist so.\par
Mal schauen, ob das sp\'e4ter beim TypeDictionary einlesen und LTM Probleme machen wird ...\par
Aber erst mal einbauen.\par
\par
Jetzt den GenericType check noch implementieren.\par
\par
Hmpf. Da muss ich eine kleine Testklasse zum erforschen bauen.\par
\par
Ist nat\'fcrlich alles wieder ein bisschen kompliziert:\par
Field#getGenericType gibt FAST immer ParameterizedType zur\'fcck. AUSSER der Typparameter wurde weggelassen, dann wird schwachsinnigerweise einfach der prim\'e4re Typ zur\'fcckgegeben.\par
JDK Idiotie live und in Farbe.\par
Also entsprechende Logik bauen.\par
\par
Au\'dferdem brauch ich noch eine XReflect#isActualClass(Class<?>), weil sie auch da wieder mal zu schwachsinnig bl\'f6d waren, eine gescheite Methode in Class reinzubauen.\par
\par
Jetzt noch #calculcateContentLength implementieren. Das w\'e4re dann das letzte TODO abgesehen von den Aufr\'e4um-Markern.\par
\par
Hm. Eigentlich muss es ja reichen, den offset des letzten felds minus den offset des ersten felds zu rechnen plus die bin\'e4rl\'e4nge des letzten felds.\par
Das berechne ich gleich beim analysieren und speicher den Wert im Handler.\par
Plus Sonderfall f\'fcr trailing variable length field.\par
\par
Dabei aufgefallen:\par
Eigentlich ist es nicht richtig, einfach nur zu validieren, ob wenn \'fcberhaupt, nur das letzte Feld ein variable length feld ist.\par
Denn was ist, wenn es zwar das letzte ist, aber dann leitet eine Klasse ab?\par
Der entsprechende Handler daf\'fcr leitet auch ab, f\'fcgt nur fixed length felder hinzu, aber das variable length Feld ist nicht mehr das letzte.\par
Und eigentlich spielt die exakte Deklarationsreihenfolge f\'fcr einen konkreten Typ ja keine Rolle. Der bekommt ja seine eigene, komplette TypeDescription.\par
Ist ja nicht so, dass die polymorpherweise alle Subtypen das gleiche Feldlayout haben m\'fcssen.\par
Besser w\'e4re:\par
Die Validierung stellt sicher, dass es h\'f6chstens ein variable length Feld gibt und DAS wird dann ans Ende der Collection geschoben.\par
Das mach ich jetzt gleich mit, weil wenn nicht, gibt es in der Zukunft garantiert mal einen Supportfall daf\'fcr und dann dauert es l\'e4nger, als wenn ich jetzt schnell noch eine stunde oder so investier...\par
\par
Achja, eine BinaryField#calculateBinaryLength brauch ich auch noch. Implementieren. F\'fcr jeden der 9 Basistypen als Methode mit konstantem Wert.\par
\par
\par
\par
2020-01-23\par
\par
Ups, bissl zu sp\'e4t dran. Das sollte eigentlich noch vor Mitternacht sein ...\par
\par
Also jetzt die Variable Length Analyse verbessern.\par
\par
Und dann die fixedContentLength Berechnung noch einbauen.\par
Fertig.\par
\par
Damit w\'e4ren es nur noch 2 TODOs:\par
Variable length Felder unterst\'fctzen (das fehlt n\'e4mlich erst mal noch) und die store~ Methoden wegmachen, falls sie nicht gebraucht werden.\par
Hm. Mal durchdenken: Macht es Sinn, die zu unterst\'fctzen?\par
Wann will/muss man f\'fcr eine Instanz einen Wert persistieren, den man nicht \'fcber einen Getter mit beliebiger Transformationslogik aus der Instanz holen kann?\par
Da f\'e4llt mir eigentlich nur eine komplexe Logik \'fcber mehrere Felder ein (z.B. Array zusammensammeln oder so), die man erst ausf\'fchren und dann Ergebnisse daraus nachgelagert als ein oder mehrere Werte persistieren will.\par
Hm. Aber was liefert der (immer pflichtm\'e4\'dfig vorhandene) Getter dann f\'fcr so ein Feld zur\'fcck? Einen Dummywert, der nachtr\'e4glich \'fcberschrieben wird?\par
Aber z.B. validateState benutzt den Getter ja auch ...\par
Das wird dann schon wieder alles recht haarig...\par
Und eigentlich sollte es so eine Felder\'fcbergreifende Logik gar nicht geben. Ein variable Length Feld, das relativ viel Logik treiben muss, bis der Wert gesetzt ist, ist okay. Aber warum sollte diese Logik dann noch ein anderes Feld setzen m\'fcssen?\par
So Sachen wie Capacity einer Collection zus\'e4tzlich zu der Size sollten trivial feststellbar sein, daf\'fcr braucht man keine \'fcbergreifende komplexe Logik...\par
Also ich l\'f6sch die store~ stubs jetzt mal raus. Falls man sie doch wieder braucht, sind sie ja generisch in ein paar Minuten wieder gebaut.\par
\par
So. Dann brauch ich morgen ("heute") noch so eine Util-Methode, um einen Handler generisch zu definineren, dann ist das Zeug fertig zum testen.\par
\par
\par
09:00 \par
\par
Ich test jetzt erst mal eine explizite Handler Klasse mit Reflection Analyse der Felder. Das war ja immerhin der Hauptteil der Implementierung.\par
Generisches Zusammendefinieren kommt dann sp\'e4ter.\par
\par
Testklassen designen:\par
- abstract basisklasse\par
- intermediate konkrete Klasse\par
- leaf konkrete Klasse\par
\par
- mit unsettable creation-felder in jeder ebene\par
- alle primitives\par
- Objektreferenz\par
- Objekte, die aber als primitives gespeichert und wieder daraus hergeleitet werden (Sinn von custom handlern, sonst br\'e4uchte man ja gleich keine)\par
\par
Dabei aufgefallen:\par
Es fehlt noch eine Varianet der Convenience "Field...(" Definitionsmethoden ohne Setter.\par
Nachr\'fcsten.\par
Und DABEI aufgefallen:\par
Die mayNull und notNull checks sind noch verdreht, als ich in meiner Umnachtung noch dachte, der Getter k\'f6nne null sein.\par
Fixen.\par
\par
Und aufgefallen:\line Es gibt noch immer kein m\'f6glichst einfachen Weg, einfach nur einen TypeHandler zu registrieren. Das execute Ding ist gut, wenn man den ArrayLengthController braucht, aber f\'fcr "normale" Handler geht das noch einfacher.\par
Einbauen.\par
\par
Testen testen.\par
NPE beim minimum length berechnen.\par
Achja, weil jetzt ja members nicht mehr garantiert non-null ist.\par
Entsprechend umbauen und in on-demand Initialisierung mit rein.\par
Testen.\par
Passt.\par
\par
N\'e4chster Fehler:\par
BinaryField with the unique identifier "[Uninitialized BinaryField]" is already registered.\par
Hm, warum dieses ...?\par
\par
Achja, jaja, weil die uninitialized Pr\'fcfung auf null testet anstatt auf den Dummynamen.\par
Fixen.\par
Testen.\par
\par
Oh, es l\'e4uft durch!\par
Mal den CSV Export anschauen.\par
Hm. Der BinaryHandler wurde nicht ber\'fccksichtigt. Seltsam.\par
\par
Ach! Naja gut, wenn ich den f\'fcr eine gar nicht verwendete Klasse nehm, dann kann der eigentlich n\'f6tige nat\'fcrlich nicht gefunden werden. M\'f6p.\par
\par
Richtiger Handler, aber wieder NPEs. Aber die kommen von meiner Testklassen Getterlogik, nicht vom Framework Code.\par
Fixen.\par
Testen.\par
\par
L\'e4uft durch, aber im Export sind die meisten Werte bullshit.\par
Hm, die Reihenfolge der Felder ist auch seltsam durcheinander. Das muss der Grund sein.\par
Und seltsam: Im TypeDictionary ist sie zwar auch anders (nur Deklarationsreihenfolge falsch gesammelt), aber der Export h\'e4lt sich nicht an diese dort definierte Reihenfolge. Das ist ja wirr.\par
\par
Also erst mal die Deklarationsreihenfolge fixen, dann nochmal laufen lassen und schauen, warum der Export was anderes treibt.\par
\par
Simpler Fix: nach dem Hiararchien abklappern die HashTable reversen, fertig.\par
Ich hatte das genau so konzipiert und dann das reverse vergessen. Haha. Aber mei, daf\'fcr gibts Tests.\par
\par
Wieder zum CSV Export:\par
Der einzige Unterschied ist, dass der die Reference Felder eigenm\'e4chtig nach vorne sortiert anstatt die TypeDictionary Reihenfolge zu verwenden. Das ist ja seltsam.\par
\par
Der Binary Export machts noch richtig.\par
Der CSV Converter ... aha. Der macht sich seine eigene Reihenfolge. Das ist ja ulkig... Und das ist bisher nie aufgefallen o_0.\par
Da mach ich jetzt ein Issue auf, um das zu dokumentieren.\par
\par
priv#211 erstellen, fixen, testen. Columns auch noch. Testen. Passt. Issue updaten und schlie\'dfen.\par
\par
Damit sieht die CSV Datei f\'fcr die BinaryField Testklasse korrekt aus.\par
\par
Jetzt Laden testen.\par
Hm... ne, Moment. Erst mal priv#212 erstellen und gleich umsetzen.\par
Das wird super!\par
\par
Fertig. Testen. Passt.\par
priv#212 updaten.\par
\par
So. dann w\'e4r jetzt noch offen:\par
- Laden testen\par
- "Custom2" Name \'e4ndern\par
- Generisch definierter Custom2 Handler. Besonders interessant in Kombination mit PersistenceTypeHandlerProviding :-D.\par
\par
\par
\par
2020-01-24\par
\par
Schon wieder zu sp\'e4t f\'fcr gestern ...\par
\par
Also jetzt Ladetest.\par
Aach, stop: Mir ist auf dem Heimweg was eingefallen:\par
Das PersistenceTypeHandlerProviding ist v\'f6llig \'fcberfl\'fcssig.\par
Man kann einfach jede neue Klasse nach so einer Methode durchchecken. Fertig aus. Die paar Mikrosekunden sind noch drin und es macht die Verwendung nochmal erheblich einfacher.\par
\par
So, rausgeworfen und getestet. Funktioniert nat\'fcrlich genauso.\par
Vielleicht gleich noch so ein Predicate mit rein bauen, auch wenn das momentan immer null ist.\par
\par
Aber jetzt: Ladetest.\par
Draufgedr\'fcckt. Debugger sagt: passt alles. \'d6h, fertig.\par
\par
Dann bau ich jetzt eine Utilmethode f\'fcr eine generische Definition eines "Custom2" Handlers. Und ich wei\'df immer noch nicht, wie ich das Ding nennen soll ...\par
Vor allem haben ja alle m\'f6glichen API Methoden schon den namen "CustomHandler" drin f\'fcr die bisherigen "native" Dinger. Hmpfl...\par
\par
Hm. Problem 1: In welche Klasse kommt die Methode rein? In "BinaryPersistence"? Das ist zwar eine zentrale, allgemeine Klasse, aber das checkt kein normaler Entwickler, weil die Klasse conveniencem\'e4\'dfig nicht vorkommt.\par
Vielleicht m\'fcsste es eine extra Klasse werden mit einem sprechenderen Namen.\par
\par
Problem 2: Die Field~ Methoden in AbstractBinaryHandlerCustom2 sind dann nat\'fcrlich nicht mehr sichtbar bzw. w\'e4ren als public auch nicht bequem verwendbar. Jedes mal "AbstractBinaryHandlerCustom2" davor hinschreiben ist Schei\'dfe.\par
Vielleicht direkt in BinaryField rein und dann nur noch als "_int" usw. Methoden? Aber wie nennt sich dann die Methode f\'fcr Referenzen? "Reference"?\par
Oder ich nehm f\'fcr Problem #1 auch BinaryField. Wieso nicht ...? K\'fcrzer wirds net.\par
Es sei denn, ich w\'fcrde alles in Binary reinklatschen. Sch\'f6n kurz und zentral, aber hat technisch dort drin nix verloren und bl\'e4ht die Klasse auf. Hm...\par
\par
Problem 3: Es muss dann f\'fcr jeden BinaryField Pseudo-Constructor nochmal eine Variante mit String name vorn dran geben.\par
Hm, oder, eigentlich k\'f6nnte man das recht h\'fcbsch trennen: die f\'fcr reflective Initialization sind ohne name in AbstractBinaryHandlerCustom2. Die f\'fcr explizite Definition sind dann in der anderen Klasse und sind mit Name. Das w\'e4r nicht schlecht.\par
\par
So. Umgebaut und konsolidiert auf benambare BinaryFields in Binary.\par
Morgen muss da noch die Utilmethode zum Handler definieren rein. Dann ist das generische Definieren auch fertig.\par
\par
\par
09:20\par
\par
Weiter gehts.\par
\par
Ganz simple und geniale Idee f\'fcr den "BinaryHandlerCustom2":\par
Einfach "CustomBinaryHandler".\par
Weil der andere hei\'dft ja "AbstractBinaryHandlerCustom" und sollte so gut wie unsichtbar sein.\par
Dann w\'e4r das schon mal erledigt.\par
\par
Jetzt noch Binary#TypeHandler Methoden bauen.\par
Mit Default Instantiator Logik.\par
\par
Beispiel zum testen bauen ...\par
Mal \'fcberlegen... was ist ein sehr simples, aber trotzdem nachvollziehbar sinnvolles Beispiel?\line Idee: Ein simples Entity, das 3 Value Type Object Werte hat, die man eigentlich genauso gut als Primitive speichern kann.\par
TypeHandler magic Methode daf\'fcr bauen.\par
MainKlasse mit Initialisierung.\par
Testen ...\par
Exception. Ah. Hm. Die generische Variante wird durch die Initialisierungslogik noch nicht abgedeckt. Das ist nat\'fcrlich richtig.\par
Nachr\'fcsten ...\par
\par
Testen. Passt.\par
\par
Aufgefallen:\line Eigentlich muss es BinaryField<? super T> hei\'dfen, weil ja ein in einer Superklasse schon definiertes BinaryField f\'fcr eine Subklasse auch anwendbar sein muss.\par
W\'e4re bl\'f6d, wenn man da Code redundant warten m\'fcsste, nur weil in der API ein "? super" fehlt.\par
Umbauen, zieht sich nat\'fcrlich quer durch den ganzen CustomTypeHandler.\par
Fertig.\par
Sollte durch Type Erasure keinen Unterschied machen, aber einfach nochmal testen.\par
\par
Okay.\par
Jetzt w\'e4r alles fix und fertig bis auf Support von variable length fields.\par
}
 