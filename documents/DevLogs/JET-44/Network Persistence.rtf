{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17134}\viewkind4\uc1 
\pard\sl276\slmult1\b\f0\fs28\lang7 Jetstream Network Persistence Entwicklertagebuch\par
\b0\par
2018-08-07\par
\par
Erst mal wieder in mehrere Jahre alten Network Code einlesen ...\par
\par
Es gibt einen NetworkConnectionServer.\par
Dazu gibt es zwei Factory Typen: sessionful und sessionless. Beide instanzieren letztendlich dieselbe Server Klasse, nur mit anderer Konfiguration.\par
Es gibt ein "NetworkConnectionServer.Implementation.Setup". Das sollte inzwischen wohl besser "Configuration" hei\'dfen.\par
Und es gibt ein "NetworkSessionServer.Implementation.Setup", das ein ConnectionServer~Setup kapselt und um Sessionanteile erweitert.\par
\par
Erst mal nur Sessionless:\par
\par
NetworkFactoryServerSessionless:\par
Braucht:\par
- NetworkConnectionSocket\par
- NetworkConnectionProcessor\par
Das erste definiert und wrappt einen Java nio ServerSocketChannel, der f\'fcr die Kommunikation verwendet wird. Klar.\par
Das zweite verarbeitet eine reinkommende Connection. Auch klar.\par
Bei Sessionless ist das direkt die custom Serverlogik, d.h. jede Connection l\'f6st die Logik aus und dann ist auch schon wieder Schluss. Code im Beispiel: Nachricht an den Client zur\'fcck-Echoen.\par
Bei Sessionful ist der Processor ein Standard-Bestandteil der API und validiert und erzeugt bei Erfolg eine Session.\par
\par
Der Rest der Factory sind optionale Werte:\par
- connectionListenerMaxThreadCount\par
- connectionListenerCheckInterval\par
- connectionProcessorMaxThreadCount\par
- connectionProcessorThreadTimeout\par
Standardm\'e4\'dfig 1, 1000, 1, 1000.\par
\par
Also es gibt 4 Dinger:\par
- NetworkConnectionSocket    \par
- NetworkConnectionListener\par
- NetworkConnectionHandler\par
- NetworkConnectionProcessor\par
\par
Socket ist klar, low-level Verbindung.\par
ConnectionListener lauscht in eigenen Threads nach neuen Connection\par
Processor ist auch klar, das ist die Logik, bzw. das Sessionregistrieren.\par
Was macht der ConnectionHandler?\par
\par
ConnectionHandler (defaultimplementierung) erzeugt intern einen ThreadManager, der selbst wiederum einen connectionProcessorProvider hat und zwei "Regulator" Instanzen, um Threadcount und Timeout dynamisch abfragen zu k\'f6nnen, d.h. im simpelsten Fall sind das einfach nur gewrappte ints. Der connectionProcessorProvider ist auch klar: Der liefert bei bedarf einen connectionProcessor. Im trivialen Fall (z.B. Sessionless) gibt der einfach nur die Referenz auf eine singleton ConnectionProcessor Logik zur\'fcck. Im Sessionfall einen "NetworkUserSessionConnectionRegisterer", der die Registrierung macht.\par
\par
Ok. Also die Factory erzeugt mit so einem Setup eine Serverinstanz und in der Beispiel Main wird danach active() aufgerufen. Das sollte besser start() hei\'dfen.\par
\par
Das NetworkConnectionServer#activate() macht intern im Wesentlichen:\par
this.connectionManager.activate()\par
Das macht wiederum:\par
ListenerController (extends Thread) instanzieren und starten.\par
Der macht in seinem run() nur:\par
Zahl der Listener via Regulator checken und entsprechend erh\'f6hen oder reduzieren, danach ein Interval lang schlafen.\par
Listener erh\'f6hen:\par
Neue ListenerThread (extends Thread und nested in NetworkConnectionManager) Instanz erzeugen, registrieren und starten.\par
\par
ListenerThread#run macht:\par
vom \'fcbergeordneten NetworkConnectionManager provideConnectionListener() aufrufen.\par
\par
Das macht wiederum:\par
NetworkConnectionListener Instanz (bisher anscheinend immer) erzeugen und dann zur\'fcckgeben.\par
\par
NetworkConnectionListener#run macht (mit Exceptionhandling und blabla au\'dfen rum):\par
SocketChannel newConnection = this.connectionSocket.acceptConnection()\par
this.connectionHandler.handleConnection(newConnection)\par
\par
connectionHandler#handleConnection macht eben wie schon recherchiert:\par
connection an den threadmanager \'fcbergeben, der holt sich intern vom connectionProcessorProvider eine connectionProcessor Instanz. Im trivialen Fall ist das die Logik selbst.\par
\par
Also soweit fertig analysiert:\par
- Server wird zusammengebaut mit custom Socket, custom processing Logik und defaults f\'fcr thread management.\par
- Connection listening erfolgt gemanaget mit einer dynamischen Anzahl an dedicated Threads.\par
- Die Threads lauschen mit acceptConnection nach neuen Verbindungen und leiten eine solche an die processor Logik weiter.\par
- Im einfachsten Fall (Beispiel) echot die die Nachricht an den Client zur\'fcck und die Connection ist erledigt.\par
- Au\'dfen rum viel Threadmanagement und Exception Handling Logik rum, damit man das nicht jedes mal selber bzw neu schreiben muss.\par
\par
\par
Der Sessionless Client ist im Vergleich relativ krude, ohne sch\'f6ne Kapselung:\par
\par
Per LogicSimpleNetwork#openRemoteChannel Utilmethode wird ein SocketChannel ge\'f6ffnet.\par
Per LogicSimpleNetwork#communicate wird ein String geschickt.\par
Die echoRequest Logik im Server ruft LogicSimpleNetwork#readString und danach LogicSimpleNetwork#sendString auf.\par
\par
\par
Jetzt auf zum dar\'fcberliegenden "network.binary.persistence" Framework:\par
\par
BinaryMessageProcessor kennt einen PersistenceBuilder<M>. Das ist die Verbindung zum Persistence Framework.\par
\par
Hm. Aber recht viel mehr ist da nicht.\par
Ein paar Verbindungen zu sessionful network Zeug. Ansonsten nur Utilmethoden, die nie aufgerufen werden und Interfaces, die nirgends implementiert werden.\par
Da ist auch requesthandling mit request IDs und sowas drin.\par
\par
Das ist alles sehr wenig und sehr anf\'e4nglich:\par
- Es hei\'dft binary.persistence, verwendet aber nur Persistence~<M> Code mit beliebigem Medium.\par
- Es ist an sessionful Code gebunden, obwohl die Verwendung eines Persistence Frameworks doch auch ohne Session m\'f6glich sein sollte (oder?)\par
- Code Kommentare sind von 2012. Das ist 6 Jahre her ^^. Da war das Persistence Zeug alles noch extrem in den Kinderschuhen.\par
\par
Hm. Ich h\'e4tte schw\'f6ren k\'f6nnen, schon mal eine Beispiel Main auch mit der Binary Persistence gehabt zu haben, aber davon find ich nix mehr, auch kein Framework.\par
\par
\par
Die Frage ist nun:\par
Zumindest der Network Code sieht schon ganz sinnvoll aus mit dem Wrapping des ganzen Overhead Codes.\par
Aber ist es hilfreich, den f\'fcr eine simple Demo \'fcberhaupt zu verwenden?\par
\par
Eigentlich reicht ja:\par
- Client Main macht einen nio SocketChannel auf.\par
- Client Server listened hardcoded und singlethreaded nach einer Connection.\par
- Wenn eine Connection reinkommt, wird die (irgendwie gewrappt) als PersistenceSource verwendet und ausgelesen.\par
- Der Client verwendet seinen SocketChannel (auch gewrappt) als PersistenceTarget und schreibt da rein.\par
\par
Das ganze muss nat\'fcrlich bidirektional sein: Der Server muss auch senden und der Client auch empfangen k\'f6nnen.\par
Das hei\'dft beide m\'fcssen den SocketChannel eigentlich \'e4hnlich wie bei der Storage als "Connection" wrappen, die Source und Target zugleich ist.\par
In StorageConnection ist das der PersistenceManager, der PersistenceRetrieving und PersistenceStoring ist und entsprechende Source und Target kennt.\par
\par
Das hei\'dft analog wie die StorageConnection m\'fcsste die NetworkConnection ein Wrapper f\'fcr einen PersistenceManager<Binary> sein, der intern den Socket als Source und Target wrappt und drum rum die ganze SwizzlingRegistry und TypeHandling Logik rumbaut.\par
\par
Anmerkung:\par
Ber StorageRequestAcceptor in der StorageConnection ist nur eine parellele Referenz auf ein vom PersistenceManager gerwrapptes Bestandteil, damit die Connection direkt Util-Requests an die Storage schicken kann. Prinzipiell, bzw. ohne Util-Requests, braucht man sowas nicht, also kann das bei der NetworkConnection entfallen.\par
Hm. Oder noch einfach (f\'fcr den Anfang): man braucht nur einen PersistenceManager direkt. Alles, was den von einem File PersistenceManager unterscheidet, ist, dass er statt einem FileChannel einen SocketChannel als Source und Target hat.\par
So sollte/muss das Framework ja auch funktionieren: man schreibt nur eine Anbindung f\'fcr ein Source und Target und der Rest ist sauber wegabstrahiert.\par
\par
Das sollte eigentlich so trivial sein wie die existierenden BinaryFileTarget und BinaryFileSource Implementierungen sein. \par
\par
\par
Ca. 1,0h f\'fcr Network und Network Binary Persistence Recherche, Recherche und Konzept f\'fcr simples Network Target und Source.\par
\par
\par
\par
2018-08-08\par
\par
21:30\par
Erst mal ordentliches Projekt "Jadoth Network Persistence" anlegen.\par
Das "Binary Persistence" kann dann gel\'f6scht bzw. gr\'f6\'dftenteils neu gebaut werden.\par
Und schon gibts das erste Problem: Daraus ein Maven Projekt machen ist alles andere als intuitiv. Nirgends eine Option, ein Java Projekt zu einem Maven Projekt zu konvetieren. Schauen, ob man ein Maven Projekt direkt anlegen kann. Ja, geht. Also l\'f6schen und als Maven Projekt neu anlegen. "Group Id". "Artifact Id". Alles Pflichtfelder, aber keine Ahnung, was da rein muss. Keine Hilfe, Vorschlagswerte sind leer (da k\'f6nnte man ja bestehende anzeigen).\par
=> Wieder mal Dreckskonzept, mit dem ich mich jetzt nicht ewig rumschlage.\par
Also wieder Maven Projekt l\'f6schen und normales Java Projekt mit normalen Projektabh\'e4ngigkeiten anlegen. Soll jemand mit magischem Maven Wissen in der Arbeit dann konvertieren.\par
\par
NetworkPersistenceConnection anlegen.\par
\par
\par
Gleich im Persistence Framework einen neuen Kombi-Typ PersistenceChannel (Target+Source) anlegen. Als Konsequenz bisherige Doppelimplementierungen konsolidieren. Interessant: In den Factories gibt es sowas eh schon, aber implizit definiert \'fcber doppel-Bound-Generics. #setPersistenceStorage. Vereinfachen zu #setPersistenceChannel.\par
\par
NetworkPersistenceConnection umbenennen zu NetworkPersistenceChannel. Das "Channel" hat nichts mit dem zu verwendenden SocketChannel zu tun, sondern ist allgemein gemeint. Siehe oben. Eher im Sinn "Einen Kanal \'f6ffnen", so wie bei Funkkommunikation oder allgemein einfach ein Kanel, durch den hin und zur\'fcck Daten flie\'dfen. Dass der NetworkChannel dann einen SocketChannel wrapt, passt zuf\'e4llig ganz gut.\par
\par
PersistenceSource#readInitial refactoren zu PersistenceSource#read und JavaDoc aktualisieren.\par
\par
Nachdenken \'fcber NetworkPersistenceConnection#readByObjectIds. Macht grunds\'e4tzliuch schon Sinn, aber erstmal weglassen. Entsprechenden Kommentar schreiben.\par
\par
NetworkPersistenceChannel muss abstract werden.\par
Es muss dann noch einen NetworkPersistenceChannelBinary mit konkreter Implementierung geben.\par
\par
Hm.\par
In PersistenceSource fehlt noch ein #prepareSource und #closeSource.\par
Analog in PersistenceTarget.\par
Gut, dass es default methods gibts. Damit ist es ein Klacks, das abw\'e4rtskompatibel zu machen.\par
\par
\par
Jetzt NetworkPersistenceChannelBinary implementieren.\par
Struktur fertig. Jetzt ist die Frage, wie man aus einem SocketChannel ein bis mehrere Binary rauszieht.\par
Das m\'fcsste analog zur simplen File Implementierung gehen. Mal checken.\par
\par
Ca. 1,0h f\'fcr Maven \'c4rger, Projekte und Strukturen anlegen, bestehende Typen leicht refactoren und NetworkPersistenceChannelBinary implementieren. \'dcberlegungen zu Daten lesen mit unbekannter L\'e4nge.\par
\par
\par
\par
2018-08-10 20:15\par
\par
PersistenceSource Implementierung f\'fcr simples File anschauen und f\'fcr SocketChannel \'fcbernehmen.\par
\par
Hm ...\par
Bei einer Netzwerkverbindung wei\'df man vorher nicht, wie viele Bytes der schicken wird. Also m\'fcsste ich entweder die Struktur der persistierten Daten erweitern ("Ein Haufen Bytes muss am Anfang immer eine Angabe \'fcber die L\'e4nge haben") oder eine bissl komplizierte zusammenst\'fcckel-Logik bauen. Aber f\'fcr ein simples Beispiel mach ich jetzt einfach mal einen gro\'dfz\'fcgigen Puffer, in den alle Daten auf einmal reingehen. Plus TODO daneben hin.\par
Etwas weiter daran rum\'fcberlegt: letztendlich muss es die "Zusammenst\'fcckel-Logik" werden, weil das flexibler ist, als zus\'e4tzliche Metadaten zu verlangen, auf die man bei einer anderen Strategie verzichten k\'f6nnte.\par
\par
Das wird aber bissl komplizierter:\par
- Anfangen mit nur einem ChunksBuffer, okay.\par
- Sobald der voll ist, den n\'e4chsten anlegen und immer so weiter, bis keine Bytes mehr \'fcber den Socket reinsprudeln.\par
- Beim durchiterieren der Bytes gibts dann verschiedene eklige Sonderf\'e4lle:\par
1.) am Ende eines Buffers ist ein Entity unvollst\'e4ndig enthalten.\par
2.) am Ende eines Buffers ist das length header field eines Entities unvollst\'e4ndig enthalten.\par
Beide F\'e4lle m\'fcssen so gel\'f6st werden:\par
Falls so ein Fall festgestellt wird, muss ein zus\'e4tzlicher ChunksBuffer erzeugt werden, der "dazwischengeschoben" wird.\par
In den wird der Restteil aus dem aktuellen ChunksBuffer kopiert.\par
Im Fall 1 wird dann der Rest des zerteilten Entities dazukopiert, so dass das Entity wieder komplett ist.\par
Im Fall 2 wird der Rest des Length Headers dazukopiert. Dann kann \'fcberhaupt erst geschaut werden, wie lang das Entity ist. Falls der dazwischengeschobene ChunksBuffer zu klein sein sollte, muss nochmal ein neues angelegt werden und nochmal umkopiert werden, damit das entity letztendlich komplett enthalten sein kann.\par
Der regul\'e4r folgende ChunksBuffer braucht einen Offset, damit die zusammenkopierten Daten an seinem Anfang nicht nochmal gelesen und f\'e4lschlicherweise als ganzes Entity interpretiert werden.\par
\par
Performancetechnisch ist das alles kein Problem: Es geht nur um ein einzelnes Entity und der ganz eklige Fall 2 sollte relativ selten sein. Aber das wird relativ viel Code. Bissl bl\'f6d.\par
\par
Aber erst mal die triviale L\'f6sung mit dem gro\'dfen Puffer und TODO daneben.\par
\par
\par
Implementieren am Beispiel von Klasse BinaryFileSource.\par
\par
Dabei gleich mal die Methoden BinaryPersistence#fillBuffer und BinaryPersistence#readChunkLength nach BinaryFileSource verschieben, weil die von inszwischen falschen Annahmen (jeder Chunk beginnt mit einem Chunk Length Header) ausgehen.\par
Solche Methoden d\'fcrfen nicht in einer allgemeinen, noch aktuellen Klasse sein.\par
\par
\par
Hm. Das ist gar nicht so einfach: Muss bei Netzwerk-Kommunikation evtl. doch ein Chunk Length Header mitgeschickt werden, weil der Empf\'e4nger sonst nie wei\'df, wie viele Bytes noch kommen werden, ob er bei einer Pause abbrechen soll, usw.\par
\par
Also w\'e4re die Strategie so:\par
Der Channel h\'e4lt sich einen Header Buffer. Ist im Moment nur 8 bytes lang, aber evtl. wird der Header mal gr\'f6\'dfer (Endiness, Version, usw.). Dann muss man nur einmal zentral den Header Buffer erweitern.\par
Der wird immer voll gemacht. Wenn der nicht voll wird (innerhalb eines bestimmten Timeouts), dann ist die Verbindung abgebrochen und es wird resettet und eine Exception geworfen.\par
Wenn er voll ist, wird die L\'e4nge des Chunks ausgelesen.\par
\par
Dann wird der aktuelle Buffer auf diese Gr\'f6\'dfe gesetzt oder, falls n\'f6tig, ein gr\'f6\'dferer allokiert. Mehrere kleine Buffers hintereinanderschalten w\'e4re hier nicht sinnvoll, weil sowieso der komplette Chunk auf einmal eingelesen werden muss und mehrere kleine machen nur mehr Overhead. Dann lieber gleich einen exakt ausreichend gro\'dfen allokieren und (mit timeout) volllaufen lassen.\par
\par
\par
Implementieren am Beispiel von Klasse BinaryFileSource.\par
\par
Dabei gleich mal die Methoden BinaryPersistence#fillBuffer und BinaryPersistence#readChunkLength nach BinaryFileSource verschieben, weil die von inszwischen falschen Annahmen (jeder Chunk beginnt mit einem Chunk Length Header) ausgehen.\par
Solche Methoden d\'fcrfen nicht in einer allgemeinen, noch aktuellen Klasse sein.\par
\par
\par
Hm. Das ist gar nicht so einfach: Muss bei Netzwerk-Kommunikation evtl. doch ein Chunk Length Header mitgeschickt werden, weil der Empf\'e4nger sonst nie wei\'df, wie viele Bytes noch kommen werden, ob er bei einer Pause abbrechen soll, usw.\par
\par
Also w\'e4re die Strategie so:\par
Der Channel h\'e4lt sich einen Header Buffer. Ist im Moment nur 8 bytes lang, aber evtl. wird der Header mal gr\'f6\'dfer (Endiness, Version, usw.). Dann muss man nur einmal zentral den Header Buffer erweitern.\par
Der wird immer voll gemacht. Wenn der nicht voll wird (innerhalb eines bestimmten Timeouts), dann ist die Verbindung abgebrochen und es wird resettet und eine Exception geworfen.\par
Wenn er voll ist, wird die L\'e4nge des Chunks ausgelesen.\par
\par
Dann wird der aktuelle Buffer auf diese Gr\'f6\'dfe gesetzt oder, falls n\'f6tig, ein gr\'f6\'dferer allokiert. Mehrere kleine Buffers hintereinanderschalten w\'e4re hier nicht sinnvoll, weil sowieso der komplette Chunk auf einmal eingelesen werden muss und mehrere kleine machen nur mehr Overhead. Dann lieber gleich einen exakt ausreichend gro\'dfen allokieren und (mit timeout) volllaufen lassen.\par
\par
Das analog dazu passende Schreiben ist relativ einfach:\par
Erst alle ChunksBuffer f\'fcllen wie gehabt, dann einen zus\'e4tzlichen voranstellen, der den korrekten Header enth\'e4lt und dann alle abschicken.\par
\par
Das muss dann aber doch gleich jetzt so implementiert werden, weil sonst nicht festgestellt werden kann, wann ein read komplett ist.\par
Es ist halt alles immer komplizierter als zun\'e4chst gedacht.\par
Positiv ist immerhin: Viel Logik (bzw. Denkarbeit) von LogicSimpleNetwork kann da gleich verwendet werden. Das hilft.\par
\par
\par
\par
\'dcberlegungen und Code TODO zu komplexerem NetworkTimeoutEvaluator. Aber einstweilen lass ich den simplen int.\par
\par
Implementierung #readFromSocketChannel ...\par
\par
Chunks interface durchschauen, bissl refactoren und mit Kommentaren versehen.\par
Das Zeug ist auch schon ganz sch\'f6n alt... ^^\par
\par
\par
2,5 h f\'fcr Netzwerk\'fcbertragung Konzept\'fcberlegungen (Terminierung, Timeout). Einlesen in und geringf\'fcgiges Refactoring von bestehendem Code (LogicSimpleNetwork, Chunks), Implementierung #readFromSocketChannel.\par
\par
\par
\par
\par
2018-08-11 22:00\par
\par
Jetzt write implementieren:\par
Plan ist wie gehabt:\par
- Gesamtl\'e4nge der Daten in allen Chunks summieren\par
- Ermittelte Gesamtl\'e4nge in einem vorangestellten Header ByteBuffer zuerst schicken\par
- Dann den eigentlichen ByteBuffer Inhalt hinterherschicken.\par
\par
Die Gesamtl\'e4nge eines Chunks kann in diesem beim Beschreiben gleich mitgef\'fchrt werden, so dass man sp\'e4ter nicht nochmal per Schleife dr\'fcber muss. Hm. Interessant ist, wie das beim Storage write ermittelt wird. Mal nachschauen ...\par
Ah. Das wird mit "chunksTotalLength()" tats\'e4chlich manuell aufaddiert. Das ersetz ich auch dort durch die on-the-fly Strategie. Das ist besser.\par
Hm. Da wird nur das ByteBuffer[] anstatt dem original Chunks \'fcbergeben. Warum ...?\par
Warum gibt StorageChannel#storeEntities ein KeyValue<ByteBuffer[], long[]> zur\'fcck?\par
Hm. Das verwendet StorageEntityCache#internalPutEntities tats\'e4chlich zum Entities updaten. Das k\'f6nnte auch ohne Arrayumweg mit einer mitsummierten ChunkPosition gel\'f6st werden, aber gut. Jetzt ist das halt so.\par
\par
Hm. Trotzdem mal ein TODO schreiben. Code Vereinfachung ist immer gut.\par
\par
Aber zur\'fcck zum Network Demo ...\par
\par
Hm. Es gibt von #flushBuffer (in NetworkPersistenceBinary bzw. fr\'fcher in LogicSimpleNetwork noch gar keine allgemeine Verwendung. Das String Senden z\'e4hlt nicht). Aber gibt eigentlich keinen Grund, die Methode nicht gleich direkt public zu machen. Am besten mit besserem Namen bzw. analog dazu auch gleich mit umbenanntem und public gemachtem #fillBuffer.\par
\par
Hm. Bl\'f6d: write() kriegt ein array, das aber eigentlich gar keins ist, weil das f\'fcr das Storage Channel Hashing ben\'f6tigt wird. \'dcberlegen. Gibt auf die Schnelle keine einfache L\'f6sung. Provisorische L\'f6sung: in Network Kommunikation auf chunks.length == 1 pr\'fcfen und ansonsten exception werfen.\par
\par
\par
Chunks#totalLength implementieren.\par
Dabei recherchieren, ob ChunksWrapper \'fcberhaupt nocht gebraucht wird.\par
Hm. Irgendwie nur in den veralteten BinaryFile- und Network-Klassen. Aber ich verwend den mal in dem neuen Network Zeug auch. Kann man sp\'e4ter ja mal rausrefactoren.\par
Dabei gleich mal aufgefallen: der ByteBuffer.flip() Aufruf im Network read ist falsch, weil position erhalten bleiben muss. Gleich mal einen Bug weniger beim Testen. Fein.\par
\par
Mit dieser Methode ist das eigentliche ChunkHeader schreiben trivial:\par
NetworkPersistenceBinary.setNetworkChunkHeaderContentLength(defaultBuffer, chunk.totalLength());\par
Okay, nicht ganz trivial: defaultBuffer.limit(NetworkPersistenceBinary.networkChunkHeaderLength()) fehlte noch.\par
Note hinschreiben, dass das alles besser gekapselt werden m\'fcsste.\par
\par
Und damit w\'e4r die write Methode fertig.\par
\par
2,0 h f\'fcr Recherchen zu bisheriger Verwendung von Chunks Typ und dessen Metadaten, Kommentare f\'fcr empfehlenswerte Codeverbesserungen, Chunks Metadaten Erweiterung, write Logik implementiert, kleiner Bugfix in read Logik.\par
\par
\par
\par
2018-08-12 21:30\par
\par
Main-Klassen f\'fcr Server und Client bauen.\par
Ich schau einfach mal in das MainTestSessionlessServer Beispiel rein und kopier den Code von dort raus.\par
\par
BufferSizeProvider aufsplitten in einfachen BufferSizeProvider und BufferSizeProviderIncremental.\par
Anpassen an Java 8 Features.\par
\par
\par
22:15 Pause\par
\par
22:45 Weiter gehts.\par
\par
Server und Client Main Test Klassen gebaut.\par
Gemeinsame Logik in Util Klasse verschoben. Dann sehen die Main Klassen selbst gleich sehr klein und aufger\'e4umt auf.\par
Erkl\'e4rende Kommentare hinzugef\'fcgt.\par
Paar kleinere Aufr\'e4umarbeiten.\par
\par
\par
1,25 h f\'fcr Server und Client Main Test Klassen und geringf\'fcgiges Refactoring.\par
\par
\par
\par
2018-08-13 20:15\par
\par
Test und Bugfixes.\par
\par
Exception: Missing assembly part of type interface net.jadoth.swizzling.types.SwizzleTypeIdProvider. null\par
Achja, klar: PeristenceManager allein bauen reicht ja nicht. Da fehlt noch einiges an Metadaten Zeug, wie z.B. in EmbeddedStorageFoundation#createEmbeddedStorageManager.\par
Anschauen und nachziehen.\par
\par
Hm. Wobei: Die ganze Storage-Specials wie Root-Handling, TypeDictionary-Verbandelung, usw. braucht man ja f\'fcr Netzwerkkommunikation nicht. Und der SwizzleTypeIdProvider wird hier gar nicht gesetzt. Das ist die falsche Stelle.\par
\par
EmbeddedStorage#createConnectionFoundation ist die richtige Stelle.\par
Die ConnectionFoundation ist nichts anderes als eine BinaryPersistenceFoundation mit bissl Erweiterung.\par
Von dort kopieren.\par
\par
Hm. Das sollte erst mal so klappen, w\'e4re aber unbrauchbar f\'fcr einen Produktivbetrieb.\par
Mal "Beschr\'e4nkungen / TODOs / bekannte Probleme" aufschreiben.\par
\par
Noch default system directory definieren. Directory ensuren. Blabla.\par
\par
Und schwups: Schon gehts. \\o/\par
\par
Paar debug-outs dazubauen. So sieht das dann aus:\par
\par
.run(MainTestNetworkPersistenceServer.java:25)                  21:18:36.132> Server awaiting connection ...\par
.run(MainTestNetworkPersistenceServer.java:27)                  21:18:36.132> Server accepted connection. Processing.\par
.processNextRequest(MainTestNetworkPersistenceServer.java:35)   21:18:36.132> Server initializing PersistenceManager\par
.processNextRequest(MainTestNetworkPersistenceServer.java:39)   21:18:36.136> Server is reading data ...\par
.processNextRequest(MainTestNetworkPersistenceServer.java:43)   21:18:36.337> Server is processing graph ...\par
Request 1534187909821:27\par
.run(MainTestNetworkPersistenceServer.java:25)                  21:18:36.338> Server awaiting connection ...\par
.run(MainTestNetworkPersistenceServer.java:27)                  21:18:36.338> Server accepted connection. Processing.\par
.processNextRequest(MainTestNetworkPersistenceServer.java:35)   21:18:36.339> Server initializing PersistenceManager\par
.processNextRequest(MainTestNetworkPersistenceServer.java:39)   21:18:36.343> Server is reading data ...\par
.processNextRequest(MainTestNetworkPersistenceServer.java:43)   21:18:36.543> Server is processing graph ...\par
Request 1534187909821:28\par
\par
\par
.main(MainTestNetworkPersistenceClient.java:23)                 21:18:36.131> Client opens channel ...\par
.main(MainTestNetworkPersistenceClient.java:26)                 21:18:36.132> Client opened channel. Sleeping ...\par
.main(MainTestNetworkPersistenceClient.java:29)                 21:18:36.332> Client initializing PersistenceManager\par
.main(MainTestNetworkPersistenceClient.java:32)                 21:18:36.336> Client sending data ... \par
.main(MainTestNetworkPersistenceClient.java:34)                 21:18:36.337> Client sent data.\par
.main(MainTestNetworkPersistenceClient.java:23)                 21:18:36.338> Client opens channel ...\par
.main(MainTestNetworkPersistenceClient.java:26)                 21:18:36.338> Client opened channel. Sleeping ...\par
.main(MainTestNetworkPersistenceClient.java:29)                 21:18:36.538> Client initializing PersistenceManager\par
.main(MainTestNetworkPersistenceClient.java:32)                 21:18:36.542> Client sending data ... \par
.main(MainTestNetworkPersistenceClient.java:34)                 21:18:36.544> Client sent data.\par
\par
\par
\par
TODOs:\par
v eigene Verzeichnisse f\'fcr Server und Client\par
v Server muss auch zur\'fccksenden k\'f6nnen\par
v Beispiel mit komplexerem Graph als nur einem String\par
v ComChannel Wrapper f\'fcr H\'fcbschness.\par
\par
21:30 Pause\par
\par
23:30 Weiter gehts. TODOs umsetzen.\par
Siehe "v"s oben.\par
\par
So. Dann w\'e4r das soweit fertig. Das Framework sind im Wesentlichen 200 LoC.\par
\par
\par
1,75 h f\'fcr Test, Bugfixes, Debugausgaben, Notieren von Beschr\'e4nkungen, Beispiele verbessern.\par
\par
\par
\par
2018-08-14\par
\par
08:30\par
Erkl\'e4rungen in WhatsApp f\'fcr MK\par
\par
08:45 Pause\par
\par
13:30\par
Koordination in WhatsApp mit MK\par
Veralteten Code l\'f6schen und committen f\'fcr bessere \'dcbersicht.\par
\par
13:45 Pause\par
\par
\par
17:15\par
Confluence Seite "Jetstream f\'fcr Netzwerkkommunikation" schreiben.\par
{{\field{\*\fldinst{HYPERLINK https://www.xdevcollaboration.com/pages/viewpage.action?pageId=51380761 }}{\fldrslt{https://www.xdevcollaboration.com/pages/viewpage.action?pageId=51380761\ul0\cf0}}}}\f0\fs28\par
\par
18:30\par
Kontrolllesen und Fehler korrigieren.\par
18:45 Feierabend\par
\par
\par
2,00 h f\'fcr Kommunikation und Confluence Artikel\par
\par
\par
2018-08-16\par
\par
0,25 h f\'fcr Konzept\'fcberlegungen und Confluence Kommentar.\par
\par
\par
\par
2018-08-17\par
\par
Failing TypeIdProvider bauen und TransientOidProvider f\'fcr Netzwerk Temp-Ids verwenden.\par
\par
Passende ID-Ranges \'fcberlegen.\par
Test, Fixes/Anpassungen f\'fcr Failing TypeIdProvider. Kommentare.\par
\par
Kommentar "\'dcberlegungen zum Typedefinition Problem" zu Confluence Artikel schreiben.\par
\par
1,50 h f\'fcr neue ID-Provider Strategie, Confluence Kommentar. Issue JET-42 Update.\par
\par
\par
\par
2018-08-18\par
\par
\'dcberlegungen zu Communication Metadaten und JET-43 Erstellung.\par
\par
1,0 h f\'fcr Communication Metadaten Konzept. JET-43 Erstellung.\par
\par
\par
2018-08-19\par
\par
\'dcberlegungen zu ID-Strategy Konzept Verbesserung und JET-43 Update.\par
\par
0,5 h f\'fcr Konzept \'dcberlegungen und Issue JET-43 Update.\par
\par
\par
2018-08-20\par
\par
0,75 h f\'fcr: Im Confluence Hinweise zu Klassen iterieren und UUIDs lesen, kurz recherchieren, Antwort zu UUIDs schreiben.\par
\par
\par
2018-08-21\par
0,25 h f\'fcr Confluence und JET-43 Updates.\par
\par
\par
2018-08-28\par
\par
14:15 Besprechungstermin im B\'fcro \par
16:15 Ende.\par
\par
2h f\'fcr Besprechungen zu Jetstream und zuk\'fcnftige JDK Kosten.\par
\par
\par
\par
2018-10-29\par
\par
Epic (JET-44) und Issues f\'fcr n\'f6tige Arbeiten anlegen.\par
\par
\'dcbersicht n\'f6tige Arbeiten / Issues:\par
- JET-43: Handshake f\'fcr Type Dictionary Abgleich, Endianess Abgleich, Protokollname und Versionsnummer\par
- Disjunkte OID Ranges managen\par
- Type Dictionary Abgleich zu Beginn\par
- Dynamische Typanalyse unterbinden, stattdessen Exception bei unbekanntem Typ.\par
- Varianten f\'fcr stateful und stateless communication, was die SwizzleRegistry angeht.\par
- Endianess Konvertierung\par
- Einfache Plugin-M\'f6glichkeit f\'fcr Ver- und Entschl\'fcsselung\par
\par
\par
2018-10-30\par
Issues Beschreibungen nachtragen.\par
\par
JET-43 anfangen.\par
Erst mal wieder in Beispielcode einlesen.\par
\par
Zun\'e4chst mal muss da eine richtige Infrastruktur gebaut werden. Momentan sind das ja nur Utilmethoden, die ein File als Directory \'fcbergeben bekommen, um das Proof-of-Concept Beispiel zu realisieren.\par
N\'f6tige Verbesserungen:\par
- TypeDictionary und IdProvider setzen, anstatt sie hardgecodet aus einem Directory lesen.\par
- ComChannel Instanzen aufheben (k\'f6nnen), anstatt f\'fcr jede Nachricht einen neuen aufzumachen.\par
- Evtl. TODOs f\'fcr closing usw. noch implementieren, mal sehen.\par
\par
Und dann kann ich schauen, wo da der Handshake geschickt wird.\par
\par
\par
Also aus UtilTestNetworkPersistence#openComChannel muss eine "ComChannelFoundation" werden, \'e4hnlich der EmbeddedStorageFoundation\par
Dort ist dann drin:\par
- BinaryPersistenceFoundation\par
- BufferSizeProvider\par
- TypeDictionaryProvider\par
\par
Es reicht aber nicht, daraus dynamisch ComChannels zu erstellen, weil sich z.B. das TypeDictionary nicht mehr \'e4ndern darf.\par
Es muss daraus eher ein ComChannelHost oder sowas erzeugt werden, der das TypeDictionary kennt usw. und der nach neuen Verbindungen lauscht.\par
Dort kommt dann auch das Handshake senden rein, noch bevor ein OGC ComChannel ge\'f6ffnet wird.\par
\par
Oder bessere Namen:\par
- ComChannel\par
- ComHost\par
- NetworkFoundation\par
\par
\par
23:30\par
\par
Implementierung weitermachen.\par
\par
\par
2018-10-31\par
\par
\'dcberlegungen zu IdStrategy.\par
Recherche zu Potenzial und Auswirkungen auf Storage-Ebene.\par
Da w\'e4re sogar ein entsprechendes TODO in EmbeddedStorage#createConnectionFoundation.\par
Dem hardgecodet ein File zu \'fcbergeben ist eh nicht so toll.\par
Wenn das aufger\'e4umt wird, w\'e4re das gut f\'fcr\par
- OGS-45.\par
- JET-43 und JET-45.\par
- OGS an sich, weil ein TODO / Eck weniger.\par
\par
Dabei aufgefallen: Es gibt noch keinen TypeDictionaryIoHandler, sondern da wird immer mit "PersistenceTypeDictionaryLoader & PersistenceTypeDictionaryStorer"-Generics rumgebaut.\par
Typ nachr\'fcsten. Macht die Umformung oben und den Foundation Code allgemein einfacher und einheitlicher.\par
Ah, die Generics Trennung hat durchaus einen Sinn: Das wird intern tats\'e4chlich als zwei Felder verwaltet, falls das mal unterschiedliche Instanzen sein m\'fcssen.\par
Aber so ein Kombinationstyp schadet trotzdem nichts. Und Benamungen bissl verbessern.\par
\par
createConnectionFoundation entflechten.\par
\par
Hm. Das ist jetzt bl\'f6d:\par
Ein "IdStrategy" Typ w\'e4re allgemeinverwendbar f\'fcr OIDs und TIDs. Aber letztendlich m\'fcssen da zwei unterschiedliche Typen ObjectIdProvider und TypeIdProvider draus werden. Auch, um eine versehentliche Vertauschung der beiden compilertechnisch zu verhindern. Wenn ich jetzt aber in den allgemeinen Typ "IdStrategy" Methoden reinbaue, um aus einer ID-Quelle beide Arten erzeugen zu k\'f6nnen, ist ja wieder die M\'f6glichkeit/Gefahr einer Vertauschung da.\par
Mal \'fcberlegen.\par
\par
Ah, so gehts:\par
Eine IdStrategy muss OID und TID kombiniert abdecken. Man braucht ja ohnehin immer beides. Dann kann man verwechslungsfrei aus der OID-Schiene den OidProvider bauen und aus der TID-Schiene den anderen.\par
Nice.\par
\par
ComHost.Configuration weiterbauen.\par
\par
Endianess Typ selber implementieren oder java.nio.ByteOrder nehmen?\par
Das java.nio Ding ist halt der \'fcbliche Rotz mit fehlenden "forName" Methoden usw.\par
Andererseits w\'e4r es schon sehr extravagant, das nachzuimplementieren und einen l\'e4stigen Konverter Zwischenschritt aufzuzwingen.\par
Also lieber ByteOrder nehmen. Und erst mal das fehlende und sp\'e4ter n\'f6tige forName nachimplementieren. Hoffentlich wird der Hass nicht zu gro\'df.\par
\par
Ein read-only PersistenceTypeDictionary erfordert erst mal einen entsprechenden Typ, der nur lesende Funktionalit\'e4t anbietet.\par
Auftrennen in retrofitteten Supertyp PersistenceTypeDictionaryView.\par
\par
Leider auch \'e4hnlich bei der TypeLineage.\par
\par
Ableitende Konstruktoren implementieren.\par
Concurrency-Handling anpassen.\par
\par
Gibt paar Typkonflikte durch die Auftrennung. L\'f6sen mit zus\'e4tzlichen Methoden.\par
\par
\par
22:15 Weitermachen.\par
\par
\par
\par
2018-11-01\par
\par
Der ComHost muss viel mehr modularisiert werden, denn es kann sein, dass alles nach dem blanken Socket-Verbindungsaufbau von einem anderen Thread gemacht werden soll/muss.\par
Also so:\par
- Verbindungsaufbau\par
- Metadatenabgleich & Channelinstanzierung\par
- Channel weiterverwenden.\par
Jeder dieser Punkte kann im selben oder in einem eigenen Thread behandelt werden.\par
\par
\par
2018-11-02\par
\par
Die Configuration bytes m\'fcssen noch terminiert werden.\par
Ein Stop-Pattern ist genauso sicher oder unsicher wie ein length header, aber letzteres ist effizenter. Dann mach ich gleich wieder das, auch bei einem blanken String.\par
\par
ComConfiguration sollte besser ComProtocol hei\'dfen.\par
Umbenennen und ein bisschen aufr\'e4umen.\par
\par
Labels und Separator definieren.\par
\par
Code TODOs abarbeiten.\par
\par
Eigentlich sind die Protocol Einzwelwerte und die Protocol Instanz in der ComFoundation redundant. Das ist immer bl\'f6d.\par
Was w\'e4re besser?\par
Nur die Instanz? Dann muss man die aufgrund des Bezugs zum TypeDictionary aber immer explizit setzen, was auch seltsam ist.\par
Nur die Einzelwerte? Evtl. einen ComProtocol.Creator setzen k\'f6nnen?\par
Eine Nested ProtocolFoundation?\par
Ein TypeDictionaryProvider?\par
\par
Und, interessant bzw. wichtig:\par
Wenn es keine Indirektion f\'fcr das TypeDictionary gibt, dann muss das finale TypeDictionary schon zum Zeitpunkt der ComHost Erzeugung feststehen.\par
Oder ist das okay so, weil ein Netzwerk-Tor nach au\'dfen erst ge\'f6ffnet werden sollte, wenn die Typ-Interna der Anwendung (DB Initialisierung usw.) abgeschlossen ist?\par
Allerdings k\'f6nnte es schon sein, dass in einer Anwendung erst mal alle Kernbestandteile erzeugt werden und die dann in einer vern\'fcnftigen Reihenfolge gestartet werden (erst DB, dann Kommunikation).\par
\par
Umbauen auf Creator und Provider Variante.\par
\par
SwizzleIdStrategy muss doch weiter aufgeteilt werden, wenn es sauber als String assemblebar sein soll.\par
\par
Hm. Irgendwie ist es bl\'f6d, immer einen "Assembler" zu bauen und dann einen extra "Parser", der sich die ganzen Symbols usw. nochmal halten muss.\par
Warum nicht ein Kombi-Ding. Guten Namen \'fcberlegen.\par
StringConverter. Genau.\par
So bauen f\'fcr ComProtocol.\par
\par
F\'fcr SwizzleIdStrategy auch nochmal n\'f6tig.\par
Zeigt: Anwendungsfall f\'fcr einen generisch abstrahierten Typ.\par
Bauen.\par
\par
Protocol Assembly Logik bauen. Gleich h\'fcbsch les- und wartbar.\par
\par
\par
\par
2018-11-03\par
\par
TODOs abarbeiten.\par
TypeDictionaryProvider.\par
\par
\par
\par
2018-11-04\par
\par
Parserlogik implementieren.\par
Test f\'fcr StringConverter (assembling und parsing) bauen.\par
IdStrategy Zeug fehlt noch und die Aufl\'f6sung der geparsten Werte.\par
\par
Hm. Vielleicht sollte es ein interface geben, das TypeDictionary und IdStrategy zur\'fcckgibt. So k\'f6nnte man eine ComFoundation sehr einfach mit einem PersistenceManager verbinden.\par
\par
\par
SwizzleIdStrategy Aufteilung verbessern, durchdenken und implementieren.\par
\par
\par
\par
2018-11-05\par
\par
SwizzleIdStrategyStringConverter Konzept durchdenken und verbessern.\par
\par
\par
Zwischendrin mal schnell recherchieren zu FH's Wunsch nach einer expliziten "TypeNotFound" Exception anstatt einer provisorischen RuntimeException.\par
Ergebnis:\par
Alle Typaufl\'f6sungen laufen \'fcber entweder Persistence#resolveType oder Persistence#tryResolveType.\par
Das erste wirft bereits eine PersistenceExceptionTypeConsistencyDefinitionResolveTypeName, das zweite gibt absichtlich nur null zur\'fcck.\par
Ich habe die Stellen, in denen die try~ Variante aufgerufen wird, nach provisorischen Exceptions abgesucht, aber nichts gefunden, das der Bitte von FH entsprechen w\'fcrde.\par
Dann habe ich noch alle Vorkommen von "proper exception" (marker f\'fcr provisorische Exceptions) im Persistence Projekt abgesucht, auch kein Treffer.\par
Vielleicht sind andere Exceptions gemeint (type mismatch usw.) oder hier liegt irgendwie ein Misverst\'e4ndnis vor.\par
\par
SwizzleIdStrategyStringConverter weitermachen.\par
\par
\par
2018-11-06\par
\par
Ich trage mal ein paar Gedanken nach, was ich die letzten Tage so implementiert habe:\par
Ich habe einen eigene assembler und parser (kombiniert "StringConverter") f\'fcr das ComProtocol, f\'fcr die darin genestete IdStrategy und die wiederum darin genesteten Type- und ObjectIdStrategies implementiert.\par
Gleich sauber und ordentlich, dynamisch erweiterbar bei zuk\'fcnftig neuen IdStrategy Typen, usw.\par
\par
Ich habe daf\'fcr in Summe einige Tage gebraucht. Wie viel genau, ist schwer zu sagen, weil parallel dazu Konzept, andere Code Teile, usw. mit gereift sind. Es war auf jeden Fall mehr als ein MT und weniger als eine MW. Den Rest kann man sich aussuchen. 2 MT? 3 MT? So in der Richtung.\par
Die Frage ist an solchen Stellen oft immer: Muss man das selber programmieren? Kann man da nicht einfach ein JSON Framework oder sowas nehmen.\par
\par
Zahlreiche Erfahrungen f\'fchren immer zu folgendem Schluss:\par
- Ein Fremdframework muss man auch erst mal einbauen, d.h. verstehen, konfigurieren, testen, usw.\par
- Meistens haben die absurde Einschr\'e4nkungen, die einem das Leben einfacher anstatt schwerer machen.\par
- Meistens haben sie auch Bugs, von katastrophaler API ganz zu schweigen.\par
- Man hat Abh\'e4ngigkeiten zu Drittanbietern, muss f\'fcr Bugfixes oder neue Features auf deren Releasezyklen warten, muss bei neuen Versionen dann wieder refactoren, neu testen, neue Bugs workarounden, usw.\par
- Mit diesem ganzen Mist etwas zu bauen, das f\'fcr die zukunft dynamisch erweiterbar ist, ist oft sehr aufwendig bis unm\'f6glich (Framework in die Tiefe verstehen und den ganzen Scheissdreck darin workarounden).\par
\par
Das ist keine theoretische Schlechtrederei. Wir haben das alles mehrfach mitgemacht.\par
\par
Mit all dem kommt man mittelfristig auf deutlich mehr Aufwand, als wenn man es gleich selber programmiert und langfristig ruiniert man sich das eigene Framework damit (Einschr\'e4nkungen usw.) oder muss irgendwann wechseln (zu dem n\'e4chsten Scheissdreck) oder es doch selbst schreiben.\par
\par
Auch wenn es f\'fcr den Au\'dfenstehenden/Unerfahrenen/Naiven (kein Vorwurf) zun\'e4chst paradox klingt: Die langfristig BESTE L\'f6sung, vor allem was Aufwand, aber auch Stabilit\'e4t, Wartbarkeit, usw. angeht, ist es, sich Zeug selbst zu schreiben.\par
Zumindest ist das meine Erfahrung. Man muss es nat\'fcrlich gut machen und nicht einfach nur schlechteren Scheissdreck bauen, als der andere Scheissdreck ist. Sonst ist der andere Scheissdreck nat\'fcrlich die versiertere L\'f6sung.\par
\par
Das hab ich inzwischen so gut wie fertig und getestet. Aktuell ist das Problem nur noch, dass der TypeDictionary String fehlt, weshalb der Parser - ganz zurecht - Eine Exception \'fcber ein vorzeitiges Ende bzw. Unvollst\'e4ndigkeit der Daten wirft.\par
\par
Das muss ich noch fixen.\par
Und dann muss ich leider noch eine TypeDictionary Builder "light" Implementierung bauen (der fr\'fcher mal auch selbstgeschriebene TypeDictionaryParser funktioniert einwandfrei und kann mitverwendet werden), die ohne die ganzen Refactoring- und Legacy-Type-Mapping-Logik auskommt, damit der Client sich einfach nur eine Struktur bauen kann zu dem TD, das ihm geschickt worden ist.\par
\par
Dann ist JET-43 fertig.\par
\par
Die gute Nachricht ist: Durch Synergieffekte ist dabei auch schon viel Fortschritt f\'fcr JET-45, JET-46, JET-47 abgefallen.\par
Insgesamt also gar nicht mal so langsam. Und daf\'fcr auch noch eine gescheite L\'f6sung, \'fcber die wir wartungstechnisch volle Kontrolle haben.\par
\par
\par
19:00\par
So, mal schauen, wie das mit dem leeren TypeDictionary ist.\par
\par
Das ist wirklich leer. Mal schauen, warum. Das sollte eigentlich bei der Initialisierung gef\'fcllt werden.\par
Hm. Die TypeDictionary Intialisierung ist seit dem LegacyTypeMapping gar nicht mehr so einfach ...\par
Mal Methodenaufrufe verfolgen.\par
\par
Ich start jetzt einfach mal einen Storage Test und debug das durch ... ^^.\par
\par
Exception: Stackoverflow.\par
Den untersuchen.\par
Ah, die neue BaseException ruft this.getMessage anstatt von super auf.\par
\'c4ndern. Passt.\par
\par
Eigentliche Storage Exception: FileNotFound.\par
Hm. Eigentlich sollte das default storage Verzeichnis bei Bedarf angelegt werden.\par
Ich hab da neulich rumgebaut. Bei dem Test dazu ging es aber noch.\par
Also mal das untersuchen ...\par
\par
\par
Aach, das lag an den \'c4nderungen der Konstruktor-Namen. Entweder hat Eclipse das nicht richtig refactort oder ich hatte dabei einen Fehler gemacht.\par
Gefixt. Geht wieder.\par
\par
Beim rumtesten mit einem direkt initialisierten TypeDictionary aufgefallen:\par
BinaryPersistence#defaultHandlers m\'fcsste eigentlich noch \'fcber Swizzle#createDefaultTypeLookup oder #getNativeTypeId die TIDs initialisieren, sonst sind die bei einem Neustart alle 0 und die validierung der TypeDescriptions wirft eine Exception.\par
Die interessante Frage ist aber noch: Warum landen sie dann beim ersten Lauf korrekt in der TypeDictionary Datei?\par
Ach, das kommt \'fcber das Registrieren in der SwizzleRegistry und dem Typanalysieren.\par
\par
\par
\par
2018-11-07\par
\par
Schnell eine Initializer Methode f\'fcr die native types bauen.\par
Funktioniert wie geplant, aber l\'f6st das Problem nicht: XCollections usw. haben keine native TypeId. Die haben weiterhin 0.\par
Also die Initializer Methode war gut, das verhindert mal Inkonsistenzen in anderen Situationen, aber das eigentliche Problem ist (nur), wie ich im Beispiel das TypeDictionary provisorisch initialisiere.\par
Das muss, falls m\'f6glich, aus dem File kommen, nicht jedes mal neu transient initialisiert werden.\par
\par
Provisorischer Fix: Wenn providetes TypeDictionary leer, dann default handler registrieren.\par
Das muss nat\'fcrlich irgendwie sauber in den TypeDictionaryBuilder rein.\par
\par
Und seltsam: im so exportierten TypeDictionary steht der Substitutor mit TID 0. Warum nur der?\par
Recherchieren.\par
Ah, nat\'fcrlich!\par
Der ist der letzte in den Default Handlers. Alle non-native Handlers haben TID 0, d.h. der letzte ersetzt in der per-TID-Table alle vorherigen.\par
Im TypeDictionary fehlte eine Validierung, dass alle zu registrierenden TypeDefinitions eine initialisierte TypeId haben. Vor dem Legacy Type Mapping war das nicht n\'f6tig, weil die zwangsweise schon ihre TypeId hatten.\par
Jetzt ist das etwas komplizierter.\par
\par
Au\'dferdem hei\'dft das:\line Es muss unterschieden werden zwischen "nativeHandlers" (alle mit festgelegter TypeId) und "defaultHandlers" (alle native plus vorgefertigte Handlers, die aber keine feste TypeId haben).\par
Standardm\'e4\'dfig initialisiert werden darf nur mit den native Handlers.\par
\par
TypeDictionary TypeId Validierung einbauen.\par
Und gleich im TypeDictionaryManager einbauen.\par
\par
Ach, jetzt wei\'df ich, wie die "richtige" Initialisierung eines TypeDictionaries geht:\par
Der TypeDictionaryManager managet ja nur speichern, laden, registrieren.\par
F\'fcr das ganze TypeHandler- und TypeId-zeug gibt es ja den TypeHandlerManager, der intern die default handlers und den TDM kennt.\par
Der hat n\'e4mlich auch die passende initialize() Methode, die das alles richtig miteinander verkabelt.\par
\par
Also Test-Main auf diesen Typ umbauen.\par
\par
Die Native Handler Unterscheidung war trotzdem gut.\par
Noch paar kleinere Verbesserungen einbauen und TypeHandlerManager erzeugung kommentieren.\par
Passt.\par
\par
Dann kann ich jetzt ja endlich die Parsing Exception bei vorhandenem TypeDictionary untersuchen.\par
\par
So. Paar Fl\'fcchtigkeitsfehler gefixt. Jetzt fehlt nur noch das TypeDictionary Parsing.\par
Hm. Die Frage ist, ob das LegacyTypeMapping da wirklich au\'dfen vor sein soll.\par
Bzw:\par
Das LTM deckt ja nur eine Richtung ab: lesen.\par
Was bei TypeMapping f\'fcr Kommunikation n\'f6tig w\'e4re, w\'e4ren ja beide Richtungen: fremdes Format auf die eigenen Strukturen konvertierend einlesen und beim Senden die Daten der eigenen Struktur wieder ins fremde Format bringen.\par
D.h. ein der aktuellen Struktur entsprechendes Schreiben braucht man hier niemals bzw. darf man gar nicht machen.\par
Das hei\'dft nat\'fcrlich auch: Das LTM, so wie es jetzt ist, also zum Daten speichern, kann man f\'fcr Kommunikation nicht brauchen.\par
\par
Hm. Andererseits: Wenn man Daten in einer aktuellen Struktur vorliegen hat und die zum Schreiben/Versenden in eine andere Struktur konvertiert werden und dabei Daten verworfen werden, dann w\'fcrde man etwas verschicken in der Annahme, dass es ankommt, was in Wirklichkeit gar nicht so w\'e4re. Das darf nicht passieren.\par
Also zumindest das weglassen von Daten d\'fcrfte bei der Konvertierung nicht vorkommen.\par
Eigentlich gilt genauso: Felder, die der Host erwartet, d\'fcrfen nicht einfach null bleiben.\par
Und Felder mit Daten, die der Host sendet, d\'fcrfen beim Client nicht einfach ignoriert werden.\par
Das alles w\'e4ren Fehler.\par
Also triviale \'c4nderungen wie Namens\'e4nderungen ja. Oder \'e4ndern der Feldreihenfolge ja. Aber keine verlustbehafteten \'c4nderungen.\par
\par
Darf es damit vielleicht bei Kommunikation \'fcberhaupt kein Mapping von Datenstrukturen geben?\par
Immerhin ist das LTM nur daf\'fcr da, die physikalisch persistent vorliegenden Daten im alten Format wieder lesen zu k\'f6nnen. Bei Netzwerkkommunikation gibt es keine Persistenz, bzw. nur eine vor\'fcbergehende, die in jedem Fall am Ende wieder verworfen wird. Man k\'f6nnte hier ohne Verlust einfordern, dass alle Teilnehmer dieselbe Datenstruktur haben.\par
\par
Praktisch gesehen wird es nat\'fcrlich doch wieder irgendwann kommen, dass es hei\'dft, es m\'fcsse auch ein veralteter Client mit einem neueren Server sprechen k\'f6nnen, weil updaten w\'e4re ja m\'fchsam, blablabla.\par
Ganz genau genommen h\'e4ngen die Fehlerquellen oben nat\'fcrlich von der jeweiligen Situation ab. Konkrete Anwendung bzw. bis runter zu einer einzelnen Klasse. Das m\'fcsste man den Anwender in Eigenverantwortung entscheiden lassen.\par
\par
Nichtsdestotrotz ist das ganze Thema bei Kommunikation nicht so dr\'e4ngend wie bei Persistierung. Eine Zeitlang kann man schon zumuten, dass Host und Client gleiche Datenstrukturen verwenden m\'fcssen.\par
Es k\'f6nnen nicht alle Features auf einmal da sein und wir brauchen ja auch noch Arbeit f\'fcr die n\'e4chsten 10 Jahre ...\par
\par
Auf jeden Fall hei\'dft das jetzt konkret:\par
Ich brauch einen TypeDictionaryProvider, der den String parst, TypeDictionary Strukturen baut und runtime type resolving macht.\par
\par
Recherchiert:\par
Eigentlich brauch ich nur Parser+Builder, ohne Loader.\par
Das hei\'dft: Eigentlich k\'f6nnte Provider bestehen aus Loader + X und der ComProtocol Parser verwendet dann nur den X. Damit w\'e4re keine eigene Implementierung n\'f6tig.\par
Das einzige Problem, das ich dabei hab, ist: Es ist kein Name mehr frei!\par
Belegt sind schon Parser, Builder, Creator.\line Den Builder weiterhin vom Parser getrennt halten, ist auch gut so.\par
Alles, was mir sonst so einf\'e4llt, klingt kaum aussagekr\'e4ftig. Etwa "Processor" oder "Converter" oder "Compiler". Vielleicht "LoadProcessor", weil das der ist, der das Zeug vom Loader verabreitet. Aber toll ist das nicht.\par
Oder doch Compiler? Der String ist der TypeDictionary "Sourcecode" und das fertige TypeDictionary ist das "Kompilat".\par
Hm...\par
\par
\par
\par
23:30\par
\par
TypeDictionaryCompiler in Com Foundation einbauen.\par
\par
Hm. Oder eigentlich ist das ja schon in der BinaryPersistenceFoundation drin, die die ComFoundation sowieso an irgendeinem Punkt braucht.\par
Mal anschauen ...\par
\par
\par
2018-11-08\par
\par
PersistenceFoundation einbauen. Passt!\par
\par
Hm. Evtl. sollte die API nicht hardgecodet auf SocketChannel festgelegt werden, sondern parametrisiert werden.\par
Ich wette, dass die JDK Implementierung - wie immer - totaler Rotz ist und dass es was besseres gibt bzw. zuk\'fcnftig aus irgendeinem Grund mal was anderes gefordert werden wird.\par
Das ist auch gar nicht viel zu machen ein paar <C> dranh\'e4ngen und 1-2 abstrakte Zwischenklassen f\'fcr triviale Logikklassen einziehen. Das probier ich mal.\par
\par
\par
2018-11-09\par
\par
Mal recherchieren, ob es wirklich f\'fcr alle F\'e4lle reicht, einen ServerSocketChannel ohne IP Adresse zu erzeugen.\par
Aha:\par
{{\field{\*\fldinst{HYPERLINK https://stackoverflow.com/questions/11931175/what-does-wildcard-address-in-inetsocketaddress-mean }}{\fldrslt{https://stackoverflow.com/questions/11931175/what-does-wildcard-address-in-inetsocketaddress-mean\ul0\cf0}}}}\f0\fs28\par
\par
From the docs: The wildcard is a special local IP address. It usually means "any" and can only be used for bind operations.\par
The value of this IP address is 0.0.0.0. If you have two network adapters, one with IP address 1.1.1.1 and one with IP address 2.2.2.2, then you can create a listening socket and bind it to 1.1.1.1 so that the socket will not bind to 2.2.2.2. You can also create a listening socket and bind it to 2.2.2.2, so that it will not bind to 1.1.1.1. If you do not care and want your socket to bind to all network cards, then you bind it to the wildcard address.\par
Another special value would be 127.0.0.1, meaning that only clients on the same computer could connect to your server.\par
\par
Hei\'dft: Auch ComHost Instanzen brauchen eine InetSocketAddress Instanz, nicht nur einen Port.\par
Umbauen.\par
\par
Au\'dferdem aufgefallen:\par
Falls jeder Client eine eigene ID-Range bekommen k\'f6nnen soll, dann das Protocol nicht schon zur Initialisierungszeit auf eine Range festgelegt werden.\par
D.h. es muss zwischen Initialisierung und ProtocolCreator noch eine ProtocolProvider Instanz rein. Die kann defaultm\'e4\'dfig einfach ein von Anfang an konstantes Protocol zur\'fcckgeben, aber kann eben auch dynamisch neue machen.\par
\par
Dann fliegt auch gleich das seltsame clearCachedProtocol() wieder raus. Nice.\par
\par
Konsolidierung der ganzen create~, ensure~ und supply~ Methoden mit schl\'fcssigem Gesamtkonzept\par
\par
Explizite Unterscheidung zwischen clientIdStrategy und hostIdStrategy.\par
\par
\par
Als n\'e4chstes steht an:\par
- Default-Implementierung f\'fcr SocketChannel machen.\par
- Spezifische BinaryPersistence Implementierungen.\par
Evtl. beides in Foundation Ableitung reinmachen.\par
\par
\par
\par
2018-11-10\par
Default-Implementierung f\'fcr SocketChannel machen.\par
\par
\par
2018-11-12\par
Default-Implementierung f\'fcr SocketChannel weitermachen. Connectionlistener usw.\par
\par
Hm. Vielleicht kann man das doch so umstrukturieren, dass diese ganzen "ComDefault" Interfaces nicht n\'f6tig sind. Denn das wird langsam ein bisschen l\'e4stig vor lauter Abstraktion.\par
Mit einem "ComPersistenceAdaptor" Typ m\'fcsste das klappen.\par
\par
Da kommt dann auch gleich die TypeDictionaryProviding Logik rein. Das TypeDictionary muss ja aus dem Persistence Kontext kommen, also genau richtige Stelle.\par
\par
Soweit alles umgebaut, inklusive Testklasse. Mal testen.\par
Exception "Missing type id at index 0."\par
Hm, seltsam. Der Protocol String sieht unver\'e4ndert korrekt aus.\par
Muss ich dann checken und fixen.\par
\par
22:20\par
\par
Ach, der Input f\'fcr den TypeDictionary Parser hat ein "TypeDictionary" vorne dran.\par
Mal schauen, warum das falsch geschnitten wird.\par
\par
Ah, schnell gefunden: Wieder mal i und iStart verwechselt ...\par
Testen. Fehler behoben.\par
\par
Jetzt paar TODOs abarbeiten. Zentralisierte Util-Logik usw.\par
\par
\par
2018-11-13\par
\par
"ComDefault" besser benennen: ComBinary.\par
Ebenso Methoden darin.\par
Kommentar verbessern.\par
ComHost#start auf #run umbenennen.\par
Locking-Fehler darin korrigieren.\par
Erkl\'e4rende Kommentare in ComBinary Methode und aufrufenden Methoden verbessern.\par
TODO f\'fcr interessante Frage im Fehlerfall notieren.\par
\par
Hm. Das wirft eine ganze Reihe von Fragen zu potenziellen Problemen auf und Fragen zu den Fragen, welche der potenziellen Probleme wirklich vorkommen k\'f6nnen oder schon von niederen Com-Layern ausgeschlossen werden.\par
Zum Beispiel:\par
- K\'f6nnen zwischen nio Sockets gesendete Bytes verloren gehen?\par
- K\'f6nnen zwischen nio Sockets gesendete Bytes ver\'e4ndert werden?\par
- K\'f6nnen zwischen nio Sockets gesendete Bytes verdoppelt werden?\par
Vielleicht sind das naive Fragen, weil die Layers darunter mit Checksums usw. schon pr\'fcfen und neu versuchen, usw., bis die Bytes korrekt \'fcbertragen worden sind, aber mir fehlt da einfach das Wissen.\par
\par
- Kann ein read/write auf einen nio Socket unvollst\'e4ndig zur\'fcckkehren? (unvollst\'e4ndig hei\'dft: es soll z.B. ein ByteBuffer mit 8 byte inhalt geschrieben/gelesen werden, es werden aber mit einem Aufruf nur 6 byte verarbeitet)\par
Die JavaDoc von SocketChannel#read sagt, dass man nur eine Garantie \'fcber 1 gelesenes Byte nach der R\'fcckkehr der Methode hat.\par
Analog bei #write: Es sollten zwar "eigentlich" alle bytes geschrieben werden, aber so richtig drauf verlassen kann man sich anscheinend nicht.\par
Also muss man so eine Zusammenst\'fcckel-Logik selbst schreiben?\par
Wenn ja, wirft das neue Fragen auf:\par
- Zul\'e4ssiger Timeout zwischen zwei empfangen Bytes?\par
- Zul\'e4ssige Anzahl a versuchen?\par
- Zul\'e4ssiger Timeout seit Beginn der \'dcbertragung? Macht sowas Sinn? D.h. falls die Datenrate zu niedrig wird irgendwann abbrechen?\par
\par
Mit dem XSockets#performIoOperation hab ich fr\'fcher schon mal versucht, sowas in die Richtung zu bauen, aber eigentlich basiert das nur auf wilden Vermutungen von mir.\par
\par
Was ist bei solchen Fehlerf\'e4llen? Kann/muss man da irgendwie fumfunken, es nochmal zu versuchen, oder muss man nicht eigentlich den Socket dann gleich ganz schlie\'dfen?\par
\par
\par
Noch paar TODOs machen bzw. Code aufr\'e4umen.\par
ComPersistenceChannel auf abstraktes <C> umstellen.\par
\par
Jetzt mal den Parser durchgehen, ob wirklich \'fcberall ein Check auf iBound gemacht wird.\par
Paar Kleinigkeiten fixen.\par
\par
Jetzt w\'e4r noch die Frage, ob man die drei usage-spefizischen Punkte nochmal zu einem Typ zusammenfasst. Eigentlich schon, macht Sinn.\par
\par
Mal bauen.\par
\par
\par
23:30\par
\par
ComHostContext Default mit SocketChannel Typisierung bauen.\par
Es reicht ja v\'f6llig, wenn die generische/abstrakte Variante zur Verf\'fcgung steht, aber als Defaults werden \'fcberall SocketChannel Typisierungen und Implementierungen verwendet.\par
\par
TODO Cleanups.\par
\par
\par
2018-11-14\par
\par
Mist. Die Arbeit von der halben Stunde gestern Abend hatte ich daheim nicht committet.\par
Schnell nochmal nachvollziehen:\par
- Default-Implementierungen mit Typisierung auf SocketChannel f\'fcr ComHostContext und seinen Builder\par
- TODO in ComPersistenceChannelBinary machen: Buffer Vorbereitung in ComBinary#setChunkHeaderContentLength verschieben\par
- MainTest-Klasse anpassen\par
- ComHostContext.Builder#setChannelAcceptorLogic umbenennen, um die Lambda-Mehrdeutigkeit f\'fcr den Compiler aufzul\'f6sen.\par
\par
Ging deutlich schneller als die halbe Stunde gestern, weil ich die Denkarbeit ja noch im Kopf hatte :-).\par
\par
\par
Jetzt Client-Seite:\par
\par
Als Gegenst\'fcck zu dem ComHost muss es einen ComConnector oder sowas geben, der macht:\par
- Verbindung aufbauen (gibt's schon)\par
- Geschicktes Protokoll parsen (gibt's schon)\par
- Das TypeDictionary daraus in einem TypeDictionaryProvider f\'fcr die Client-Persistence-Seite verwenden.\par
\par
Hm. Das wird interessant:\par
Beim Host ist es so, dass es den Persistence-Kontext schon geben muss und der wird in den Com-Kontext eingebracht, weil Daten vom Persistence-Kontext zum Com-Kontext fliesen (n\'e4mlich das TypeDictionary)\par
Beim Client ist es anders rum: Das TypeDictionary fliest vom Com-Kontext als Quelle in den Persistence-Kontext, damit die Anwendungslogik die Persistierung verwenden kann.\par
\par
Es muss erst mal einen ComClient geben, der die Host-Adresse kennt.\par
Der muss ein "connect()" haben, das dann einen ComChannel zur\'fcckgibt.\par
Und der ComClient muss das protocol providen k\'f6nnen, nachdem verbunden wurde.\par
Oder sollte das nochmal ein extra Typ sein? Eine ComConnection, die erzeugt wird, nachdem das Protocol empfangen und geparst wurde? Ansonsten hat man nur eine Instanz, die manchmal was valides zur\'fcckgibt und manchmal nicht. Das w\'e4r doof. Besser w\'e4r: Wenn eine ComConnection zur\'fcckgegeben wird, dann ist die auch immer valide.\par
\par
Bl\'f6d w\'e4r dann aber, dass die H\'e4lfte der Server-Typen "ComConnection~" hei\'dfen, aber der Server selber gar keine ComConnection verwendet.\par
Vielleicht w\'e4re es dann doch so besser:\par
- ComConnector: kennt eine HostAdresse und erzeugt ComClients\par
- ComClient: h\'e4lt eine aktive Verbindung / ComChannel und ein erfolgreich geparstes Protocol\par
\par
Das w\'fcrde auch f\'fcr folgendes gut passen:\par
Der Connector h\'e4lt intern nur eine PersistenceFoundation.\par
Der Client h\'e4lt einen erzeugten PersistenceManager, basierend auf dem TypeDictionary aus dem erfolgreich geparsten Protocol.\par
\par
So m\'fcsste es gut sein.\par
\par
Die Frage ist dann noch:\par
Was gibt ComConnector#connect genau zur\'fcck? Einen ComChannel oder einen ComClient?\par
Bei ComChannel fehlt die R\'fcckreferenz auf den ComClient.\par
Bei ComClient m\'fcssen die DAUs schon wieder eine Methode mehr aufrufen, das f\'fchrt wieder dann zu Verwirrung.\par
Vielleicht m\'fcsste man dann einen ComClientChannel extends ComChannel machen und der Connect gibt einen ClientChannel zur\'fcck.\par
\par
Dann ist auch noch die Frage nach dem closen einer Verbindung.\par
Ein ComClient h\'e4lt immer nur einen Channel. Das ist nicht "Der Client", der mehrere Verbindungen haben kann, sondern das ist eine Repr\'e4sentation, dass der Client-Prozess ein Client f\'fcr eine Adresse ist. Man kann mehrere ComClient Instanzen haben, mit potenziell unterschiedlichen Protokollen / TypeDictionaries.\par
\par
Ein ComClient mit einmal geschlossenem ComChannel kann nicht wieder aktiviert werden, weil sich das Protocol/TypeDictionary des Hosts in der Zwischenzeit ge\'e4ndert haben k\'f6nnte.\par
Es gibt also nur: ComConnector#connect -> neue ComClient Instanz mit exklusiver ComChannel Instanz -> Verwendung -> close\par
\par
So mal implementieren ...\par
\par
Haha, dabei aufgefallen:\par
Es gibt noch gar kein close() im PersistenceManager. F\'fcr Source und Target gibt es das, aber nicht f\'fcr den PM. Mal nachr\'fcsten ...\par
\par
Client Stuff weiter implementieren.\par
Dabei aufgefallen: ist ComClient nicht einfach ein \'fcberfl\'fcssiger Zwischenschritt zwischen ComChannel und ComConnector?\par
Der ComChannel m\'fcsste f\'fcr die Client-spezifischen Teile ja nur erweitert werden (ComClientChannel extends ComChannel).\par
Dann w\'e4re aber folgende Benamung doch besser:\par
ComClient ist das Basisding, analog zu ComHost.\par
ComClientChannel ist dann die aktive Verbindung.\par
Der ComClient h\'e4tte analog zum ComHost auch die Adresse. Passt.\par
Nur den Umweg mit dem Connection Listenen und accepten h\'e4tte er nicht, darum k\'f6nnte er die PersistenceFoundation direkt kennen.\par
\par
\par
\par
2018-11-15\par
\par
ClientChannelCreator implementieren, mit Binary Implementierung.\par
\par
TODO in ProtocolStringConvert schreiben, dass der flexibler werden muss.\par
F\'fcr den Moment passt der so und \'fcber die H\'e4lfte der Arbeit war allgemeine Parsing-Struktur und Konzepte und Utilmethoden, das bleibt auch bei einer \'c4nderung alles erhalten und war nicht umsonst.\par
\par
Protocol Assembling besser in eine zentrale statische methode packen.\par
\par
\par
Idee f\'fcr Usability:\par
In ComBinary eine Methode machen, die diesen Kontext als Default f\'fcr fehlende Teile im Com Kontext setzt.\par
Damit muss man aus der ganzen Binary Schiene nur eine statische Methode aufrufen und der Rest l\'e4uft \'fcber den allgemeinen Kontext.\par
Falls man customizen will, muss man sich sowieso mit den Details auseinandersetzen.\par
\par
\par
Hm. Noch eine Idee:\par
Anstatt ein dutzend "Abstract" Klassen mit einem Dutzend "Default" Implementierungen, die jede nur 1-2 Zeilen f\'fcr SocketChannel Handling enth\'e4lt, abstrahier ich noch ein kleines St\'fcck weiter zu einem Low-Level "ConnectionLogic" Typ, der die <C> produziert, schlie\'dft, schreibt, liest. Eine Implementierung daf\'fcr w\'e4re trivial zu verstehen und zu implementieren und alles andere m\'fcsste man nicht anfassen/ableiten/implementieren.\par
Das muss ich probieren, das ist super!\par
}
 