{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\b\f0\fs28\lang7 Jetstream Network Persistence Entwicklertagebuch\par
\b0\par
2018-08-07\par
\par
Erst mal wieder in mehrere Jahre alten Network Code einlesen ...\par
\par
Es gibt einen NetworkConnectionServer.\par
Dazu gibt es zwei Factory Typen: sessionful und sessionless. Beide instanzieren letztendlich dieselbe Server Klasse, nur mit anderer Konfiguration.\par
Es gibt ein "NetworkConnectionServer.Implementation.Setup". Das sollte inzwischen wohl besser "Configuration" hei\'dfen.\par
Und es gibt ein "NetworkSessionServer.Implementation.Setup", das ein ConnectionServer~Setup kapselt und um Sessionanteile erweitert.\par
\par
Erst mal nur Sessionless:\par
\par
NetworkFactoryServerSessionless:\par
Braucht:\par
- NetworkConnectionSocket\par
- NetworkConnectionProcessor\par
Das erste definiert und wrappt einen Java nio ServerSocketChannel, der f\'fcr die Kommunikation verwendet wird. Klar.\par
Das zweite verarbeitet eine reinkommende Connection. Auch klar.\par
Bei Sessionless ist das direkt die custom Serverlogik, d.h. jede Connection l\'f6st die Logik aus und dann ist auch schon wieder Schluss. Code im Beispiel: Nachricht an den Client zur\'fcck-Echoen.\par
Bei Sessionful ist der Processor ein Standard-Bestandteil der API und validiert und erzeugt bei Erfolg eine Session.\par
\par
Der Rest der Factory sind optionale Werte:\par
- connectionListenerMaxThreadCount\par
- connectionListenerCheckInterval\par
- connectionProcessorMaxThreadCount\par
- connectionProcessorThreadTimeout\par
Standardm\'e4\'dfig 1, 1000, 1, 1000.\par
\par
Also es gibt 4 Dinger:\par
- NetworkConnectionSocket    \par
- NetworkConnectionListener\par
- NetworkConnectionHandler\par
- NetworkConnectionProcessor\par
\par
Socket ist klar, low-level Verbindung.\par
ConnectionListener lauscht in eigenen Threads nach neuen Connection\par
Processor ist auch klar, das ist die Logik, bzw. das Sessionregistrieren.\par
Was macht der ConnectionHandler?\par
\par
ConnectionHandler (defaultimplementierung) erzeugt intern einen ThreadManager, der selbst wiederum einen connectionProcessorProvider hat und zwei "Regulator" Instanzen, um Threadcount und Timeout dynamisch abfragen zu k\'f6nnen, d.h. im simpelsten Fall sind das einfach nur gewrappte ints. Der connectionProcessorProvider ist auch klar: Der liefert bei bedarf einen connectionProcessor. Im trivialen Fall (z.B. Sessionless) gibt der einfach nur die Referenz auf eine singleton ConnectionProcessor Logik zur\'fcck. Im Sessionfall einen "NetworkUserSessionConnectionRegisterer", der die Registrierung macht.\par
\par
Ok. Also die Factory erzeugt mit so einem Setup eine Serverinstanz und in der Beispiel Main wird danach active() aufgerufen. Das sollte besser start() hei\'dfen.\par
\par
Das NetworkConnectionServer#activate() macht intern im Wesentlichen:\par
this.connectionManager.activate()\par
Das macht wiederum:\par
ListenerController (extends Thread) instanzieren und starten.\par
Der macht in seinem run() nur:\par
Zahl der Listener via Regulator checken und entsprechend erh\'f6hen oder reduzieren, danach ein Interval lang schlafen.\par
Listener erh\'f6hen:\par
Neue ListenerThread (extends Thread und nested in NetworkConnectionManager) Instanz erzeugen, registrieren und starten.\par
\par
ListenerThread#run macht:\par
vom \'fcbergeordneten NetworkConnectionManager provideConnectionListener() aufrufen.\par
\par
Das macht wiederum:\par
NetworkConnectionListener Instanz (bisher anscheinend immer) erzeugen und dann zur\'fcckgeben.\par
\par
NetworkConnectionListener#run macht (mit Exceptionhandling und blabla au\'dfen rum):\par
SocketChannel newConnection = this.connectionSocket.acceptConnection()\par
this.connectionHandler.handleConnection(newConnection)\par
\par
connectionHandler#handleConnection macht eben wie schon recherchiert:\par
connection an den threadmanager \'fcbergeben, der holt sich intern vom connectionProcessorProvider eine connectionProcessor Instanz. Im trivialen Fall ist das die Logik selbst.\par
\par
Also soweit fertig analysiert:\par
- Server wird zusammengebaut mit custom Socket, custom processing Logik und defaults f\'fcr thread management.\par
- Connection listening erfolgt gemanaget mit einer dynamischen Anzahl an dedicated Threads.\par
- Die Threads lauschen mit acceptConnection nach neuen Verbindungen und leiten eine solche an die processor Logik weiter.\par
- Im einfachsten Fall (Beispiel) echot die die Nachricht an den Client zur\'fcck und die Connection ist erledigt.\par
- Au\'dfen rum viel Threadmanagement und Exception Handling Logik rum, damit man das nicht jedes mal selber bzw neu schreiben muss.\par
\par
\par
Der Sessionless Client ist im Vergleich relativ krude, ohne sch\'f6ne Kapselung:\par
\par
Per LogicSimpleNetwork#openRemoteChannel Utilmethode wird ein SocketChannel ge\'f6ffnet.\par
Per LogicSimpleNetwork#communicate wird ein String geschickt.\par
Die echoRequest Logik im Server ruft LogicSimpleNetwork#readString und danach LogicSimpleNetwork#sendString auf.\par
\par
\par
Jetzt auf zum dar\'fcberliegenden "network.binary.persistence" Framework:\par
\par
BinaryMessageProcessor kennt einen PersistenceBuilder<M>. Das ist die Verbindung zum Persistence Framework.\par
\par
Hm. Aber recht viel mehr ist da nicht.\par
Ein paar Verbindungen zu sessionful network Zeug. Ansonsten nur Utilmethoden, die nie aufgerufen werden und Interfaces, die nirgends implementiert werden.\par
Da ist auch requesthandling mit request IDs und sowas drin.\par
\par
Das ist alles sehr wenig und sehr anf\'e4nglich:\par
- Es hei\'dft binary.persistence, verwendet aber nur Persistence~<M> Code mit beliebigem Medium.\par
- Es ist an sessionful Code gebunden, obwohl die Verwendung eines Persistence Frameworks doch auch ohne Session m\'f6glich sein sollte (oder?)\par
- Code Kommentare sind von 2012. Das ist 6 Jahre her ^^. Da war das Persistence Zeug alles noch extrem in den Kinderschuhen.\par
\par
Hm. Ich h\'e4tte schw\'f6ren k\'f6nnen, schon mal eine Beispiel Main auch mit der Binary Persistence gehabt zu haben, aber davon find ich nix mehr, auch kein Framework.\par
\par
\par
Die Frage ist nun:\par
Zumindest der Network Code sieht schon ganz sinnvoll aus mit dem Wrapping des ganzen Overhead Codes.\par
Aber ist es hilfreich, den f\'fcr eine simple Demo \'fcberhaupt zu verwenden?\par
\par
Eigentlich reicht ja:\par
- Client Main macht einen nio SocketChannel auf.\par
- Client Server listened hardcoded und singlethreaded nach einer Connection.\par
- Wenn eine Connection reinkommt, wird die (irgendwie gewrappt) als PersistenceSource verwendet und ausgelesen.\par
- Der Client verwendet seinen SocketChannel (auch gewrappt) als PersistenceTarget und schreibt da rein.\par
\par
Das ganze muss nat\'fcrlich bidirektional sein: Der Server muss auch senden und der Client auch empfangen k\'f6nnen.\par
Das hei\'dft beide m\'fcssen den SocketChannel eigentlich \'e4hnlich wie bei der Storage als "Connection" wrappen, die Source und Target zugleich ist.\par
In StorageConnection ist das der PersistenceManager, der PersistenceRetrieving und PersistenceStoring ist und entsprechende Source und Target kennt.\par
\par
Das hei\'dft analog wie die StorageConnection m\'fcsste die NetworkConnection ein Wrapper f\'fcr einen PersistenceManager<Binary> sein, der intern den Socket als Source und Target wrappt und drum rum die ganze SwizzlingRegistry und TypeHandling Logik rumbaut.\par
\par
Anmerkung:\par
Ber StorageRequestAcceptor in der StorageConnection ist nur eine parellele Referenz auf ein vom PersistenceManager gerwrapptes Bestandteil, damit die Connection direkt Util-Requests an die Storage schicken kann. Prinzipiell, bzw. ohne Util-Requests, braucht man sowas nicht, also kann das bei der NetworkConnection entfallen.\par
Hm. Oder noch einfach (f\'fcr den Anfang): man braucht nur einen PersistenceManager direkt. Alles, was den von einem File PersistenceManager unterscheidet, ist, dass er statt einem FileChannel einen SocketChannel als Source und Target hat.\par
So sollte/muss das Framework ja auch funktionieren: man schreibt nur eine Anbindung f\'fcr ein Source und Target und der Rest ist sauber wegabstrahiert.\par
\par
Das sollte eigentlich so trivial sein wie die existierenden BinaryFileTarget und BinaryFileSource Implementierungen sein. \par
\par
\par
Ca. 1,0h f\'fcr Network und Network Binary Persistence Recherche, Recherche und Konzept f\'fcr simples Network Target und Source.\par
\par
\par
\par
2018-08-08\par
\par
21:30\par
Erst mal ordentliches Projekt "Jadoth Network Persistence" anlegen.\par
Das "Binary Persistence" kann dann gel\'f6scht bzw. gr\'f6\'dftenteils neu gebaut werden.\par
Und schon gibts das erste Problem: Daraus ein Maven Projekt machen ist alles andere als intuitiv. Nirgends eine Option, ein Java Projekt zu einem Maven Projekt zu konvetieren. Schauen, ob man ein Maven Projekt direkt anlegen kann. Ja, geht. Also l\'f6schen und als Maven Projekt neu anlegen. "Group Id". "Artifact Id". Alles Pflichtfelder, aber keine Ahnung, was da rein muss. Keine Hilfe, Vorschlagswerte sind leer (da k\'f6nnte man ja bestehende anzeigen).\par
=> Wieder mal Dreckskonzept, mit dem ich mich jetzt nicht ewig rumschlage.\par
Also wieder Maven Projekt l\'f6schen und normales Java Projekt mit normalen Projektabh\'e4ngigkeiten anlegen. Soll jemand mit magischem Maven Wissen in der Arbeit dann konvertieren.\par
\par
NetworkPersistenceConnection anlegen.\par
\par
\par
Gleich im Persistence Framework einen neuen Kombi-Typ PersistenceChannel (Target+Source) anlegen. Als Konsequenz bisherige Doppelimplementierungen konsolidieren. Interessant: In den Factories gibt es sowas eh schon, aber implizit definiert \'fcber doppel-Bound-Generics. #setPersistenceStorage. Vereinfachen zu #setPersistenceChannel.\par
\par
NetworkPersistenceConnection umbenennen zu NetworkPersistenceChannel. Das "Channel" hat nichts mit dem zu verwendenden SocketChannel zu tun, sondern ist allgemein gemeint. Siehe oben. Eher im Sinn "Einen Kanal \'f6ffnen", so wie bei Funkkommunikation oder allgemein einfach ein Kanel, durch den hin und zur\'fcck Daten flie\'dfen. Dass der NetworkChannel dann einen SocketChannel wrapt, passt zuf\'e4llig ganz gut.\par
\par
PersistenceSource#readInitial refactoren zu PersistenceSource#read und JavaDoc aktualisieren.\par
\par
Nachdenken \'fcber NetworkPersistenceConnection#readByObjectIds. Macht grunds\'e4tzliuch schon Sinn, aber erstmal weglassen. Entsprechenden Kommentar schreiben.\par
\par
NetworkPersistenceChannel muss abstract werden.\par
Es muss dann noch einen NetworkPersistenceChannelBinary mit konkreter Implementierung geben.\par
\par
Hm.\par
In PersistenceSource fehlt noch ein #prepareSource und #closeSource.\par
Analog in PersistenceTarget.\par
Gut, dass es default methods gibts. Damit ist es ein Klacks, das abw\'e4rtskompatibel zu machen.\par
\par
\par
Jetzt NetworkPersistenceChannelBinary implementieren.\par
Struktur fertig. Jetzt ist die Frage, wie man aus einem SocketChannel ein bis mehrere Binary rauszieht.\par
Das m\'fcsste analog zur simplen File Implementierung gehen. Mal checken.\par
\par
Ca. 1,0h f\'fcr Maven \'c4rger, Projekte und Strukturen anlegen, bestehende Typen leicht refactoren und NetworkPersistenceChannelBinary implementieren. \'dcberlegungen zu Daten lesen mit unbekannter L\'e4nge.\par
\par
\par
\par
2018-08-10 20:15\par
\par
PersistenceSource Implementierung f\'fcr simples File anschauen und f\'fcr SocketChannel \'fcbernehmen.\par
\par
Hm ...\par
Bei einer Netzwerkverbindung wei\'df man vorher nicht, wie viele Bytes der schicken wird. Also m\'fcsste ich entweder die Struktur der persistierten Daten erweitern ("Ein Haufen Bytes muss am Anfang immer eine Angabe \'fcber die L\'e4nge haben") oder eine bissl komplizierte zusammenst\'fcckel-Logik bauen. Aber f\'fcr ein simples Beispiel mach ich jetzt einfach mal einen gro\'dfz\'fcgigen Puffer, in den alle Daten auf einmal reingehen. Plus TODO daneben hin.\par
Etwas weiter daran rum\'fcberlegt: letztendlich muss es die "Zusammenst\'fcckel-Logik" werden, weil das flexibler ist, als zus\'e4tzliche Metadaten zu verlangen, auf die man bei einer anderen Strategie verzichten k\'f6nnte.\par
\par
Das wird aber bissl komplizierter:\par
- Anfangen mit nur einem ChunksBuffer, okay.\par
- Sobald der voll ist, den n\'e4chsten anlegen und immer so weiter, bis keine Bytes mehr \'fcber den Socket reinsprudeln.\par
- Beim durchiterieren der Bytes gibts dann verschiedene eklige Sonderf\'e4lle:\par
1.) am Ende eines Buffers ist ein Entity unvollst\'e4ndig enthalten.\par
2.) am Ende eines Buffers ist das length header field eines Entities unvollst\'e4ndig enthalten.\par
Beide F\'e4lle m\'fcssen so gel\'f6st werden:\par
Falls so ein Fall festgestellt wird, muss ein zus\'e4tzlicher ChunksBuffer erzeugt werden, der "dazwischengeschoben" wird.\par
In den wird der Restteil aus dem aktuellen ChunksBuffer kopiert.\par
Im Fall 1 wird dann der Rest des zerteilten Entities dazukopiert, so dass das Entity wieder komplett ist.\par
Im Fall 2 wird der Rest des Length Headers dazukopiert. Dann kann \'fcberhaupt erst geschaut werden, wie lang das Entity ist. Falls der dazwischengeschobene ChunksBuffer zu klein sein sollte, muss nochmal ein neues angelegt werden und nochmal umkopiert werden, damit das entity letztendlich komplett enthalten sein kann.\par
Der regul\'e4r folgende ChunksBuffer braucht einen Offset, damit die zusammenkopierten Daten an seinem Anfang nicht nochmal gelesen und f\'e4lschlicherweise als ganzes Entity interpretiert werden.\par
\par
Performancetechnisch ist das alles kein Problem: Es geht nur um ein einzelnes Entity und der ganz eklige Fall 2 sollte relativ selten sein. Aber das wird relativ viel Code. Bissl bl\'f6d.\par
\par
Aber erst mal die triviale L\'f6sung mit dem gro\'dfen Puffer und TODO daneben.\par
\par
\par
Implementieren am Beispiel von Klasse BinaryFileSource.\par
\par
Dabei gleich mal die Methoden BinaryPersistence#fillBuffer und BinaryPersistence#readChunkLength nach BinaryFileSource verschieben, weil die von inszwischen falschen Annahmen (jeder Chunk beginnt mit einem Chunk Length Header) ausgehen.\par
Solche Methoden d\'fcrfen nicht in einer allgemeinen, noch aktuellen Klasse sein.\par
\par
\par
Hm. Das ist gar nicht so einfach: Muss bei Netzwerk-Kommunikation evtl. doch ein Chunk Length Header mitgeschickt werden, weil der Empf\'e4nger sonst nie wei\'df, wie viele Bytes noch kommen werden, ob er bei einer Pause abbrechen soll, usw.\par
\par
Also w\'e4re die Strategie so:\par
Der Channel h\'e4lt sich einen Header Buffer. Ist im Moment nur 8 bytes lang, aber evtl. wird der Header mal gr\'f6\'dfer (Endiness, Version, usw.). Dann muss man nur einmal zentral den Header Buffer erweitern.\par
Der wird immer voll gemacht. Wenn der nicht voll wird (innerhalb eines bestimmten Timeouts), dann ist die Verbindung abgebrochen und es wird resettet und eine Exception geworfen.\par
Wenn er voll ist, wird die L\'e4nge des Chunks ausgelesen.\par
\par
Dann wird der aktuelle Buffer auf diese Gr\'f6\'dfe gesetzt oder, falls n\'f6tig, ein gr\'f6\'dferer allokiert. Mehrere kleine Buffers hintereinanderschalten w\'e4re hier nicht sinnvoll, weil sowieso der komplette Chunk auf einmal eingelesen werden muss und mehrere kleine machen nur mehr Overhead. Dann lieber gleich einen exakt ausreichend gro\'dfen allokieren und (mit timeout) volllaufen lassen.\par
\par
\par
Implementieren am Beispiel von Klasse BinaryFileSource.\par
\par
Dabei gleich mal die Methoden BinaryPersistence#fillBuffer und BinaryPersistence#readChunkLength nach BinaryFileSource verschieben, weil die von inszwischen falschen Annahmen (jeder Chunk beginnt mit einem Chunk Length Header) ausgehen.\par
Solche Methoden d\'fcrfen nicht in einer allgemeinen, noch aktuellen Klasse sein.\par
\par
\par
Hm. Das ist gar nicht so einfach: Muss bei Netzwerk-Kommunikation evtl. doch ein Chunk Length Header mitgeschickt werden, weil der Empf\'e4nger sonst nie wei\'df, wie viele Bytes noch kommen werden, ob er bei einer Pause abbrechen soll, usw.\par
\par
Also w\'e4re die Strategie so:\par
Der Channel h\'e4lt sich einen Header Buffer. Ist im Moment nur 8 bytes lang, aber evtl. wird der Header mal gr\'f6\'dfer (Endiness, Version, usw.). Dann muss man nur einmal zentral den Header Buffer erweitern.\par
Der wird immer voll gemacht. Wenn der nicht voll wird (innerhalb eines bestimmten Timeouts), dann ist die Verbindung abgebrochen und es wird resettet und eine Exception geworfen.\par
Wenn er voll ist, wird die L\'e4nge des Chunks ausgelesen.\par
\par
Dann wird der aktuelle Buffer auf diese Gr\'f6\'dfe gesetzt oder, falls n\'f6tig, ein gr\'f6\'dferer allokiert. Mehrere kleine Buffers hintereinanderschalten w\'e4re hier nicht sinnvoll, weil sowieso der komplette Chunk auf einmal eingelesen werden muss und mehrere kleine machen nur mehr Overhead. Dann lieber gleich einen exakt ausreichend gro\'dfen allokieren und (mit timeout) volllaufen lassen.\par
\par
Das analog dazu passende Schreiben ist relativ einfach:\par
Erst alle ChunksBuffer f\'fcllen wie gehabt, dann einen zus\'e4tzlichen voranstellen, der den korrekten Header enth\'e4lt und dann alle abschicken.\par
\par
Das muss dann aber doch gleich jetzt so implementiert werden, weil sonst nicht festgestellt werden kann, wann ein read komplett ist.\par
Es ist halt alles immer komplizierter als zun\'e4chst gedacht.\par
Positiv ist immerhin: Viel Logik (bzw. Denkarbeit) von LogicSimpleNetwork kann da gleich verwendet werden. Das hilft.\par
\par
\par
\par
\'dcberlegungen und Code TODO zu komplexerem NetworkTimeoutEvaluator. Aber einstweilen lass ich den simplen int.\par
\par
Implementierung #readFromSocketChannel ...\par
\par
Chunks interface durchschauen, bissl refactoren und mit Kommentaren versehen.\par
Das Zeug ist auch schon ganz sch\'f6n alt... ^^\par
\par
\par
2,5 h f\'fcr Netzwerk\'fcbertragung Konzept\'fcberlegungen (Terminierung, Timeout). Einlesen in und geringf\'fcgiges Refactoring von bestehendem Code (LogicSimpleNetwork, Chunks), Implementierung #readFromSocketChannel.\par
\par
\par
\par
\par
2018-08-11 22:00\par
\par
Jetzt write implementieren:\par
Plan ist wie gehabt:\par
- Gesamtl\'e4nge der Daten in allen Chunks summieren\par
- Ermittelte Gesamtl\'e4nge in einem vorangestellten Header ByteBuffer zuerst schicken\par
- Dann den eigentlichen ByteBuffer Inhalt hinterherschicken.\par
\par
Die Gesamtl\'e4nge eines Chunks kann in diesem beim Beschreiben gleich mitgef\'fchrt werden, so dass man sp\'e4ter nicht nochmal per Schleife dr\'fcber muss. Hm. Interessant ist, wie das beim Storage write ermittelt wird. Mal nachschauen ...\par
Ah. Das wird mit "chunksTotalLength()" tats\'e4chlich manuell aufaddiert. Das ersetz ich auch dort durch die on-the-fly Strategie. Das ist besser.\par
Hm. Da wird nur das ByteBuffer[] anstatt dem original Chunks \'fcbergeben. Warum ...?\par
Warum gibt StorageChannel#storeEntities ein KeyValue<ByteBuffer[], long[]> zur\'fcck?\par
Hm. Das verwendet StorageEntityCache#internalPutEntities tats\'e4chlich zum Entities updaten. Das k\'f6nnte auch ohne Arrayumweg mit einer mitsummierten ChunkPosition gel\'f6st werden, aber gut. Jetzt ist das halt so.\par
\par
Hm. Trotzdem mal ein TODO schreiben. Code Vereinfachung ist immer gut.\par
\par
Aber zur\'fcck zum Network Demo ...\par
\par
Hm. Es gibt von #flushBuffer (in NetworkPersistenceBinary bzw. fr\'fcher in LogicSimpleNetwork noch gar keine allgemeine Verwendung. Das String Senden z\'e4hlt nicht). Aber gibt eigentlich keinen Grund, die Methode nicht gleich direkt public zu machen. Am besten mit besserem Namen bzw. analog dazu auch gleich mit umbenanntem und public gemachtem #fillBuffer.\par
\par
Hm. Bl\'f6d: write() kriegt ein array, das aber eigentlich gar keins ist, weil das f\'fcr das Storage Channel Hashing ben\'f6tigt wird. \'dcberlegen. Gibt auf die Schnelle keine einfache L\'f6sung. Provisorische L\'f6sung: in Network Kommunikation auf chunks.length == 1 pr\'fcfen und ansonsten exception werfen.\par
\par
\par
Chunks#totalLength implementieren.\par
Dabei recherchieren, ob ChunksWrapper \'fcberhaupt nocht gebraucht wird.\par
Hm. Irgendwie nur in den veralteten BinaryFile- und Network-Klassen. Aber ich verwend den mal in dem neuen Network Zeug auch. Kann man sp\'e4ter ja mal rausrefactoren.\par
Dabei gleich mal aufgefallen: der ByteBuffer.flip() Aufruf im Network read ist falsch, weil position erhalten bleiben muss. Gleich mal einen Bug weniger beim Testen. Fein.\par
\par
Mit dieser Methode ist das eigentliche ChunkHeader schreiben trivial:\par
NetworkPersistenceBinary.setNetworkChunkHeaderContentLength(defaultBuffer, chunk.totalLength());\par
Okay, nicht ganz trivial: defaultBuffer.limit(NetworkPersistenceBinary.networkChunkHeaderLength()) fehlte noch.\par
Note hinschreiben, dass das alles besser gekapselt werden m\'fcsste.\par
\par
Und damit w\'e4r die write Methode fertig.\par
\par
2,0 h f\'fcr Recherchen zu bisheriger Verwendung von Chunks Typ und dessen Metadaten, Kommentare f\'fcr empfehlenswerte Codeverbesserungen, Chunks Metadaten Erweiterung, write Logik implementiert, kleiner Bugfix in read Logik.\par
\par
\par
\par
2018-08-12 21:30\par
\par
Main-Klassen f\'fcr Server und Client bauen.\par
Ich schau einfach mal in das MainTestSessionlessServer Beispiel rein und kopier den Code von dort raus.\par
\par
BufferSizeProvider aufsplitten in einfachen BufferSizeProvider und BufferSizeProviderIncremental.\par
Anpassen an Java 8 Features.\par
\par
\par
22:15 Pause\par
\par
22:45 Weiter gehts.\par
\par
Server und Client Main Test Klassen gebaut.\par
Gemeinsame Logik in Util Klasse verschoben. Dann sehen die Main Klassen selbst gleich sehr klein und aufger\'e4umt auf.\par
Erkl\'e4rende Kommentare hinzugef\'fcgt.\par
Paar kleinere Aufr\'e4umarbeiten.\par
\par
\par
1,25 h f\'fcr Server und Client Main Test Klassen und geringf\'fcgiges Refactoring.\par
\par
\par
\par
2018-08-13 20:15\par
\par
Test und Bugfixes.\par
\par
Exception: Missing assembly part of type interface net.jadoth.swizzling.types.SwizzleTypeIdProvider. null\par
Achja, klar: PeristenceManager allein bauen reicht ja nicht. Da fehlt noch einiges an Metadaten Zeug, wie z.B. in EmbeddedStorageFoundation#createEmbeddedStorageManager.\par
Anschauen und nachziehen.\par
\par
Hm. Wobei: Die ganze Storage-Specials wie Root-Handling, TypeDictionary-Verbandelung, usw. braucht man ja f\'fcr Netzwerkkommunikation nicht. Und der SwizzleTypeIdProvider wird hier gar nicht gesetzt. Das ist die falsche Stelle.\par
\par
EmbeddedStorage#createConnectionFoundation ist die richtige Stelle.\par
Die ConnectionFoundation ist nichts anderes als eine BinaryPersistenceFoundation mit bissl Erweiterung.\par
Von dort kopieren.\par
\par
Hm. Das sollte erst mal so klappen, w\'e4re aber unbrauchbar f\'fcr einen Produktivbetrieb.\par
Mal "Beschr\'e4nkungen / TODOs / bekannte Probleme" aufschreiben.\par
\par
Noch default system directory definieren. Directory ensuren. Blabla.\par
\par
Und schwups: Schon gehts. \\o/\par
\par
Paar debug-outs dazubauen. So sieht das dann aus:\par
\par
.run(MainTestNetworkPersistenceServer.java:25)                  21:18:36.132> Server awaiting connection ...\par
.run(MainTestNetworkPersistenceServer.java:27)                  21:18:36.132> Server accepted connection. Processing.\par
.processNextRequest(MainTestNetworkPersistenceServer.java:35)   21:18:36.132> Server initializing PersistenceManager\par
.processNextRequest(MainTestNetworkPersistenceServer.java:39)   21:18:36.136> Server is reading data ...\par
.processNextRequest(MainTestNetworkPersistenceServer.java:43)   21:18:36.337> Server is processing graph ...\par
Request 1534187909821:27\par
.run(MainTestNetworkPersistenceServer.java:25)                  21:18:36.338> Server awaiting connection ...\par
.run(MainTestNetworkPersistenceServer.java:27)                  21:18:36.338> Server accepted connection. Processing.\par
.processNextRequest(MainTestNetworkPersistenceServer.java:35)   21:18:36.339> Server initializing PersistenceManager\par
.processNextRequest(MainTestNetworkPersistenceServer.java:39)   21:18:36.343> Server is reading data ...\par
.processNextRequest(MainTestNetworkPersistenceServer.java:43)   21:18:36.543> Server is processing graph ...\par
Request 1534187909821:28\par
\par
\par
.main(MainTestNetworkPersistenceClient.java:23)                 21:18:36.131> Client opens channel ...\par
.main(MainTestNetworkPersistenceClient.java:26)                 21:18:36.132> Client opened channel. Sleeping ...\par
.main(MainTestNetworkPersistenceClient.java:29)                 21:18:36.332> Client initializing PersistenceManager\par
.main(MainTestNetworkPersistenceClient.java:32)                 21:18:36.336> Client sending data ... \par
.main(MainTestNetworkPersistenceClient.java:34)                 21:18:36.337> Client sent data.\par
.main(MainTestNetworkPersistenceClient.java:23)                 21:18:36.338> Client opens channel ...\par
.main(MainTestNetworkPersistenceClient.java:26)                 21:18:36.338> Client opened channel. Sleeping ...\par
.main(MainTestNetworkPersistenceClient.java:29)                 21:18:36.538> Client initializing PersistenceManager\par
.main(MainTestNetworkPersistenceClient.java:32)                 21:18:36.542> Client sending data ... \par
.main(MainTestNetworkPersistenceClient.java:34)                 21:18:36.544> Client sent data.\par
\par
\par
\par
TODOs:\par
v eigene Verzeichnisse f\'fcr Server und Client\par
v Server muss auch zur\'fccksenden k\'f6nnen\par
v Beispiel mit komplexerem Graph als nur einem String\par
v ComChannel Wrapper f\'fcr H\'fcbschness.\par
\par
21:30 Pause\par
\par
23:30 Weiter gehts. TODOs umsetzen.\par
Siehe "v"s oben.\par
\par
So. Dann w\'e4r das soweit fertig. Das Framework sind im Wesentlichen 200 LoC.\par
\par
\par
1,75 h f\'fcr Test, Bugfixes, Debugausgaben, Notieren von Beschr\'e4nkungen, Beispiele verbessern.\par
\par
\par
\par
2018-08-14\par
\par
08:30\par
Erkl\'e4rungen in WhatsApp f\'fcr MK\par
\par
08:45 Pause\par
\par
13:30\par
Koordination in WhatsApp mit MK\par
Veralteten Code l\'f6schen und committen f\'fcr bessere \'dcbersicht.\par
\par
13:45 Pause\par
\par
\par
17:15\par
Confluence Seite "Jetstream f\'fcr Netzwerkkommunikation" schreiben.\par
{{\field{\*\fldinst{HYPERLINK https://www.xdevcollaboration.com/pages/viewpage.action?pageId=51380761 }}{\fldrslt{https://www.xdevcollaboration.com/pages/viewpage.action?pageId=51380761\ul0\cf0}}}}\f0\fs28\par
\par
18:30\par
Kontrolllesen und Fehler korrigieren.\par
18:45 Feierabend\par
\par
\par
2,00 h f\'fcr Kommunikation und Confluence Artikel\par
\par
\par
2018-08-16\par
\par
0,25 h f\'fcr Konzept\'fcberlegungen und Confluence Kommentar.\par
\par
\par
\par
2018-08-17\par
\par
Failing TypeIdProvider bauen und TransientOidProvider f\'fcr Netzwerk Temp-Ids verwenden.\par
\par
Passende ID-Ranges \'fcberlegen.\par
Test, Fixes/Anpassungen f\'fcr Failing TypeIdProvider. Kommentare.\par
\par
Kommentar "\'dcberlegungen zum Typedefinition Problem" zu Confluence Artikel schreiben.\par
\par
1,50 h f\'fcr neue ID-Provider Strategie, Confluence Kommentar. Issue JET-42 Update.\par
\par
\par
\par
2018-08-18\par
\par
\'dcberlegungen zu Communication Metadaten und JET-43 Erstellung.\par
\par
1,0 h f\'fcr Communication Metadaten Konzept. JET-43 Erstellung.\par
\par
\par
2018-08-19\par
\par
\'dcberlegungen zu ID-Strategy Konzept Verbesserung und JET-43 Update.\par
\par
0,5 h f\'fcr Konzept \'dcberlegungen und Issue JET-43 Update.\par
\par
\par
2018-08-20\par
\par
0,75 h f\'fcr: Im Confluence Hinweise zu Klassen iterieren und UUIDs lesen, kurz recherchieren, Antwort zu UUIDs schreiben.\par
\par
\par
2018-08-21\par
0,25 h f\'fcr Confluence und JET-43 Updates.\par
\par
\par
2018-08-28\par
\par
14:15 Besprechungstermin im B\'fcro \par
16:15 Ende.\par
\par
2h f\'fcr Besprechungen zu Jetstream und zuk\'fcnftige JDK Kosten.\par
\par
\par
\par
2018-10-29\par
\par
Epic (JET-44) und Issues f\'fcr n\'f6tige Arbeiten anlegen.\par
\par
\'dcbersicht n\'f6tige Arbeiten / Issues:\par
- JET-43: Handshake f\'fcr Type Dictionary Abgleich, Endianess Abgleich, Protokollname und Versionsnummer\par
- Disjunkte OID Ranges managen\par
- Type Dictionary Abgleich zu Beginn\par
- Dynamische Typanalyse unterbinden, stattdessen Exception bei unbekanntem Typ.\par
- Varianten f\'fcr stateful und stateless communication, was die SwizzleRegistry angeht.\par
- Endianess Konvertierung\par
- Einfache Plugin-M\'f6glichkeit f\'fcr Ver- und Entschl\'fcsselung\par
\par
\par
2018-10-30\par
Issues Beschreibungen nachtragen.\par
\par
JET-43 anfangen.\par
Erst mal wieder in Beispielcode einlesen.\par
\par
Zun\'e4chst mal muss da eine richtige Infrastruktur gebaut werden. Momentan sind das ja nur Utilmethoden, die ein File als Directory \'fcbergeben bekommen, um das Proof-of-Concept Beispiel zu realisieren.\par
N\'f6tige Verbesserungen:\par
- TypeDictionary und IdProvider setzen, anstatt sie hardgecodet aus einem Directory lesen.\par
- ComChannel Instanzen aufheben (k\'f6nnen), anstatt f\'fcr jede Nachricht einen neuen aufzumachen.\par
- Evtl. TODOs f\'fcr closing usw. noch implementieren, mal sehen.\par
\par
Und dann kann ich schauen, wo da der Handshake geschickt wird.\par
\par
\par
Also aus UtilTestNetworkPersistence#openComChannel muss eine "ComChannelFoundation" werden, \'e4hnlich der EmbeddedStorageFoundation\par
Dort ist dann drin:\par
- BinaryPersistenceFoundation\par
- BufferSizeProvider\par
- TypeDictionaryProvider\par
\par
Es reicht aber nicht, daraus dynamisch ComChannels zu erstellen, weil sich z.B. das TypeDictionary nicht mehr \'e4ndern darf.\par
Es muss daraus eher ein ComChannelHost oder sowas erzeugt werden, der das TypeDictionary kennt usw. und der nach neuen Verbindungen lauscht.\par
Dort kommt dann auch das Handshake senden rein, noch bevor ein OGC ComChannel ge\'f6ffnet wird.\par
\par
Oder bessere Namen:\par
- ComChannel\par
- ComHost\par
- NetworkFoundation\par
\par
\par
23:30\par
\par
Implementierung weitermachen.\par
\par
\par
2018-10-31\par
\par
\'dcberlegungen zu IdStrategy.\par
Recherche zu Potenzial und Auswirkungen auf Storage-Ebene.\par
Da w\'e4re sogar ein entsprechendes TODO in EmbeddedStorage#createConnectionFoundation.\par
Dem hardgecodet ein File zu \'fcbergeben ist eh nicht so toll.\par
Wenn das aufger\'e4umt wird, w\'e4re das gut f\'fcr\par
- OGS-45.\par
- JET-43 und JET-45.\par
- OGS an sich, weil ein TODO / Eck weniger.\par
\par
Dabei aufgefallen: Es gibt noch keinen TypeDictionaryIoHandler, sondern da wird immer mit "PersistenceTypeDictionaryLoader & PersistenceTypeDictionaryStorer"-Generics rumgebaut.\par
Typ nachr\'fcsten. Macht die Umformung oben und den Foundation Code allgemein einfacher und einheitlicher.\par
Ah, die Generics Trennung hat durchaus einen Sinn: Das wird intern tats\'e4chlich als zwei Felder verwaltet, falls das mal unterschiedliche Instanzen sein m\'fcssen.\par
Aber so ein Kombinationstyp schadet trotzdem nichts. Und Benamungen bissl verbessern.\par
\par
createConnectionFoundation entflechten.\par
\par
Hm. Das ist jetzt bl\'f6d:\par
Ein "IdStrategy" Typ w\'e4re allgemeinverwendbar f\'fcr OIDs und TIDs. Aber letztendlich m\'fcssen da zwei unterschiedliche Typen ObjectIdProvider und TypeIdProvider draus werden. Auch, um eine versehentliche Vertauschung der beiden compilertechnisch zu verhindern. Wenn ich jetzt aber in den allgemeinen Typ "IdStrategy" Methoden reinbaue, um aus einer ID-Quelle beide Arten erzeugen zu k\'f6nnen, ist ja wieder die M\'f6glichkeit/Gefahr einer Vertauschung da.\par
Mal \'fcberlegen.\par
\par
Ah, so gehts:\par
Eine IdStrategy muss OID und TID kombiniert abdecken. Man braucht ja ohnehin immer beides. Dann kann man verwechslungsfrei aus der OID-Schiene den OidProvider bauen und aus der TID-Schiene den anderen.\par
Nice.\par
\par
ComHost.Configuration weiterbauen.\par
\par
Endianess Typ selber implementieren oder java.nio.ByteOrder nehmen?\par
Das java.nio Ding ist halt der \'fcbliche Rotz mit fehlenden "forName" Methoden usw.\par
Andererseits w\'e4r es schon sehr extravagant, das nachzuimplementieren und einen l\'e4stigen Konverter Zwischenschritt aufzuzwingen.\par
Also lieber ByteOrder nehmen. Und erst mal das fehlende und sp\'e4ter n\'f6tige forName nachimplementieren. Hoffentlich wird der Hass nicht zu gro\'df.\par
\par
Ein read-only PersistenceTypeDictionary erfordert erst mal einen entsprechenden Typ, der nur lesende Funktionalit\'e4t anbietet.\par
Auftrennen in retrofitteten Supertyp PersistenceTypeDictionaryView.\par
\par
Leider auch \'e4hnlich bei der TypeLineage.\par
\par
Ableitende Konstruktoren implementieren.\par
Concurrency-Handling anpassen.\par
\par
Gibt paar Typkonflikte durch die Auftrennung. L\'f6sen mit zus\'e4tzlichen Methoden.\par
\par
\par
22:15 Weitermachen.\par
\par
\par
\par
2018-11-01\par
\par
Der ComHost muss viel mehr modularisiert werden, denn es kann sein, dass alles nach dem blanken Socket-Verbindungsaufbau von einem anderen Thread gemacht werden soll/muss.\par
Also so:\par
- Verbindungsaufbau\par
- Metadatenabgleich & Channelinstanzierung\par
- Channel weiterverwenden.\par
Jeder dieser Punkte kann im selben oder in einem eigenen Thread behandelt werden.\par
\par
\par
2018-11-02\par
\par
Die Configuration bytes m\'fcssen noch terminiert werden.\par
Ein Stop-Pattern ist genauso sicher oder unsicher wie ein length header, aber letzteres ist effizenter. Dann mach ich gleich wieder das, auch bei einem blanken String.\par
\par
ComConfiguration sollte besser ComProtocol hei\'dfen.\par
Umbenennen und ein bisschen aufr\'e4umen.\par
\par
Labels und Separator definieren.\par
\par
Code TODOs abarbeiten.\par
\par
Eigentlich sind die Protocol Einzwelwerte und die Protocol Instanz in der ComFoundation redundant. Das ist immer bl\'f6d.\par
Was w\'e4re besser?\par
Nur die Instanz? Dann muss man die aufgrund des Bezugs zum TypeDictionary aber immer explizit setzen, was auch seltsam ist.\par
Nur die Einzelwerte? Evtl. einen ComProtocol.Creator setzen k\'f6nnen?\par
Eine Nested ProtocolFoundation?\par
Ein TypeDictionaryProvider?\par
\par
Und, interessant bzw. wichtig:\par
Wenn es keine Indirektion f\'fcr das TypeDictionary gibt, dann muss das finale TypeDictionary schon zum Zeitpunkt der ComHost Erzeugung feststehen.\par
Oder ist das okay so, weil ein Netzwerk-Tor nach au\'dfen erst ge\'f6ffnet werden sollte, wenn die Typ-Interna der Anwendung (DB Initialisierung usw.) abgeschlossen ist?\par
Allerdings k\'f6nnte es schon sein, dass in einer Anwendung erst mal alle Kernbestandteile erzeugt werden und die dann in einer vern\'fcnftigen Reihenfolge gestartet werden (erst DB, dann Kommunikation).\par
\par
Umbauen auf Creator und Provider Variante.\par
\par
SwizzleIdStrategy muss doch weiter aufgeteilt werden, wenn es sauber als String assemblebar sein soll.\par
\par
Hm. Irgendwie ist es bl\'f6d, immer einen "Assembler" zu bauen und dann einen extra "Parser", der sich die ganzen Symbols usw. nochmal halten muss.\par
Warum nicht ein Kombi-Ding. Guten Namen \'fcberlegen.\par
StringConverter. Genau.\par
So bauen f\'fcr ComProtocol.\par
\par
F\'fcr SwizzleIdStrategy auch nochmal n\'f6tig.\par
Zeigt: Anwendungsfall f\'fcr einen generisch abstrahierten Typ.\par
Bauen.\par
\par
Protocol Assembly Logik bauen. Gleich h\'fcbsch les- und wartbar.\par
\par
\par
\par
2018-11-03\par
\par
TODOs abarbeiten.\par
TypeDictionaryProvider.\par
\par
\par
\par
2018-11-04\par
\par
Parserlogik implementieren.\par
Test f\'fcr StringConverter (assembling und parsing) bauen.\par
IdStrategy Zeug fehlt noch und die Aufl\'f6sung der geparsten Werte.\par
\par
Hm. Vielleicht sollte es ein interface geben, das TypeDictionary und IdStrategy zur\'fcckgibt. So k\'f6nnte man eine ComFoundation sehr einfach mit einem PersistenceManager verbinden.\par
\par
\par
SwizzleIdStrategy Aufteilung verbessern, durchdenken und implementieren.\par
\par
\par
\par
2018-11-05\par
\par
SwizzleIdStrategyStringConverter Konzept durchdenken und verbessern.\par
\par
\par
Zwischendrin mal schnell recherchieren zu FH's Wunsch nach einer expliziten "TypeNotFound" Exception anstatt einer provisorischen RuntimeException.\par
Ergebnis:\par
Alle Typaufl\'f6sungen laufen \'fcber entweder Persistence#resolveType oder Persistence#tryResolveType.\par
Das erste wirft bereits eine PersistenceExceptionTypeConsistencyDefinitionResolveTypeName, das zweite gibt absichtlich nur null zur\'fcck.\par
Ich habe die Stellen, in denen die try~ Variante aufgerufen wird, nach provisorischen Exceptions abgesucht, aber nichts gefunden, das der Bitte von FH entsprechen w\'fcrde.\par
Dann habe ich noch alle Vorkommen von "proper exception" (marker f\'fcr provisorische Exceptions) im Persistence Projekt abgesucht, auch kein Treffer.\par
Vielleicht sind andere Exceptions gemeint (type mismatch usw.) oder hier liegt irgendwie ein Misverst\'e4ndnis vor.\par
\par
SwizzleIdStrategyStringConverter weitermachen.\par
\par
\par
2018-11-06\par
\par
Ich trage mal ein paar Gedanken nach, was ich die letzten Tage so implementiert habe:\par
Ich habe einen eigene assembler und parser (kombiniert "StringConverter") f\'fcr das ComProtocol, f\'fcr die darin genestete IdStrategy und die wiederum darin genesteten Type- und ObjectIdStrategies implementiert.\par
Gleich sauber und ordentlich, dynamisch erweiterbar bei zuk\'fcnftig neuen IdStrategy Typen, usw.\par
\par
Ich habe daf\'fcr in Summe einige Tage gebraucht. Wie viel genau, ist schwer zu sagen, weil parallel dazu Konzept, andere Code Teile, usw. mit gereift sind. Es war auf jeden Fall mehr als ein MT und weniger als eine MW. Den Rest kann man sich aussuchen. 2 MT? 3 MT? So in der Richtung.\par
Die Frage ist an solchen Stellen oft immer: Muss man das selber programmieren? Kann man da nicht einfach ein JSON Framework oder sowas nehmen.\par
\par
Zahlreiche Erfahrungen f\'fchren immer zu folgendem Schluss:\par
- Ein Fremdframework muss man auch erst mal einbauen, d.h. verstehen, konfigurieren, testen, usw.\par
- Meistens haben die absurde Einschr\'e4nkungen, die einem das Leben einfacher anstatt schwerer machen.\par
- Meistens haben sie auch Bugs, von katastrophaler API ganz zu schweigen.\par
- Man hat Abh\'e4ngigkeiten zu Drittanbietern, muss f\'fcr Bugfixes oder neue Features auf deren Releasezyklen warten, muss bei neuen Versionen dann wieder refactoren, neu testen, neue Bugs workarounden, usw.\par
- Mit diesem ganzen Mist etwas zu bauen, das f\'fcr die zukunft dynamisch erweiterbar ist, ist oft sehr aufwendig bis unm\'f6glich (Framework in die Tiefe verstehen und den ganzen Scheissdreck darin workarounden).\par
\par
Das ist keine theoretische Schlechtrederei. Wir haben das alles mehrfach mitgemacht.\par
\par
Mit all dem kommt man mittelfristig auf deutlich mehr Aufwand, als wenn man es gleich selber programmiert und langfristig ruiniert man sich das eigene Framework damit (Einschr\'e4nkungen usw.) oder muss irgendwann wechseln (zu dem n\'e4chsten Scheissdreck) oder es doch selbst schreiben.\par
\par
Auch wenn es f\'fcr den Au\'dfenstehenden/Unerfahrenen/Naiven (kein Vorwurf) zun\'e4chst paradox klingt: Die langfristig BESTE L\'f6sung, vor allem was Aufwand, aber auch Stabilit\'e4t, Wartbarkeit, usw. angeht, ist es, sich Zeug selbst zu schreiben.\par
Zumindest ist das meine Erfahrung. Man muss es nat\'fcrlich gut machen und nicht einfach nur schlechteren Scheissdreck bauen, als der andere Scheissdreck ist. Sonst ist der andere Scheissdreck nat\'fcrlich die versiertere L\'f6sung.\par
\par
Das hab ich inzwischen so gut wie fertig und getestet. Aktuell ist das Problem nur noch, dass der TypeDictionary String fehlt, weshalb der Parser - ganz zurecht - Eine Exception \'fcber ein vorzeitiges Ende bzw. Unvollst\'e4ndigkeit der Daten wirft.\par
\par
Das muss ich noch fixen.\par
Und dann muss ich leider noch eine TypeDictionary Builder "light" Implementierung bauen (der fr\'fcher mal auch selbstgeschriebene TypeDictionaryParser funktioniert einwandfrei und kann mitverwendet werden), die ohne die ganzen Refactoring- und Legacy-Type-Mapping-Logik auskommt, damit der Client sich einfach nur eine Struktur bauen kann zu dem TD, das ihm geschickt worden ist.\par
\par
Dann ist JET-43 fertig.\par
\par
Die gute Nachricht ist: Durch Synergieffekte ist dabei auch schon viel Fortschritt f\'fcr JET-45, JET-46, JET-47 abgefallen.\par
Insgesamt also gar nicht mal so langsam. Und daf\'fcr auch noch eine gescheite L\'f6sung, \'fcber die wir wartungstechnisch volle Kontrolle haben.\par
\par
\par
19:00\par
So, mal schauen, wie das mit dem leeren TypeDictionary ist.\par
\par
Das ist wirklich leer. Mal schauen, warum. Das sollte eigentlich bei der Initialisierung gef\'fcllt werden.\par
Hm. Die TypeDictionary Intialisierung ist seit dem LegacyTypeMapping gar nicht mehr so einfach ...\par
Mal Methodenaufrufe verfolgen.\par
\par
Ich start jetzt einfach mal einen Storage Test und debug das durch ... ^^.\par
\par
Exception: Stackoverflow.\par
Den untersuchen.\par
Ah, die neue BaseException ruft this.getMessage anstatt von super auf.\par
\'c4ndern. Passt.\par
\par
Eigentliche Storage Exception: FileNotFound.\par
Hm. Eigentlich sollte das default storage Verzeichnis bei Bedarf angelegt werden.\par
Ich hab da neulich rumgebaut. Bei dem Test dazu ging es aber noch.\par
Also mal das untersuchen ...\par
\par
\par
Aach, das lag an den \'c4nderungen der Konstruktor-Namen. Entweder hat Eclipse das nicht richtig refactort oder ich hatte dabei einen Fehler gemacht.\par
Gefixt. Geht wieder.\par
\par
Beim rumtesten mit einem direkt initialisierten TypeDictionary aufgefallen:\par
BinaryPersistence#defaultHandlers m\'fcsste eigentlich noch \'fcber Swizzle#createDefaultTypeLookup oder #getNativeTypeId die TIDs initialisieren, sonst sind die bei einem Neustart alle 0 und die validierung der TypeDescriptions wirft eine Exception.\par
Die interessante Frage ist aber noch: Warum landen sie dann beim ersten Lauf korrekt in der TypeDictionary Datei?\par
Ach, das kommt \'fcber das Registrieren in der SwizzleRegistry und dem Typanalysieren.\par
\par
\par
\par
2018-11-07\par
\par
Schnell eine Initializer Methode f\'fcr die native types bauen.\par
Funktioniert wie geplant, aber l\'f6st das Problem nicht: XCollections usw. haben keine native TypeId. Die haben weiterhin 0.\par
Also die Initializer Methode war gut, das verhindert mal Inkonsistenzen in anderen Situationen, aber das eigentliche Problem ist (nur), wie ich im Beispiel das TypeDictionary provisorisch initialisiere.\par
Das muss, falls m\'f6glich, aus dem File kommen, nicht jedes mal neu transient initialisiert werden.\par
\par
Provisorischer Fix: Wenn providetes TypeDictionary leer, dann default handler registrieren.\par
Das muss nat\'fcrlich irgendwie sauber in den TypeDictionaryBuilder rein.\par
\par
Und seltsam: im so exportierten TypeDictionary steht der Substitutor mit TID 0. Warum nur der?\par
Recherchieren.\par
Ah, nat\'fcrlich!\par
Der ist der letzte in den Default Handlers. Alle non-native Handlers haben TID 0, d.h. der letzte ersetzt in der per-TID-Table alle vorherigen.\par
Im TypeDictionary fehlte eine Validierung, dass alle zu registrierenden TypeDefinitions eine initialisierte TypeId haben. Vor dem Legacy Type Mapping war das nicht n\'f6tig, weil die zwangsweise schon ihre TypeId hatten.\par
Jetzt ist das etwas komplizierter.\par
\par
Au\'dferdem hei\'dft das:\line Es muss unterschieden werden zwischen "nativeHandlers" (alle mit festgelegter TypeId) und "defaultHandlers" (alle native plus vorgefertigte Handlers, die aber keine feste TypeId haben).\par
Standardm\'e4\'dfig initialisiert werden darf nur mit den native Handlers.\par
\par
TypeDictionary TypeId Validierung einbauen.\par
Und gleich im TypeDictionaryManager einbauen.\par
\par
Ach, jetzt wei\'df ich, wie die "richtige" Initialisierung eines TypeDictionaries geht:\par
Der TypeDictionaryManager managet ja nur speichern, laden, registrieren.\par
F\'fcr das ganze TypeHandler- und TypeId-zeug gibt es ja den TypeHandlerManager, der intern die default handlers und den TDM kennt.\par
Der hat n\'e4mlich auch die passende initialize() Methode, die das alles richtig miteinander verkabelt.\par
\par
Also Test-Main auf diesen Typ umbauen.\par
\par
Die Native Handler Unterscheidung war trotzdem gut.\par
Noch paar kleinere Verbesserungen einbauen und TypeHandlerManager erzeugung kommentieren.\par
Passt.\par
\par
Dann kann ich jetzt ja endlich die Parsing Exception bei vorhandenem TypeDictionary untersuchen.\par
\par
So. Paar Fl\'fcchtigkeitsfehler gefixt. Jetzt fehlt nur noch das TypeDictionary Parsing.\par
Hm. Die Frage ist, ob das LegacyTypeMapping da wirklich au\'dfen vor sein soll.\par
Bzw:\par
Das LTM deckt ja nur eine Richtung ab: lesen.\par
Was bei TypeMapping f\'fcr Kommunikation n\'f6tig w\'e4re, w\'e4ren ja beide Richtungen: fremdes Format auf die eigenen Strukturen konvertierend einlesen und beim Senden die Daten der eigenen Struktur wieder ins fremde Format bringen.\par
D.h. ein der aktuellen Struktur entsprechendes Schreiben braucht man hier niemals bzw. darf man gar nicht machen.\par
Das hei\'dft nat\'fcrlich auch: Das LTM, so wie es jetzt ist, also zum Daten speichern, kann man f\'fcr Kommunikation nicht brauchen.\par
\par
Hm. Andererseits: Wenn man Daten in einer aktuellen Struktur vorliegen hat und die zum Schreiben/Versenden in eine andere Struktur konvertiert werden und dabei Daten verworfen werden, dann w\'fcrde man etwas verschicken in der Annahme, dass es ankommt, was in Wirklichkeit gar nicht so w\'e4re. Das darf nicht passieren.\par
Also zumindest das weglassen von Daten d\'fcrfte bei der Konvertierung nicht vorkommen.\par
Eigentlich gilt genauso: Felder, die der Host erwartet, d\'fcrfen nicht einfach null bleiben.\par
Und Felder mit Daten, die der Host sendet, d\'fcrfen beim Client nicht einfach ignoriert werden.\par
Das alles w\'e4ren Fehler.\par
Also triviale \'c4nderungen wie Namens\'e4nderungen ja. Oder \'e4ndern der Feldreihenfolge ja. Aber keine verlustbehafteten \'c4nderungen.\par
\par
Darf es damit vielleicht bei Kommunikation \'fcberhaupt kein Mapping von Datenstrukturen geben?\par
Immerhin ist das LTM nur daf\'fcr da, die physikalisch persistent vorliegenden Daten im alten Format wieder lesen zu k\'f6nnen. Bei Netzwerkkommunikation gibt es keine Persistenz, bzw. nur eine vor\'fcbergehende, die in jedem Fall am Ende wieder verworfen wird. Man k\'f6nnte hier ohne Verlust einfordern, dass alle Teilnehmer dieselbe Datenstruktur haben.\par
\par
Praktisch gesehen wird es nat\'fcrlich doch wieder irgendwann kommen, dass es hei\'dft, es m\'fcsse auch ein veralteter Client mit einem neueren Server sprechen k\'f6nnen, weil updaten w\'e4re ja m\'fchsam, blablabla.\par
Ganz genau genommen h\'e4ngen die Fehlerquellen oben nat\'fcrlich von der jeweiligen Situation ab. Konkrete Anwendung bzw. bis runter zu einer einzelnen Klasse. Das m\'fcsste man den Anwender in Eigenverantwortung entscheiden lassen.\par
\par
Nichtsdestotrotz ist das ganze Thema bei Kommunikation nicht so dr\'e4ngend wie bei Persistierung. Eine Zeitlang kann man schon zumuten, dass Host und Client gleiche Datenstrukturen verwenden m\'fcssen.\par
Es k\'f6nnen nicht alle Features auf einmal da sein und wir brauchen ja auch noch Arbeit f\'fcr die n\'e4chsten 10 Jahre ...\par
\par
Auf jeden Fall hei\'dft das jetzt konkret:\par
Ich brauch einen TypeDictionaryProvider, der den String parst, TypeDictionary Strukturen baut und runtime type resolving macht.\par
\par
Recherchiert:\par
Eigentlich brauch ich nur Parser+Builder, ohne Loader.\par
Das hei\'dft: Eigentlich k\'f6nnte Provider bestehen aus Loader + X und der ComProtocol Parser verwendet dann nur den X. Damit w\'e4re keine eigene Implementierung n\'f6tig.\par
Das einzige Problem, das ich dabei hab, ist: Es ist kein Name mehr frei!\par
Belegt sind schon Parser, Builder, Creator.\line Den Builder weiterhin vom Parser getrennt halten, ist auch gut so.\par
Alles, was mir sonst so einf\'e4llt, klingt kaum aussagekr\'e4ftig. Etwa "Processor" oder "Converter" oder "Compiler". Vielleicht "LoadProcessor", weil das der ist, der das Zeug vom Loader verabreitet. Aber toll ist das nicht.\par
Oder doch Compiler? Der String ist der TypeDictionary "Sourcecode" und das fertige TypeDictionary ist das "Kompilat".\par
Hm...\par
\par
\par
\par
23:30\par
\par
TypeDictionaryCompiler in Com Foundation einbauen.\par
\par
Hm. Oder eigentlich ist das ja schon in der BinaryPersistenceFoundation drin, die die ComFoundation sowieso an irgendeinem Punkt braucht.\par
Mal anschauen ...\par
\par
\par
2018-11-08\par
\par
PersistenceFoundation einbauen. Passt!\par
\par
Hm. Evtl. sollte die API nicht hardgecodet auf SocketChannel festgelegt werden, sondern parametrisiert werden.\par
Ich wette, dass die JDK Implementierung - wie immer - totaler Rotz ist und dass es was besseres gibt bzw. zuk\'fcnftig aus irgendeinem Grund mal was anderes gefordert werden wird.\par
Das ist auch gar nicht viel zu machen ein paar <C> dranh\'e4ngen und 1-2 abstrakte Zwischenklassen f\'fcr triviale Logikklassen einziehen. Das probier ich mal.\par
\par
\par
2018-11-09\par
\par
Mal recherchieren, ob es wirklich f\'fcr alle F\'e4lle reicht, einen ServerSocketChannel ohne IP Adresse zu erzeugen.\par
Aha:\par
{{\field{\*\fldinst{HYPERLINK https://stackoverflow.com/questions/11931175/what-does-wildcard-address-in-inetsocketaddress-mean }}{\fldrslt{https://stackoverflow.com/questions/11931175/what-does-wildcard-address-in-inetsocketaddress-mean\ul0\cf0}}}}\f0\fs28\par
\par
From the docs: The wildcard is a special local IP address. It usually means "any" and can only be used for bind operations.\par
The value of this IP address is 0.0.0.0. If you have two network adapters, one with IP address 1.1.1.1 and one with IP address 2.2.2.2, then you can create a listening socket and bind it to 1.1.1.1 so that the socket will not bind to 2.2.2.2. You can also create a listening socket and bind it to 2.2.2.2, so that it will not bind to 1.1.1.1. If you do not care and want your socket to bind to all network cards, then you bind it to the wildcard address.\par
Another special value would be 127.0.0.1, meaning that only clients on the same computer could connect to your server.\par
\par
Hei\'dft: Auch ComHost Instanzen brauchen eine InetSocketAddress Instanz, nicht nur einen Port.\par
Umbauen.\par
\par
Au\'dferdem aufgefallen:\par
Falls jeder Client eine eigene ID-Range bekommen k\'f6nnen soll, dann das Protocol nicht schon zur Initialisierungszeit auf eine Range festgelegt werden.\par
D.h. es muss zwischen Initialisierung und ProtocolCreator noch eine ProtocolProvider Instanz rein. Die kann defaultm\'e4\'dfig einfach ein von Anfang an konstantes Protocol zur\'fcckgeben, aber kann eben auch dynamisch neue machen.\par
\par
Dann fliegt auch gleich das seltsame clearCachedProtocol() wieder raus. Nice.\par
\par
Konsolidierung der ganzen create~, ensure~ und supply~ Methoden mit schl\'fcssigem Gesamtkonzept\par
\par
Explizite Unterscheidung zwischen clientIdStrategy und hostIdStrategy.\par
\par
\par
Als n\'e4chstes steht an:\par
- Default-Implementierung f\'fcr SocketChannel machen.\par
- Spezifische BinaryPersistence Implementierungen.\par
Evtl. beides in Foundation Ableitung reinmachen.\par
\par
\par
\par
2018-11-10\par
Default-Implementierung f\'fcr SocketChannel machen.\par
\par
\par
2018-11-12\par
Default-Implementierung f\'fcr SocketChannel weitermachen. Connectionlistener usw.\par
\par
Hm. Vielleicht kann man das doch so umstrukturieren, dass diese ganzen "ComDefault" Interfaces nicht n\'f6tig sind. Denn das wird langsam ein bisschen l\'e4stig vor lauter Abstraktion.\par
Mit einem "ComPersistenceAdaptor" Typ m\'fcsste das klappen.\par
\par
Da kommt dann auch gleich die TypeDictionaryProviding Logik rein. Das TypeDictionary muss ja aus dem Persistence Kontext kommen, also genau richtige Stelle.\par
\par
Soweit alles umgebaut, inklusive Testklasse. Mal testen.\par
Exception "Missing type id at index 0."\par
Hm, seltsam. Der Protocol String sieht unver\'e4ndert korrekt aus.\par
Muss ich dann checken und fixen.\par
\par
22:20\par
\par
Ach, der Input f\'fcr den TypeDictionary Parser hat ein "TypeDictionary" vorne dran.\par
Mal schauen, warum das falsch geschnitten wird.\par
\par
Ah, schnell gefunden: Wieder mal i und iStart verwechselt ...\par
Testen. Fehler behoben.\par
\par
Jetzt paar TODOs abarbeiten. Zentralisierte Util-Logik usw.\par
\par
\par
2018-11-13\par
\par
"ComDefault" besser benennen: ComBinary.\par
Ebenso Methoden darin.\par
Kommentar verbessern.\par
ComHost#start auf #run umbenennen.\par
Locking-Fehler darin korrigieren.\par
Erkl\'e4rende Kommentare in ComBinary Methode und aufrufenden Methoden verbessern.\par
TODO f\'fcr interessante Frage im Fehlerfall notieren.\par
\par
Hm. Das wirft eine ganze Reihe von Fragen zu potenziellen Problemen auf und Fragen zu den Fragen, welche der potenziellen Probleme wirklich vorkommen k\'f6nnen oder schon von niederen Com-Layern ausgeschlossen werden.\par
Zum Beispiel:\par
- K\'f6nnen zwischen nio Sockets gesendete Bytes verloren gehen?\par
- K\'f6nnen zwischen nio Sockets gesendete Bytes ver\'e4ndert werden?\par
- K\'f6nnen zwischen nio Sockets gesendete Bytes verdoppelt werden?\par
Vielleicht sind das naive Fragen, weil die Layers darunter mit Checksums usw. schon pr\'fcfen und neu versuchen, usw., bis die Bytes korrekt \'fcbertragen worden sind, aber mir fehlt da einfach das Wissen.\par
\par
- Kann ein read/write auf einen nio Socket unvollst\'e4ndig zur\'fcckkehren? (unvollst\'e4ndig hei\'dft: es soll z.B. ein ByteBuffer mit 8 byte inhalt geschrieben/gelesen werden, es werden aber mit einem Aufruf nur 6 byte verarbeitet)\par
Die JavaDoc von SocketChannel#read sagt, dass man nur eine Garantie \'fcber 1 gelesenes Byte nach der R\'fcckkehr der Methode hat.\par
Analog bei #write: Es sollten zwar "eigentlich" alle bytes geschrieben werden, aber so richtig drauf verlassen kann man sich anscheinend nicht.\par
Also muss man so eine Zusammenst\'fcckel-Logik selbst schreiben?\par
Wenn ja, wirft das neue Fragen auf:\par
- Zul\'e4ssiger Timeout zwischen zwei empfangen Bytes?\par
- Zul\'e4ssige Anzahl a versuchen?\par
- Zul\'e4ssiger Timeout seit Beginn der \'dcbertragung? Macht sowas Sinn? D.h. falls die Datenrate zu niedrig wird irgendwann abbrechen?\par
\par
Mit dem XSockets#performIoOperation hab ich fr\'fcher schon mal versucht, sowas in die Richtung zu bauen, aber eigentlich basiert das nur auf wilden Vermutungen von mir.\par
\par
Was ist bei solchen Fehlerf\'e4llen? Kann/muss man da irgendwie fumfunken, es nochmal zu versuchen, oder muss man nicht eigentlich den Socket dann gleich ganz schlie\'dfen?\par
\par
\par
Noch paar TODOs machen bzw. Code aufr\'e4umen.\par
ComPersistenceChannel auf abstraktes <C> umstellen.\par
\par
Jetzt mal den Parser durchgehen, ob wirklich \'fcberall ein Check auf iBound gemacht wird.\par
Paar Kleinigkeiten fixen.\par
\par
Jetzt w\'e4r noch die Frage, ob man die drei usage-spefizischen Punkte nochmal zu einem Typ zusammenfasst. Eigentlich schon, macht Sinn.\par
\par
Mal bauen.\par
\par
\par
23:30\par
\par
ComHostContext Default mit SocketChannel Typisierung bauen.\par
Es reicht ja v\'f6llig, wenn die generische/abstrakte Variante zur Verf\'fcgung steht, aber als Defaults werden \'fcberall SocketChannel Typisierungen und Implementierungen verwendet.\par
\par
TODO Cleanups.\par
\par
\par
2018-11-14\par
\par
Mist. Die Arbeit von der halben Stunde gestern Abend hatte ich daheim nicht committet.\par
Schnell nochmal nachvollziehen:\par
- Default-Implementierungen mit Typisierung auf SocketChannel f\'fcr ComHostContext und seinen Builder\par
- TODO in ComPersistenceChannelBinary machen: Buffer Vorbereitung in ComBinary#setChunkHeaderContentLength verschieben\par
- MainTest-Klasse anpassen\par
- ComHostContext.Builder#setChannelAcceptorLogic umbenennen, um die Lambda-Mehrdeutigkeit f\'fcr den Compiler aufzul\'f6sen.\par
\par
Ging deutlich schneller als die halbe Stunde gestern, weil ich die Denkarbeit ja noch im Kopf hatte :-).\par
\par
\par
Jetzt Client-Seite:\par
\par
Als Gegenst\'fcck zu dem ComHost muss es einen ComConnector oder sowas geben, der macht:\par
- Verbindung aufbauen (gibt's schon)\par
- Geschicktes Protokoll parsen (gibt's schon)\par
- Das TypeDictionary daraus in einem TypeDictionaryProvider f\'fcr die Client-Persistence-Seite verwenden.\par
\par
Hm. Das wird interessant:\par
Beim Host ist es so, dass es den Persistence-Kontext schon geben muss und der wird in den Com-Kontext eingebracht, weil Daten vom Persistence-Kontext zum Com-Kontext fliesen (n\'e4mlich das TypeDictionary)\par
Beim Client ist es anders rum: Das TypeDictionary fliest vom Com-Kontext als Quelle in den Persistence-Kontext, damit die Anwendungslogik die Persistierung verwenden kann.\par
\par
Es muss erst mal einen ComClient geben, der die Host-Adresse kennt.\par
Der muss ein "connect()" haben, das dann einen ComChannel zur\'fcckgibt.\par
Und der ComClient muss das protocol providen k\'f6nnen, nachdem verbunden wurde.\par
Oder sollte das nochmal ein extra Typ sein? Eine ComConnection, die erzeugt wird, nachdem das Protocol empfangen und geparst wurde? Ansonsten hat man nur eine Instanz, die manchmal was valides zur\'fcckgibt und manchmal nicht. Das w\'e4r doof. Besser w\'e4r: Wenn eine ComConnection zur\'fcckgegeben wird, dann ist die auch immer valide.\par
\par
Bl\'f6d w\'e4r dann aber, dass die H\'e4lfte der Server-Typen "ComConnection~" hei\'dfen, aber der Server selber gar keine ComConnection verwendet.\par
Vielleicht w\'e4re es dann doch so besser:\par
- ComConnector: kennt eine HostAdresse und erzeugt ComClients\par
- ComClient: h\'e4lt eine aktive Verbindung / ComChannel und ein erfolgreich geparstes Protocol\par
\par
Das w\'fcrde auch f\'fcr folgendes gut passen:\par
Der Connector h\'e4lt intern nur eine PersistenceFoundation.\par
Der Client h\'e4lt einen erzeugten PersistenceManager, basierend auf dem TypeDictionary aus dem erfolgreich geparsten Protocol.\par
\par
So m\'fcsste es gut sein.\par
\par
Die Frage ist dann noch:\par
Was gibt ComConnector#connect genau zur\'fcck? Einen ComChannel oder einen ComClient?\par
Bei ComChannel fehlt die R\'fcckreferenz auf den ComClient.\par
Bei ComClient m\'fcssen die DAUs schon wieder eine Methode mehr aufrufen, das f\'fchrt wieder dann zu Verwirrung.\par
Vielleicht m\'fcsste man dann einen ComClientChannel extends ComChannel machen und der Connect gibt einen ClientChannel zur\'fcck.\par
\par
Dann ist auch noch die Frage nach dem closen einer Verbindung.\par
Ein ComClient h\'e4lt immer nur einen Channel. Das ist nicht "Der Client", der mehrere Verbindungen haben kann, sondern das ist eine Repr\'e4sentation, dass der Client-Prozess ein Client f\'fcr eine Adresse ist. Man kann mehrere ComClient Instanzen haben, mit potenziell unterschiedlichen Protokollen / TypeDictionaries.\par
\par
Ein ComClient mit einmal geschlossenem ComChannel kann nicht wieder aktiviert werden, weil sich das Protocol/TypeDictionary des Hosts in der Zwischenzeit ge\'e4ndert haben k\'f6nnte.\par
Es gibt also nur: ComConnector#connect -> neue ComClient Instanz mit exklusiver ComChannel Instanz -> Verwendung -> close\par
\par
So mal implementieren ...\par
\par
Haha, dabei aufgefallen:\par
Es gibt noch gar kein close() im PersistenceManager. F\'fcr Source und Target gibt es das, aber nicht f\'fcr den PM. Mal nachr\'fcsten ...\par
\par
Client Stuff weiter implementieren.\par
Dabei aufgefallen: ist ComClient nicht einfach ein \'fcberfl\'fcssiger Zwischenschritt zwischen ComChannel und ComConnector?\par
Der ComChannel m\'fcsste f\'fcr die Client-spezifischen Teile ja nur erweitert werden (ComClientChannel extends ComChannel).\par
Dann w\'e4re aber folgende Benamung doch besser:\par
ComClient ist das Basisding, analog zu ComHost.\par
ComClientChannel ist dann die aktive Verbindung.\par
Der ComClient h\'e4tte analog zum ComHost auch die Adresse. Passt.\par
Nur den Umweg mit dem Connection Listenen und accepten h\'e4tte er nicht, darum k\'f6nnte er die PersistenceFoundation direkt kennen.\par
\par
\par
\par
2018-11-15\par
\par
ClientChannelCreator implementieren, mit Binary Implementierung.\par
\par
TODO in ProtocolStringConvert schreiben, dass der flexibler werden muss.\par
F\'fcr den Moment passt der so und \'fcber die H\'e4lfte der Arbeit war allgemeine Parsing-Struktur und Konzepte und Utilmethoden, das bleibt auch bei einer \'c4nderung alles erhalten und war nicht umsonst.\par
\par
Protocol Assembling besser in eine zentrale statische methode packen.\par
\par
\par
Idee f\'fcr Usability:\par
In ComBinary eine Methode machen, die diesen Kontext als Default f\'fcr fehlende Teile im Com Kontext setzt.\par
Damit muss man aus der ganzen Binary Schiene nur eine statische Methode aufrufen und der Rest l\'e4uft \'fcber den allgemeinen Kontext.\par
Falls man customizen will, muss man sich sowieso mit den Details auseinandersetzen.\par
\par
\par
Hm. Noch eine Idee:\par
Anstatt ein dutzend "Abstract" Klassen mit einem Dutzend "Default" Implementierungen, die jede nur 1-2 Zeilen f\'fcr SocketChannel Handling enth\'e4lt, abstrahier ich noch ein kleines St\'fcck weiter zu einem Low-Level "ConnectionLogic" Typ, der die <C> produziert, schlie\'dft, schreibt, liest. Eine Implementierung daf\'fcr w\'e4re trivial zu verstehen und zu implementieren und alles andere m\'fcsste man nicht anfassen/ableiten/implementieren.\par
Das muss ich probieren, das ist super!\par
\par
Das ersetzt gleich den ComConnectionListenerCreator und den ComProtocolSender. Und der Code zum Protokoll senden und empfangen steht direkt nebeneinander, so dass man sich mit der Einhaltung des Formats bei der Implementierung sehr leicht tut.\par
\par
Fertig. Nur bei den beiden ComBinary Implementierungen muss ich mal noch \'fcberlegen, ob sich das konsolidieren l\'e4sst.\par
\par
\par
2018-11-16\par
\par
Ich mach am besten einen ReadOnly TypeDictionaryManager.\par
Daf\'fcr muss der TypeDictionaryView wieder "hochgecastet", bzw. gewrappt werden als TypeDictionary mit entsprechenden UnsupportedOperation Exceptions.\par
Implementieren ...\par
\par
Hm, bl\'f6d dabei: Die TypeLineageView Dinger sind auch nicht mehr typm\'e4\'dfig kompatibel zu den TypeLineages.\par
Bzw. das eigentlich bl\'f6de ist: Das sind durchaus mutable TypeLineage Instanzen, nur genericsm\'e4\'dfig registriert als TypeLineageView.\par
Aber eigentlich ist das bl\'f6d: Sie sind nicht wirklich immutable, was gef\'e4hrlich ist und man muss sie herumcasten oder alles einmal in die Tiefe umwrappen.\par
\par
Vielleicht w\'e4re es doch besser, das anders rum zu typisieren:\par
View extends das normale mit UnsupportedOperation Exceptions.\par
Denn die Verwendung ist ja eher so:\par
- Alle ver\'e4ndernden Operationen werden schon von den ~Manager Typen abgefangen und eine Exception geworfen.\par
- Alle lesenden Operationen, evtl. sogar direkt auf dem TypeDictionary, gehen ja.\par
\par
Trotzdem m\'fcsten die TypeLineages einmap umgewrappt werden in ~View Instanzen nach demselben Konzept. Wenn was immutable ist / sein soll / sein muss, muss es schon richtig immutable sein, sonst ist es scheisse.\par
\par
\par
\par
22:30\par
\par
Also jetzt muss mal der ComClientChannelCreatorBinary eingebaut werden bzw. \'fcberhaupt die Foundation Infrastruktur, um ComClient Instanzen zu erzeugen.\par
\par
Hm, dabei aufgefallen:\par
Der ComHostContext wird nur in der Foundation abgefragt, um die Einzelteile rauszuholen. Sollte der nicht insgesamt \'fcbergeben werden?\par
\par
provideChannelAcceptor\par
Wird benutzt in:\par
- createHost\par
(Sonst nirgends)\par
\par
provideSocketAddress\par
Wird benutzt in:\par
- createHost\par
(Sonst nirgends)\par
\par
providePersistenceAdaptor\par
Wird benutzt in:\par
- drei ensure~ Methoden.\par
\par
Hm. Dann passt das vorerst mal so.\par
\par
ComClient braucht noch einen Creator, so wie ComHost, falls man mal einen Wrapper rumlegen will oder so.\par
\par
Hm. Wenn die clientTargetAddress jetzt als einzelnes Datum in der Foundation liegt, dann w\'e4r es bl\'f6d, wenn die HostBindingAddress in dem eigentlich sinnlosen ComHostContext drinstecken w\'fcrde.\par
\par
Die Address Instanzen mal besser benennen.\par
\par
Soweit so gut. Aber die Koppelung von ComBinary an Com fehlt immer noch.\par
Evtl. muss ich das wirklich so machen, dass man von ComBinary aus eine Erzeugerlogik static in Com setzen kann.\par
\par
Au\'dferdem fehlt noch:\par
Ohne bereits vorhandenen Persistence Context des Servers muss einer on-demand erzeugt werden k\'f6nnen.\par
Das hei\'dft auch, es muss eine Liste an Typen geben, die man durchiterieren kann, f\'fcr die dann der Persistence Kontext initialisiert, d.h. TypeHandler erzeugt werden.\par
\par
\par
\par
2018-11-17\par
\par
ComClientChannelCreatorBinary einbauen.\par
Testklassen fertigbauen.\par
\par
Dabei aufgefallen: ComChannel sollte eine M\'f6glichkeit haben, auf die verwendete Connection zuzugreifen. Genauer gesagt: ComHostChannel und ComClientChannel sollten das jeweils bieten. Der Blanke ComChannel kann ohne Typisierung und ohne Quering Methode so bleiben, der ist ja h\'fcbsch simpel.\par
\par
Hm. Es g\'e4b ja sogar SocketChannel#shutdownOutput und ~Input. Aber f\'fcr den Moment erst mal nur TODOs machen.\par
Muss vor dem einbauen genauer untersucht werden, z.B., ob die JDK-Vollpfeiffen den "isClosed()" State dann richtig setzen. F\'fcr differenzierte querying-Methoden hats ja immerhin schon nicht mehr gereicht. Nur Deppen unterwegs im JDK.\par
\par
Jetzt mal testen.\par
\par
Hm: Beim Client muss man die PersistenceFoundation zweimal \'fcbergeben, f\'fcr zwei verschiedene Verwendungszwecke. Das ist etwas seltsam.\par
\par
Und, hehe: Beim Host wird noch \'fcberhaupt kein PersistenceChannel aus der Connection gemacht und gesetzt. Beim Client passiert das schon. Darum auch die zweite Stelle.\par
\par
Idee: Beide sollte auf beiden Seiten \'fcber den PersistenceAdaptor gehen.\par
Evtl. braucht der dann ein \'e4hnliches Konzept wie der ConnectionHandler.\par
\par
Implementieren ...\par
\par
Sieht soweit gut aus, aber der immutable TypeDictionaryManager muss auf no-ops pr\'fcfen, sonst fliegen beim client sinnlos exceptions\par
\par
\par
\par
2018-11-19\par
Idee: Com#bounce als uber-simplicity default Methode bauen, ausf\'fchrlich dokumentieren und verwenden.\par
Client- und Server-Convenience-Methoden bauen und testen.\par
\par
\par
Jetzt mal noch ein OGC-Issue anlegen f\'fcr "Convenience & Customization".\par
JET-52.\par
\par
Weitere Host-Convenience Methoden f\'fcr den ChannelAcceptor.\par
\par
Runnable interface implementieren.\par
\par
Paar kleinere Verbesserungen.\par
\par
Damit fehlt jetzt f\'fcr einen ersten Prototyp nur noch ein Default beim Host f\'fcr die PersistenceFoundation.\par
\par
\par
\par
23:00\par
Also erst mal defaults f\'fcr die IDs machen.\par
Bzw. die gibts ja schon. Mal schauen, wie ich die integrier und ob das so passt.\par
\par
Oh, dabei aufgefallen: Der ProtocolProvider gibt ja immer die gleiche IdStrategy f\'fcr den Client zur\'fcck. Das ist defaultm\'e4\'dfig schon richtig, aber es sollte/muss hier die M\'f6glichkeit geben, jedem Client eine andere IdRange mitzuteilen.\par
Ich denk es reicht, dem ProtocolProvider einfach die Connection zu \'fcbergeben. Falls es nicht reicht, den SocketChannel zu \'fcbergeben, muss man halt einen Wrapper schreiben, in dem vorher erst noch ein Username oder sowas festgestellt wird.\par
Also ausreichende M\'f6glichkeiten hat man damit auf jeden Fall.\par
\par
\par
\par
2018-11-20\par
\par
Host bzw. Host-TypeDictionary Initialisierung bauen.\par
Das ist knifflig:\par
- Braucht eine eigene IdStrategy und dementsprechende defaults.\par
- Braucht eine eigene Foundation Instanz und einen bequemen Weg, eine zu erhalten.\par
- Braucht einen transient TypeDictionaryManager.\par
\par
Hm. Damit man f\'fcr die eigene Foundation Instanz nicht umst\'e4ndlich doppelt Instanzen \'fcbergeben muss, muss sowas wie ein "clone()" her. Die haben die JDK Deppen nat\'fcrlich ruiniert. Hehe, dann mach ich einfach "Clone", weil es ja eine neue Instanz erzeugt.\par
\par
F\'fcr den TypeDictionaryManager macht es Sinn, die Implementierungen zu \'fcberarbeiten, um Redundanzen zu entfernen und weitere zu vermeiden:\par
- Abstract\par
- Exporting extends Abstract\par
- Transient extends Abstract\par
- Immutable extends Abstract\par
\par
Entsprechend umbauen.\par
\par
Initialisierung fertigbauen.\par
\par
Testen. Funktioniert auf Anhieb! \\o/\par
\par
Jetzt noch Convenience-Methoden entsprechend verbessern.\par
\par
Z.B. fehlt ja eine bequeme M\'f6glichkeit, die zu registrierenden Typen zu \'fcbergeben.\par
Ebenso die HostIdStrategy\par
Mal \'fcberlegen ...\par
\par
Eigentlich m\'fcsste beides in die ComFoundation rein und dann an den PersistenceAdaptor nur \'fcbergeben werden.\par
Das hei\'dft, es muss mal wieder eine zus\'e4tzliche Creator Indirektion geben.\par
\par
\par
Hmpf. Aber das macht dann Probleme beim Client. Muss ich sp\'e4ter noch hinbiegen ...\par
\par
\par
22:00\par
\par
Das l\'f6s ich ganz einfach: je eine creating Methode f\'fcr Client und Server. Die f\'fcr Client macht als default server mit 3x null.\par
\par
Hm. Dann muss es aber auch zwei Varianten von getPersistenceAdaptor() in der Foundation geben.\par
Aber warum auch nicht. Initialisiert wird ja immer nur eine und das zweite Feld st\'f6rt niemanden.\par
\par
So. Passt.\par
\par
Durchgehen und @FunctionalInterface erg\'e4nzen, wo m\'f6glich.\par
\par
Jetzt dann noch Host-Convenience-Methoden in ComBinary und dann sollt es soweit fertig sein.\par
\par
Implementiert. Bissl testen.\par
Exception wegen failing TypeId Provider bzw. da l\'e4uft eine Initialisierung in die falsche der beiden foundations rein.\par
Ah, ne, hehe: richtige Foundation Instanz, aber die IdStrategies waren verdreht.\par
Umgestellt. Getestet. Passt.\par
\par
Server Beispielklasse bissl aufr\'e4umen.\par
\par
Nachricht an MK.\par
\par
\par
\par
2018-11-21\par
\par
Issues-update-Marathon und JET-53 erstellen.\par
\par
Recherche zu JET-48 (Stateful & stateless Registry).\par
\par
Da gibts schon ein langes TODO im Code vom 31.10.2018 zu der rausmodularisierten ConstantRegistry, aber das ignoriert den entscheidenden Punkte, dass auch Lookups beim Laden zwei Lookups br\'e4uchten.\par
\par
Oh, interessant:\par
Seit Class Instanzen (aufgrund der Komplikationen durch das LTM) nicht mehr als Entities betrachtet werden, sondern als unhandlebare Metadaten, ist die ganze Registrierei von Types in der SwizzleRegistry hinf\'e4llig.\par
Die Types k\'f6nnen alle in eine eigene Doppel-HashTable direkt in der TypeRegistry rein.\par
Dann ist der ganze Type-Lookup Block schon mal komplett raus aus der Registry.\par
Also gehts nur noch um die Konstanten. Nice.\par
\par
\par
16:30\par
Zeiteintrag f\'fcr Aufwand f\'fcr Gehaltsdiskrepanzen kontrollrechnen f\'fcr TS.\par
\par
22:30\par
TypeRegistry aus SwizzleRegistry raustrennen. Refactoring.\par
\par
\par
2018-11-24\par
\par
TypeRegistry rausgetrennt, erfolgreich getestet und nebenbei noch ein paar kleinere Aufr\'e4umarbeiten, JavaDoc, TODOs gemacht.\par
Au\'dferdem einen Regression Bugfix, weil ich mit einem fr\'fcheren Aufh\'fcbschen von Code unbedachterweise die TypeHandler Registrierung f\'fcr die PersistenceRoots hinter die TypeHandler Initialisierung gezogen hatte, was nat\'fcrlich einen Fehler ergab. Ordentlich dokumentiert, damit das nicht nochmal passiert.\par
\par
\par
2018-11-25\par

\pard\par
Nix wegen Familienerk\'e4ltung.\par

\pard\sl276\slmult1\par
\par
\par
2018-11-26\par
\par
Nach einigen \'dcberlegungen zwischendurch: Das beste wird sein, die ObjectRegistry um Methoden f\'fcr ~Constant Handling zu erweitern.\par
Intern h\'e4lt die Implementierung sich einfach eine List an Entries mit den Constants und bei jedem clear werden die paar wieder dazugeaddet.\par
Braucht halt dann clear (nur Objects), clearAll, clearConstants Methoden.\par
\par
Wenn ich eh daran rumbau, w\'e4re es eine \'dcberlegung wert, gleich die inzwischen aufgelaufenen Ideen f\'fcr eine Verbesserung und evtl. auch algorithmus vereinfachung der ObjectRegistry umzusetzen.\par
Erst mal evaluieren, was memory-m\'e4\'dfig g\'fcnstiger w\'e4re ...\par
\par
Memory consumption without compressed pointers for a single entry:\par
\par
Entry:\par
- 16 byte object header\par
- 8 byte oid\par
- 8 byte hash int plus memory padding to 8 byte alignment\par
- 8 byte reference field to weakReference instance\par
\par
WeakReference\par
- 16 byte object header\par
- 32 byte for 4 reference fields\par
\par
8 byte per-oid-bucket array reference to the Entry instance\par
8 byte per-ref-bucket array reference to the Entry instance\par
\par
always:\par
104 byte\par
\par
\par
PLUS: \par
\par
default hash density of 1.0:\par
\par
slotsPerOid: 8 byte array entry reference to the bucket\par
24 byte bucket array header (1-element bucket is the common case!)\par
\par
slotsPerRef: 8 byte array entry reference to the bucket\par
24 byte bucket array header (1-element bucket is the common case!)\par
\par
additional: 64 bytes\par
\par
total: 168 bytes\par
\par
\par
\par
default hash density of 2.0:\par
\par
additional: 32 bytes\par
\par
total: 136 bytes\par
\par
\par
default hash density of 4.0:\par
\par
additional: 16 bytes\par
\par
total: 120 bytes\par
\par
default hash density of 8.0:\par
\par
additional: 8 bytes\par
\par
total: 120 bytes\par
\par
\par
With Entry extends WeakReference:\par
- 16 byte Object header\par
- 8 byte reference\par
\par
change: -24 bytes\par
\par
Meaning:\par
\par
1.0 hash density: 144 bytes\par
2.0 hash density: 112 bytes\par
4.0 hash density: 96 bytes\par
8.0 hash density: 88 bytes\par
\par
\par
\par
\par
With removed unnecessary hash field in Entry:\par
\par
1.0 hash density with explicit WeakReference reference: 160 bytes\par
2.0 hash density with explicit WeakReference reference: 128 bytes\par
4.0 hash density with explicit WeakReference reference: 112 bytes\par
8.0 hash density with explicit WeakReference reference: 104 bytes\par
\par
1.0 hash density with WeakReference-extending Entry: 136 bytes\par
2.0 hash density with WeakReference-extending Entry: 104 bytes\par
4.0 hash density with WeakReference-extending Entry: 88 bytes\par
8.0 hash density with WeakReference-extending Entry: 80 bytes\par
\par
\par
No Entry class at all but redundant arrays for OID and WeakReference:\par
\par
\par
WeakReference\par
- 16 byte object header\par
- 32 byte for 4 reference fields\par
\par
8 byte per-oid-bucket array reference to the WeakReference instance\par
8 byte per-ref-bucket array reference to the WeakReference instance\par
\par
WeakReference total: 64 bytes\par
\par
1.00 hash density:\par
- slotsPerOidOids (keys)  : 8 byte array entry reference to the bucket\par
- slotsPerOidRefs (values): 8 byte array entry reference to the bucket\par
- slotsPerRefRefs (keys)  : 8 byte array entry reference to the bucket\par
- slotsPerRefOids (values : 8 byte array entry reference to the bucket\par
- 24 byte slotsPerOidOids bucket array header (1-element bucket is the common case!)\par
- 24 byte slotsPerOidRefs bucket array header (1-element bucket is the common case!)\par
- 24 byte slotsPerRefRefs bucket array header (1-element bucket is the common case!)\par
- 24 byte slotsPerRefOids bucket array header (1-element bucket is the common case!)\par
\par
Hashing total: 128 bytes\par
\par
1.0 hash density total: 192\par
2.0 hash density total: 128\par
4.0 hash density total: 96\par
8.0 hash density total: 80\par
\par
With 16 elements per bucket: here 72 bytes vs. 76 bytes above.\par
\par
plus it would have a LOT less pointer chasing in every case\par
\par
\par
\par
23:00\par
\par
Konzeptnotizen:\par
\par
- buckets sind immer effective immutable.\par
- rebuild erst, wenn ein bucket besonders lang wird und wenn dann die aktuelle capacity \'fcberschritten worden ist.\par
\par
\par
\par
2018-11-27\par
\par
DefaultObjectRegistry Implementierung weitermachen.\par
JET-48 updaten.\par
\par
Am Rande Konstantenbenamungen und Beschreibung zu JSL Konstanten in Persistence Klasse verbessern.\par
Und Bug in hashLength padding in Klasse Hashing durchdenken, fixen und kommentieren.\par
\par
Nach dem allen in ca. 5 Stunden tut jetzt der Kopf weh ...\par
\par
\par
2018-11-28\par
\par
Mal DefaultObjectRegistry soweit abschlie\'dfen, dass sie verwendet werden kann. Nice-to-have Methoden als TODO vermerken. Aufr\'e4umen.\par
\par
\par
Testen. L\'e4uft schon mal auf Anhieb durch, aber mal paar debugging Ausgaben reinbauen.\par
A, fieser Fehler: da fehlt ein Math.ceil(), sonst rundet der long cast ab.\par
Testen. Passt.\par
Au\'dferdem ein "+ 1" beim bucket rebuilden vergessen, so dass er immer nur 1-elementige Buckets erzeugt hat. Haha.\par
Testen. Passt.\par
\par
HashStatistics und HashStatisticsBucketBased typen implementieren.\par
Inklusive String assembly.\par
Erzeugung in DefaultObjectRegistry daf\'fcr.\par
\par
Jetzt kann man die Hashingsverteilung der ObjectRegistry wunderbar auf Knopfdruck analysieren.\par
\par
Aufgefallen:\par
Es kommt noch sehr oft der Begriff "Swizzle" vor, obwohl das l\'e4ngst \'fcberholt ist. Rausrefactoren.\par
\par
Bisschen rumprobieren und kontrollieren mit verschiedenen HashDensities.\par
Sieht alles gut aus.\par
\par
\par
2018-11-29\par
\par
Also funktionieren tut die Implementierung, braucht deutlich weniger Speicher als die bisherige und w\'e4re potenziell auch genauso schnell oder schneller, aber die Tests haben gezeigt, dass das massive Bucket Array Instanzieren und umkopieren die Performance killt und den heap extrem schnell zum\'fcllt. Ein GC r\'e4umt das alles wieder auf, also nat\'fcrlich kein Memory Leak, aber die permanenten GC-Pausen machen dann die performance schlechter als das bisherige ist.\par
\par
Ich hab gestern daheim ein bisschen rum\'fcberlegt und auch schon implementiert und ein Konzept gefunden, dass die Vorteile beh\'e4lt, aber die Nachteile entfernt:\par
- Buckets mit mehr length als n\'f6tig machen. Der erste null-Eintrag kennzeichnet das Ende der Eintr\'e4ge\par
- daf\'fcr eine optimize() Methode, die einmal \'fcber alle buckets l\'e4uft und sie einmalig auf ein Bucket Array mit minimal n\'f6tiger L\'e4nger umkopiert.\par
- Damit man die nicht manuell aufrufen muss, bekommt die registry einen eigenen Thread, der das regelm\'e4\'dfig checkt.\par
- Der Thread macht dann auch gleich Stichproben nach Orphen Entries.\par
- Damit der Thread nicht l\'e4nger lebt, als die Registry, kriegt er eine weak R\'fcck-Referenz.\par
- Damit er einen Ladevorgang aus vielen (potenziell millionen) register Aufrufen nicht st\'f6rt, checkt er einen "lastRegister" Timestamp.\par
- Nat\'fcrlich ein paar Konfigurationswerte f\'fcr Check Interval, Wartezeit nach letztem Register, usw.\par
- Die Registry bekommt eine Start- und Stop-Methode f\'fcr den Thread. Z.B. f\'fcr die Verwendung in OGC mit stateless Kommunikation macht der Thread gar keinen Sinn.\par
- Ein register Aufruf checkt, dass der Thread l\'e4uft.\par
- Setzen der size auf 0 deaktiviert den Thread.\par
\par
Damit wird das eine rundum-sorglos ObjectRegistry mit minimalem Speicherverbrauch und trotzdem sehr hoher Performance.\par
\par
Jetzt muss ich das nur noch darauf umbauen.\par
\par
\par
\par
2018-12-10\par
\par
Siehe JET-48 Kommentare.\par
Mal recherchieren, wie das in dem Storer ist...\par
\par
Storer ObjectManager Verwendung:\par
\par
1.)\par
#apply\par
this.objectManager.lookupObjectId(instance)\par
\par
2.)\par
In #registerAdd\par
this.objectManager.ensureObjectId(instance)\par
\par
Ablauf:\par
1.) store aufruf (lazy)\par
2.) initialier registerAdd() Aufruf mit ensureObjectId(). Denn die \'fcbergebene Instanz wird immer gespeichert.\par
3.) item chain processing mit je einem apply() Aufruf pro Instanz\par
Apply Ablauf:\par
4.) storer-local OID-lookup\par
5.) this.objectManager.lookupObjectId(instance) ("lazy" storing)\par
6.) registerAdd() Aufruf mit this.objectManager.ensureObjectId()\par
\par
Zun\'e4chst mal ist hier Redundanz im Code:\par
Bei 5) wird ein lookupObjectId gemacht, bei 6) dann (intern) nochmal ein lookup und dann erst die neue ID vergeben.\par
Besser w\'e4re:\par
- lock holen\par
- lookup, wenn erfolgreich, OID zur\'fcckgeben\par
- ansonsten neue OID vergeben, lokal registrieren und zur\'fcckgeben.\par
- lock freigeben\par
\par
Das Dumme daran ist: Um das so zu machen, m\'fcsste die ObjectManager Kapselung hier aufgespalten werden. Das wiederum kann ObjectManager Implementierungen ruinieren bzw. unm\'f6glich machen.\par
\par
L\'f6sung:\par
Es muss eine ensureObjectId Variante mit callback geben, was getan werden soll, wenn eine neue ID vergeben wird.\par
Das mag eine zus\'e4tzliche Funktionsinstanz sein, aber immer noch sehr viel billiger als ein doppelter lookup und besser als eine ruinierte ObjectManager Implementierung.\par
\par
Variante implementiert. Storer darauf umgebaut. Kommentare zu lazy/eager Logik geschrieben.\par
\par
So. Damit zur\'fcck zum eigentlichen Thema: Wenn der ObjectManager f\'fcr das ContextDispatching nicht zerissen werden soll, muss es noch einen Zwischentyp geben. Einen ObjectIdEnsurer oder so. Mal rechechieren ...\par
Dabei paar Sachen aufr\'e4umen und umbenennen.\par
Den ganzen PersistenceBuilder Quatsch braucht eigentlich auch niemand. In Loader reinkonsolidieren.\par
Dabei createBuildItem Methode gefunden, die sich selbst aufruft. Kann ja wohl nicht sein. Recherchieren in \'e4lteren Branches.\par
Ach, da wurde das District Ged\'f6ns aufgerufen, das ich rausgel\'f6scht hab und dann unaufmerksam einen bug reinrefactort hab.\par
Fixen.\par
\par
ContextDispatcher erweitern f\'fcr Storer.\par
Allerdings kann mit einem durchgereichten ObjectManager ja noch immer keine Registry gewrappt werden ...\par
Hm. Es sei denn, macht gibt dem ObjectManager ein Clone().\par
Das w\'fcrde dann sogar gleich neue, resettete OidProvider Instanzen erzeugen.\par
Hm. K\'f6nnte passen.\par
\par
\par
\par
2018-12-11\par
\par
Mal Test laufen lassen.\par
\par
Aha, exception beim Laden:\par
Cached Integer Konstante wird in der Datenbank nicht gefunden. Das ist erst mal richtig, weil die ja nicht abgespeichert werden (sollte evtl. mal ge\'e4ndert werden), aber die Frage ist, wieso die Konstanten-ID \'fcberhaupt angefordert wird.\par
Mal recherchieren. Evtl. hat es was mit der Konsolidierung der Loaders oder mit dem Umbau der ObjectRegistry zu tun.\par
K\'f6nnte was mit handleKnownObject() und isUnrequiredReference() zu tun haben.\par
\par
Die constantsHotRegistry enth\'e4lt nur 132 Eintr\'e4ge, aber eine plausible size von 1154.\par
Debuggen.\par
\par
Aha:\par
Beim Hin- und Herbuilden der constants hot und cold registry muss was schief gehen.\par
\par
\par
Constants registration Ablauf:\par
1.) registerConstant() registriert in haupt-registry, stellt hot constants registry sicher, f\'fcgt dort hinzu.\par
2.) rebuild der haupt-registry stellt cold constants registry sicher.\par
Einfach mal printlns in die beiden building methoden reinbauen.\par
Debuggen ...\par
\par
Tja. Wenn man beim Umkopieren in Arrays den Index nicht inkrementiert, dann kommt \'fcberraschenderweise nur Mist raus.\par
Fixen.\par
Testen.\par
\par
Das sieht jetzt korrekt aus. Aber es gibt trotzdem noch fehlschlagende Lookups nach Konstanten-IDs, obwohl Konstanten registriert sind.\par
Debuggen.\par
\par
\par
9000000000000005147 wird nicht gefunden.\par
\par
Debuggen.\par
\par
Zwischendrin unn\'f6tigen Shrink untersuchen.\par
Da wird durch >= anstatt > capacity um 1 zu fr\'fch vergr\'f6\'dfert und der (korrekte) decrease check verkleinert wieder. Haha.\par
Pr\'fcfen und umstellen auf ">". Testen. Passt.\par
\par
Wieder weitersuchen am eigentlichen Problem:\par
Ach, da wird zum checken der oid-hashchain durch einen copy&paste Fehler refNext verwendet. Dann ist das kein Wunder ...\par
Fixen.\par
Gleich noch vorsichtshalber alle hashchain Iterierungen durchschauen.\par
Sonst kein solcher Fehler mehr.\par
\par
Wieder testen. Passt.\par
\par
Debug-\'c4nderungen aufr\'e4umen.\par
\par
\par
\par
Jetzt JET-49 (ByteOrder Konvertierung).\par
\par
Wieder einlesen.\par
Ich denk, als erstes macht es Sinn, endlich mal die zweite Referenz auf sun.misc.Unsafe in BinaryPersistence loszuwerden.\par
Kurzer Performance Test. Macht keinen Unterschied. Also ersetzen.\par
\par
\par
22:30:\par
\par
Alles aufger\'e4umt und doch wieder umbenannt zu "XMemory".\par
\par
Jetzt Recherche zum eigentlichen Thema.\par
Also alle Implementierungen, die die BinaryValueStorer und BinaryValueSetter verwenden, also die generische Reflective Implementierung usw., sind unproblematisch, wie im Issue geschrieben.\par
Dann w\'e4ren da so gekapselte Methoden wie in BinaryCollectionHandling. Die k\'f6nnte man alle verdoppeln f\'fcr eine Byteverdrehende Logik und dann mit einem relativ billigen, d.h. vernachl\'e4ssigbaren check ausw\'e4hlen. W\'e4r nicht sch\'f6n, aber okay.\par
Und dann sind da noch Klassen wie z.B. BinaryHandlerDate. Dort werden direkt einzelne Werte von und in den Speicher gelesen und geschrieben. F\'fcr einen einzelnen long Wert jedes mal ein Flag checken w\'e4r ziemlich bl\'f6d. Von der Code Komplexit\'e4t ganz zu schweigen.\par
Das gilt auch f\'fcr von Benutzer-Entwicklern selbstgeschriebene BinaryHandler. Siehe z.B. Bonusanwendung. Wenn da einer einen direkten Speicherzugriff macht, wird die Bytereihenfolge nicht gedreht.\par
\par
Eine L\'f6sung w\'e4re, Setter-Funktionsinstanzen in zentralen Feldern in Superklassen zu halten. Da m\'fcsste getestet werden, wie performant das w\'e4re.\par
Ist halt saubl\'f6d, wenn man wegen buckligen BE-Kr\'fcpeln, die in gef\'fchlten 99% der F\'e4lle (und immer seltener) \'fcberhaupt relevant sind, auf low-level-Ebene Performance verlieren w\'fcrde.\par
Hmpfl!\par
\par
\par
\par
2018-12-13\par
\par
Interessant w\'e4re ein Test, wie schnell modulare Setter Funktionen anstatt direkte XMemory-aufrufe dauern w\'fcrden.\par
Mal sowas bauen ...\par
\par
Hm. Also sofern mir da die JVM Optimierung nicht irgendwie einen Strich durch die Rechnung macht, sind das krasse Ergebnisse:\par
Beide Varianten, direkter unsafe Aufruf und modularisiert \'fcber eine Funktionsinstanz, sind gleich schnell.\par
Grob 1 ns pro gesetztem Wert.\par
\par
Ich muss evtl. noch bissl testen, ob da nicht doch zu viel rumoptimiert worden ist.\par
Am besten, indem ich das ganze mal in die echten handler einbau.\par
Wenn sich das Ergebnis best\'e4tigt, w\'e4r ich mir dem Issue quasi schon fertig.\par
\par
\par
23:00\par
\par
BinaryValueAccessor Typ bauen.\par
\par
\par
2018-12-14\par
\par
BinaryValueAccessor verschoben von TypeHandler nach Binary. Das ist super so. Die Binary Instanz wird eh rumgereicht.\par
Evtl. kann man dort sogar das ganze direkte handling von Memory Adressen wegkapseln.\par
\par
JET-49 updaten.\par
\par
BinaryValueAccessor umbenennen zu RawValueHandler.\par
Einbauen.\par
\par
Jetzt mal recherchieren zu Memory Adressen wegkapseln.\par
\par
Hm.\par
Also die ganzen eh schon gekapselten Hilfsmethoden wie z.B. BinaryPersistence.storeFixedSize() m\'fcsste halt nach Binary verschoben werden.\par
\par
Aus den kombinierten Quelle->Ziel "BinaryValueStorer" m\'fcsste "BinaryValueGetter" (oder besser "RawValueGetter") werden, die einen Wert aus einer Instanz holen und dann an einen setter des RawValueHandlers \'fcbergeben.\par
Das gleiche in gr\'fcn mit dem "BinaryValueSetter": Anstatt einen Wert von einer Quelladresse zu holen und auf eine Zieladresse oder in ein Zielobjekt zu schreiben, w\'fcrde der Wert von dem RawValueHandler geliefert und dann nur noch zum setzen \'fcbergeben werden.\par
Das h\'e4tte aber wieder R\'fcckwirkungen auf die Value Converter f\'fcr das LegacyTypeMapping: Anstatt ~64 Einzelimplementierungen f\'fcr die Konvertierung, m\'fcsste es 8 8-fach Implementierungen geben, die jeden beliebigen primitive Quelltyp annehmen k\'f6nnen und zu einem primitive Zieltyp konvertieren.\par
\par
\par
2019-01-15\par
\par
Weiter gehts, genau ein Monat sp\'e4ter. Ich hab w\'e4hrend der Umzugsschufterei immer wieder mal dar\'fcber nachgedacht, aber hatte nie Zeit, es aufzuschreiben oder gar daran zu arbeiten.\par
Meine \'dcberlegungen:\par
- Die Binary Klasse kann direkt die API enthalten, um Werte zu setzen.\par
- Ob die Variante f\'fcr ByteOrder-Konvertierung dann als Funktionsreferenz (evtl. mit null f\'fcr die Standardfall) oder als Ableitung gemacht wird, muss ausprobiert werden.\par
- In diesem Zusammenhang k\'f6nnte die Binary Klasse auch bzgl. anderen Kleinigkeiten \'fcberarbeitet werden, z.B. indem sie intern die Channelverwaltung macht (Binary Instanz zeigt auf andere Binary Instanzen, mit sich selbst als Channel 0).\par
- Alle generischen "storeList" usw. Methoden k\'f6nnen dann dort rein verschoben werden.\par
- Idealerweise m\'fcsste dann sogar entfallen k\'f6nnen, dass man vorab wissen muss, wie lang ein entity werden wird, weil das Binary Ding einfach bei Bedarf eine weitere Instanzen mit einem neuen reservierten Speicherbereich anlegt.\par
\par
\par
\par
Also m\'fcsste es ungef\'e4hr so aussehen:\par
\par
State:\par
- ein Binary ist die "head" Instanz als Arbeitsmedium f\'fcr einen gesamten Vorgang, z.B. einen Store.\par
- die head Binary Instanz hat ein Array an Binaries, dessen L\'e4nge der Channel Anzahl entspricht. Index 0 ist die head Instanz selber.\par
- Jede channel-spezifische Binary Instanz muss eine dynamisch wachsende Liste an DirectByteBuffer Instanzen haben und die aktuelle Addresse und bound in Feldern vorhalten\par
\par
/!\\ ein "voller" ByteBuffer muss ggf. auf ein paar Bytes vor seiner Capacity beschr\'e4nkt werden. Aber das geht mit limit().\par
\par
Idealerweise sollte die (eigentlich abstrakte) Binary Klasse selbst keinen state haben, damit abgeleitete Klassen nicht unn\'f6tig Speicher belegen. Bei Items (eine Instanz je entity) kann das durchaus relevant sein.\par
\par
Nochmal die aktuell vorhandenen Varianten (Ableitungen) durchdenken:\par
1.) Item: Beim Laden wird pro Entity ein Item angelegt. Das ist n\'f6tig, weil sowieso ein Item pro Entity gebraucht wird und das dann auch gleich auf die Speicheradresse der Entity Daten aus dem ChunksBuffer zeigen kann.\par
2.) ChunksBuffer: Beim Speichern und Laden wird pro Channel ein ChunksBuffer angelegt, der eine dynamisch wachsende Liste an ByteBuffers h\'e4lt und bei Bedarf als Array zur\'fcckgibt.\par
3.) ChunksWrapper: benutzt von FileSource (nur debug-Spielerei) und ComPersistenceChannelBinary. Wrappt einfach nur eingelesene ByteBuffer ohne weitere Logik\par
\par
Binary#rawValueHandler ist die Logik f\'fcr die ByteOrder-Konvertierung. Wird vielleicht direkt in das neue Binary \'fcbernommen, vielleicht \'fcber Ableitung gemacht.\par
Binary#entityContentAddress kommt zuk\'fcnftig direkt in die Item Klasse bzw. wird sowieso anders gel\'f6st, indem nur noch mit relativen Offsets mit Bound-Validierungs gearbeitet wird.\par
Binary#helperState wird nur beim Laden verwendet, kommt also auch direkt in die Item Klasse.\par
\par
\par
Neu vielleicht so:\par
\par
Binary:\par
[keine Felder]\par
\par
ChannelChunks extends Binary:\par
- ChannelChunks[] (dasselbe Array f\'fcr alle beteiligten ChannelChunks Instanzen)\par
- ByteBuffer[] usw., so wie bisher in ChunkBuffer.\par
\par
ChunksWrapper kann entweder so bleiben, oder konsolidiert werden mit ChannelChunks.\par
\par
\par
Nochmal recherchieren, wie das mit der Array ugliness (siehe XXX in ComBinary) ist.\par
PersistenceTarget erwartet ein M[]. Das ist nur n\'f6tig wegen der Channelaufteilung in der Storage (siehe EmbeddedStorageBinaryTarget).\par
Besser w\'e4re:\par
Binary bekommt eine Methode Chunk[] hashedChunks() , die das Array zur\'fcck gibt.\par
\par
Im neuen Load Item k\'f6nnte die OID weggelassen werden, wenn man stattdessen von der sowieso vorhandenen entityContentAddress 8 bytes zur\'fcckgeht und den Wert ausliest. Dort liegt die n\'e4mlich. Immer.\par
\par
Das BuildItem bauen k\'f6nnte mit der neuen Kapselung auch besser gehen:\par
Es muss nicht mit startOffset und boundOffset und tausend schleifen und expliziter Memory Adresse \'fcber 17 createItem() Aufrufe so eine Instanz gebaut werden, sondern einfach wie folgt:\par
Das neue Binary definiert eine Methode, der man einen BuildItemAcceptor \'fcbergibt. Die l\'e4uft intern \'fcber den Speicherbereich (aus wie vielen einzelnen Segmenten der auch immer bestehen mag), zerst\'fcckelt den in lauter neue BuildItem Instanzen und \'fcbergibt jede davon an den Acceptor. Der kann sich dann OID, TID usw. \'fcber entsprechende, gekapselte Getter auf den Speicherbereich raussuchen und lookups auf TypeHandler und ContextInstance machen, wie er lustig ist. Passt.\par
\par
Mal Binary2 und BuildItem2 implementieren und anhand davon weiter \'fcberlegen.\par
\par
\par
2019-01-18\par
\par
Die Spezialmethoden zum Speichern von Arrays usw. m\'fcssen dann auch in die Binary Klasse rein, damit die intern effizient arbeiten kann. Das passt aber auch strukturell gut dort rein.\par
Dabei kann ich auch gleich das "array bombs" Problem fixen.\par
\par
Relevante Methoden:\par
BinaryCollectionHandling#getSizedArrayLength\par
BinaryPersistence#binaryArrayElementCount\par
\par
Beide m\'fcssen so umgebaut werden, dass sie pr\'fcfen:\par
- Elementzahl mal elementgr\'f6\'dfe plus listheaderl\'e4nge muss angegebene gesamtlistenl\'e4nge ergeben. (z.B. BinaryPersistence#calculateReferenceListTotalBinaryLength)\par
- startoffset der liste plus angegebene gesamtlistenl\'e4nge darf die entityl\'e4nge nicht \'fcbersteigen.\par
\par
Daf\'fcr muss man die Methoden weiterhin umbauen von contentAddress auf entityAddress mit einem start offset dazu.\par
Um die Methoden generisch zu halten, muss au\'dferdem zus\'e4tzlich die Elementl\'e4nge \'fcbergeben werden. Aktuell gibt es: 1, 2, 4, 8 byte und 2*8 byte f\'fcr KeyValue-Elemente.\par
\par
Besser (stabiler) w\'e4re wohl, zun\'e4chst mal diese \'c4nderung in den bisherigen Methoden umzusetzen und dann die ge\'e4nderten Methoden in die neue Klasse \'fcbernehmen.\par
\par
Neue Kernmethode bauen, die das alles validiert.\par
JET-63 anlegen.\par
\par
\par
\par
2019-01-22\par
\par
JET-63 weitermachen.\par
Die validierende Methode m\'fcsste so passen. Jetzt alle spezifischeren list-Methoden auf die umstellen.\par
\par
Aufegefallen:\par
Im Rahmen von JET-60 kann dann auch folgendes TODO in BinaryPersistence erledigt werden:\par
// (03.07.2013)TODO: entityHeaderLength() should never be required\par
\par
\par
Also abgesehen davon, dass ich 17 mal unterbrochen worden bin wegen Bonus und Haus-Stuff, ist das validierung zentral einbauen im Detail ein bisschen knifflig.\par
Nicht schwierig, aber es gibt alle m\'f6glichen Varianten an Methoden, wie z.B. getSizedArrayElementCount, die jetzt nach Varianten f\'fcr element length (primitive oder reference) aufgeteilt werden m\'fcssen.\par
Dazu macht es Sinn, den Methodenwust an sich erst mal aufr\'e4umen.\par
\par
\par
Hm. Der BinaryReferenceTraverser$InlinedComplexType k\'f6nnte extrem verkompliziert werden, wenn der die Bin\'e4rl\'e4nge eines Element kennen muss. Wenn ein Element selbst n\'e4mlich wieder variable L\'e4nge hat, wird's haarig.\par
Aber eigentlich erzeugt der Traverser ja niemals Instanzen, sondern, wie der Name schon sagt, traversiert nur existierende. D.h. der k\'f6nnte eine nicht validierende Methode verwenden und die braucht dann auch die Elementl\'e4nge nicht, sondern funktioniert wie bisher. Dann bau ich das wieder so, aber mit einem Zusatz "NotValidating".\par
\par
Soweit alle Compilerfehler drau\'dfen. Mal committen und morgen die gemachten TODOs durchschauen.\par
\par
\par
\par
2019-01-23\par
\par
TODOs durchschauen.\par
Es gibt ja redundante Konstanten und Logik einmal f\'fcr eine binary element list und einmal f\'fcr ein binary array. Beides ist aber das gleiche.\par
Konsolidieren.\par
\par
So. Jetzt w\'e4ren soweit alle TODOs raus und die Redundanzen zusammenkonsolidiert.\par
\par
Jetzt bleibt aber noch eine Frage, bzw. daf\'fcr schreib ich jetzt ein TODO wieder rein:\par
Sollte der Getter getBinaryListByteLength nicht auch validieren?\par
Der Getter getBinaryListElementCount k\'f6nnte den dann mitverwenden.\par
\par
\par
\par
2019-01-24\par
\par
JET-63 TODO weitermachen. Daf\'fcr BinaryPersistenceExceptionInvalidList aufsplitten. Kommentare schreiben.\par
Fertig.\par
\par
Achja, lustig:\par
Das eigentliche initiale TODO, "Security: prevent array bombs", bei sized arrays handling, sollt ich vielleicht schon auch noch machen.\par
Aufrufstellen konsolidieren.\par
\par
\'c4hm. Hehe ... \'f6hm. Das geht bei SizedArrays nicht. Kommentar schreiben.\par
\par
L\'f6sung: PersistenceSizedArrayLengthController.\par
Implementieren. Einbauen. Defaults f\'fcr normalen Betrieb und f\'fcr Com. Daf\'fcr bissl aufr\'e4umen. JavaDoc schreiben, damit man die Modifikation nachbilden kann, falls man die Foundation selbst \'fcbergeben will.\par
Fertig.\par
\par
\par
2019-01-25\par
\par
Jetzt wieder weiter mit JET-49.\par
Binary Handling Logik in Binary Klasse umziehen.\par
Ich denk besser, als eine neue Binary2 Klasse machen, alles redundant dort rein packen und dann alles alte auf das neue umstellen, ist, gleich die bestehende Binary Klasse Schritt f\'fcr Schritt umziehen.\par
Als erstes mal das explizite Geld oid in Item \'fcberfl\'fcssig machen, indem das aus dem Entity Header direkt ausgelesen wird.\par
\par
Idee f\'fcr JET-58. Schnell aufschreiben. W\'e4hrend dem Schreiben weiter\'fcberlegen, verfeinern.\par
\par
\par
\par
2019-01-28\par
\par
Jetzt mal \'fcberlegen, wie ich das dumme Array wegbring.\par
\par
Kopiert von oben und aktualisiert:\par
1.) Item: Beim Laden wird pro Entity ein Item angelegt. Das ist n\'f6tig, weil sowieso ein Item pro Entity gebraucht wird und das dann auch gleich auf die Speicheradresse der Entity Daten aus dem ChunksBuffer zeigen kann.\par
2.) ChunksBuffer: Beim Speichern und Laden wird pro Channel ein ChunksBuffer angelegt, der eine dynamisch wachsende Liste an ByteBuffers h\'e4lt und bei Bedarf als Array zur\'fcckgibt.\par
3.) ChunksWrapper: benutzt von FileSource (nur debug-Spielerei) und ComPersistenceChannelBinary. Wrappt einfach nur eingelesene ByteBuffer ohne weitere Logik\par
\par
Neu vielleicht so:\par
\par
Binary:\par
Basisklasse\par
\par
LoadItem extends Binary\par
Instanz f\'fcr ein einzelnes Entity, wird durch Iteration aller Entities in einer ChannelChunks Instanz erzeugt.\par
\par
ChannelChunks extends Binary:\par
- ChannelChunks[] (dasselbe Array f\'fcr alle beteiligten ChannelChunks Instanzen)\par
- ByteBuffer[] usw., so wie bisher in ChunkBuffer.\par
\par
ChunksWrapper kann entweder so bleiben, oder konsolidiert werden mit ChannelChunks.\par
\par
\par
Nochmal recherchieren, wie das mit der Array ugliness (siehe XXX in ComBinary) ist.\par
PersistenceTarget erwartet ein M[]. Das ist nur n\'f6tig wegen der Channelaufteilung in der Storage (siehe EmbeddedStorageBinaryTarget).\par
Besser w\'e4re:\par
Binary bekommt eine Methode Chunk[] hashedChunks() , die das Array zur\'fcck gibt.\par
\par
Es braucht eigentlich gar keine extra "Head" Klasse. Es reicht, wenn der ChunksBuffer ein Index-Array f\'fcr alle Channel ChunksBuffers kennt. Egal, welche Channel-Instanz man erwischt (eigentlich immer die von Channel 0), man kann auf alle Channel-ChunksBuffers zugreifen. Das ist auch gut und wichtig so, weil das builden der Entities Singlethreaded passiert und darum ein Thread auf die ChunksBuffers aller Storage Channels zugreifen k\'f6nnen muss.\par
\par
Mal schauen, wo ich das am besten einbau ...\par
Storing sollte kein Problem sein, da ist die Instanzierung ja im Storer.\par
Beim Loaden muss der Load StorageTask umgebaut werden, aber nicht viel, sollte leicht gehen.\par
\par
\par
So. Storing und Loading umgebaut. Damit ist auch das h\'e4sslich-sinnlose Array in OGC verschwunden.\par
So gef\'e4llt mir das.\par
\par
\par
2019-01-29\par
\par
Weiter im Text:\par
Jetzt alle Binary-Access-Abstraction Methoden in BinaryPersistence und BinaryCollectionHandling direkt nach Binary umziehen.\par
Dann verschwinden die public API memory offsets (extremer Sicherheitsgewinn f\'fcr custom handler. Also "safety") und dann kann in diesen Methoden intern sehr leicht, nach au\'dfen unsichtbar und performant die optionale ByteOrder Konvertierung gemacht werden.\par
\par
Methoden sind soweit umgezogen.\par
Noch haufenweise Compilerfehler f\'fcr nun nicht mehr passende Methodenaufrufe. Muss ich noch anpassen.\par
Dann einige Methoden konsolidieren, damit m\'f6glichst keine absoluten Speicheradressen mehr verwendet werden.\par
Und dann m\'fcssten eigentlich noch \'fcberall Validierungen von \'fcbergebenen offsets rein.\par
\par
Wenn ich diese drei Punkte gemacht hab, kann ich \'fcberlegen,wie ich die Logik zum ByteOrder Konvertieren rein bau (RawValueHandler Referenz oder besser Ableitung) und das dann machen.\par
Dann ist es fertig.\par
\par
\par
2019-01-30\par
\par
Compilerfehler Anpassungen nachziehen. Zieht sich ... zwischendurch auff\'e4llige Methoden checken.\par
Da muss so viel overhault werden ... *seufz*\par
\par
Nun zwischendurch geschriebene Todos abarbeiten, z.T. Overhauls.\par
\par
\par
23:20\par
TODOs weitermachen.\par
\par
00:20 Ende\par
\par
\par
\par
2019-01-31\par
\par
Mir ist aufgefallen:\par
Die ByteOrder-Switching Variante muss eigentlich \'fcber eine Ableitung passieren, weil eine Referenz auf einen RawValueHandler ja die BinaryLoadItem Instanzen (eine pro Entity) vergr\'f6\'dfern w\'fcrde.\par
Au\'dferdem ist es wahrscheinlich imperformanter als die L\'f6sung \'fcber die Ableitung.\par
\par
Also Ableitung soll es sein.\par
Das Problem daran:\par
Die Binary Klasse ist aktuell 1500 Zeilen lang. Entweder, es m\'fcssten alle Werte-Getter und -Setter modularisiert werden, was Performance kostet, oder die komplette Klasse m\'fcsste einmal abgeleitet und die Methodenr\'fcmpfe umgeschrieben werden.\par
Beides ziemlich bl\'f6d.\par
\par
Dabei f\'e4llt mir auf: So oder so m\'fcssen noch mehr (ALLE) der Binary Handling Methoden von BinaryPersistence nach Binary umgezogen werden, weil sie ja sonst nicht bon der ByteOrder Konvertierung (egal ob RawValueHandler oder Ableitung) abgedeckt werden. Also die auch noch umziehen.\par
\par
Ah, bzw. nicht alle, weil die letzte "schicht" an settern/gettern, ohne irgendwelche arithmetik, kann ja Werte "blind" setzen, ohne zu wissen, welche Order die haben.\par
Aber bissl was muss noch umgezogen werden.\par
\par
Vielleicht muss es noch eine Ebene an Ableitung geben:\par
Ganz oben nur stateless getting/setting Logik.\par
Davon dann eine normale und eine Ableitung zum switchen.\par
\par
Und von denen beiden dann relativ kleine Ableitungen, die dann nur LoadItem bzw. ChunksBuffer sind.\par
Die m\'fcssten halt dann redundant implementiert werden, hilft nix.\par
\par
Au\'dferdem aufgefallen: Es gibt ja alle m\'f6glichen API-Verflechtungen, wo OIDs aus den Bin\'e4rdaten gelesen und an einen Lookup oder Iterator \'fcbergeben werden.\par
Die m\'fcssten dann auch alle eine Konvertierung machen. Das ist echt l\'e4stig. Und sehr fehleranf\'e4llig, weil die IDE da nicht mitdenken kann.\par
\par
Erst mal BinaryPersistence Klasse aufr\'e4umen, um einen \'dcberblick zu verschaffen, was binary data handling Logik ist und was Initialisierungszeug ist.\par
Dann das binary data handling Zeug Methode f\'fcr Methode durchdenken, was davon bleiben kann und was nach Binary muss, um dort ByteOrder-modularisiert zu werden.\par
Auch gleich wieder aufr\'e4umen. Z.B. unbenutzte Methoden usw.\par
Am besten gleich die ganzen Functions in eine eigene Klasse "BinaryValueFunctions" verschieben.\par
\par
So. Jetzt hab ich die ganze Binary Access Handling Logik in die Binary Klasse rein und der Rest ist aufgeteilt auf zwei h\'fcbsch kleine spezialisierte Klassen.\par
\par
Jetzt ist noch zu tun:\par
- Methoden konsolidieren, so dass m\'f6glichst keine absoluten Speicheradressen mehr vorkommen, keine redundante Logik mehr da ist, m\'f6glichst viel zu Instanzmethoden wird, die man dann mit einer Ableitung overriden kann.\par
- Da m\'fcssten dann offset Validierungen rein.\par
- Und dann ist zu \'fcberlegen, wie das eigentliche ByteOrder switching da rein kommt. Ggf. durch verschieben der entsprechenden Methoden in eine neue Vererbungsebene.\par
\par
\par
Ich mach das jetzt doch so, dass nur simple getter und setter bzw. storer und reader overridet werden.\par
Die JVM sollte den aufruf weg-jitten und der restliche Code muss nur einmal geschrieben werden.\par
Passt.\par
\par
\par
\par
2019-02-01\par
\par
Methoden in Klasse Binary weiter instanzifizieren, damit die Ableitung sie beeinflussen kann.\par
\par
Achja: F\'fcr die Array Methoden brauch ich auch noch Ableitbare Kapselungen.\par
\par
Zwischendrin Besprechung mit MK und FH.\par
\par
Redundanzen zwischen "buildArray" und create&update Paar untersuchen. Konsolidieren.\par
\par
\par
\par
2019-02-02\par
\par
Restliche Methoden in Klasse Binary instanzifizieren bzw. die Compilerfehler dazu rausmachen.\par
\par
Einlesen ... erste Methode: storeChars().\par
Ahja. Das Problem hier ist: im statischen Kontext wird mit absoluten Speicheradressen gearbeitet.\par
Es w\'e4re aber besser, relative Offsets zu verwenden.\par
Dazu muss ich aber erst die Implementierung umbauen, dass die den aktuellen Entity Offset zu ihrer Basisadresse mitf\'fchrt, auf den dann der entity-relative Offset draufgez\'e4hlt wird.\par
Das wiederum hei\'dft, dass die Methode storeEntityHeader() umgebaut werden muss.\par
Und das hat wiederum auswirkungen auf 28 andere Methoden.\par
Im Detail ist das alles trivial, aber man muss halt Schritt f\'fcr Schritt relativ viel umstricken.\par
\par
Daf\'fcr muss auch erst mal die zweite, statische Methode storeEntityHeader() wegrefactort werden, weil das ja \'fcber Instanzmethoden laufen muss.\par
\par
\par
\par
2019-02-04\par
\par
Weitermachen.\par
\par
Hm. Binary#getBinaryListElementCountAbsolute kann nicht einfach so in eine Instanzmethode umgewandelt werden, weil die im BinaryReferenceTraverser statisch mit absoluter Adresse verwendet wird.\par
Da muss wohl etwas mehr restrukturiert werden, damit es passt.\par
\par
Evtl. m\'fcsste es dann f\'fcr die Implementierungen der BinaryReferenceTraverser ein zweites Set geben, das die ByteOrder switcht.\par
Das zieht sich dann wieder durch bis zum TypeHandler erzeugen. Dann m\'fcsste dort ein modularer Erzeuger rein. Das w\'e4r generell nicht schlecht, anstatt hardgecodet Konstruktoren aufzurufen.\par
\par
Oh. Dabei gefunden: Was genau gibt BinaryReferenceTraverser#count zur\'fcck? Zahl der Referenzen? Konstante Zahl der Referenzen (d.h. variable length h\'e4tte 0)? Anzahl der abgedeckten Bytes?\par
Unterschiedliche Implementierungen scheinen hier unterschiedliche Konzepte zu verwenden. Evtl. Kommt daher sogar der GC-Bug, weil manche Referenzen nicht sicher erreicht werden. Wobei das dann 100% reproduzierbar sein m\'fcsste und keine Race Condition sein d\'fcrfte. Aber wie auch immer: Diese Methode ist seltsam und muss untersuchen, ggf. gefixt und ordentlich kommentiert werden.\par
\par
Also Problem kann es schon mal davon nicht geben, weil in den benutzen Algorithmen immer auch hasReferences() abgepr\'fcft wird.\par
\par
Okay, jetzt hab ich das alles wieder ordentlich durchgedacht und verstanden. Das stimmt schon so, nur die Benamung und der fehlende Kommentar war schlecht. Das hab ich mal verbessert.\par
\par
\par
\par
2019-02-05\par
\par
Das BinaryLoader#createBuildItem wird knifflig: da wird von einer Binary Implementierung an eine andere \'fcbergeben, um wieder eine Binary Instanz zu erzeugen. Und gerade das dazwischen br\'e4uchte jetzt auch eine Binary Implementierung.\par
Muss ich evtl. ganz anders strukturieren.\par
Und erst mal fliegt die Variante raus, per OID einen TypeHandler Lookup zu machen. Das wird nie benutzt, kann bei Bedarf auch anders gel\'f6st werden und kostet nur performance und Komplexit\'e4t.\par
\par
So, jetzt w\'e4ren schon mal alle Compiler Fehler weg.\par
Jetzt nur noch die 346345 TODOs anschauen.\par
\par
Und dann m\'fcssen ja da noch ByteOrder-Switchende Ableitungen her und irgendwie eine Fallunterscheidung, welche Implementierung verwendet werden soll.\par
Wenn ich da das \'fcbliche Creator interface Pattern mach, k\'f6nnte das evtl. etwas imperformant beim Laden werden, wenn millionen build items erzeugt werden m\'fcssen.\par
\par
Mal eine BinaryLoadItemByteReversing Klasse ableiten und Byte-Umdreh-Methoden einbauen.\par
\par
LoadItem Instanzierung zusammenkonsolidieren.\par
boolean reverseBytes einbauen und durchziehen bis runter (rauf?) in die Foundation.\par
Dort eine entsprechende isByteOrderMismatch() Methode bauen.\par
\par
Das gleiche f\'fcr ChunksBuffer usw...\par
\par
\par
23:00\par
\par
Jetzt noch das gleiche f\'fcr ChunksWrapper. \'dcberall all durchziehen.\par
Au\'dferdem RawValueHandler l\'f6schen und rausrefactoren.\par
Fertig.\par
\par
Keine Compilerfehler mehr, aber die TODOs sind noch.\par
\par
\par
\par
2019-02-06\par
TODOs abarbeiten.\par
\par
Dabei mal das zu generische (man kann schlecht danach suchen) _longProcedure ersetzen durch PersistenceObjectIdAcceptor.\par
\par
Achja: f\'fcr generische/reflective Handler m\'fcssen ja noch die Store Funktionen f\'fcr ByteReversing dupliziert und fallunterschieden werden.\par
Einbauen. \'dcberlegen, ob das reverseBytes lieber durchgereicht oder lieber als Feld abgebildet werden sollte.\par
Ergebnis: Eindeutig als Feld. Durchreichen w\'fcrde sich durch ein dutzend oder mehr Methoden ziehen, wohingegen die Variante \'fcber das Feld recht schnell in der Foundation landet und dort entschieden werden kann.\par
\par
Jetzt weitere TODOs machen.\par
\par
Paar Benamungen konsolidieren.\par
\par
Dann sind da auf einmal noch immer ein paar _longProcedure  drin. Umbauen.\par
\par
Ach und es gibt in der Storage nochmal einen Satz Funktionsinstanzen, die eine reversed Variante brauchen.\par
\par
Paar weitere TODOs schreiben.\par
\par
\par
\par
2019-02-07\par
\par
TODOs abarbeiten.\par
}
 