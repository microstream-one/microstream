{\rtf1\ansi\ansicpg1252\deff0\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\lang7\f0\fs28 2019-04-03 MS-62\par
\par
Planung:\par
\par
Dateiformat:\par
Wie im Issue beschrieben:\par
13 Zeichen UTC Timestamp f\'fcr den aktuellen Wert\par
13 Zeichen UTC Timestamp f\'fcr den vorherigen Wert\par
Rest der Datei ist der Identifier des Besitzers\par
\par
Aktueller zuerst, weil das der wichtige ist. Spielt praktisch keine Rolle, nur f\'fcr human-readability.\par
Dann muss da noch ein Separator rein.\par
Eigentlich kann das so simpel gemacht sein:\par
Chars iterieren, bis das erste nicht-Ziffer-zeichen kommt.\par
Wenn Anzahl != 13, dann exception.\par
Nicht-Ziffer-zeichen \'fcberspringen.\par
Dann das gleiche nochmal.\par
Nicht-Ziffer-zeichen \'fcberspringen.\par
Rest der Chars ist der Identifier. Der braucht keinerlei delimiting oder \'e4hnliches, weil er ja trailing ist.\par
\par
Default Separator ist ";", muss auch so in die public API rein, aber eigentlich ist er komplett egal.\par
\par
\par
Es muss nat\'fcrlich einen neuen Typen geben:\par
StorageLocker oder so. Klingt bl\'f6d, muss zwischendrin mal verbessert werden.\par
\par
Der muss haben:\par
- Identity (process id vom system?)\par
- Interval Vorgabe\par
\par
Und der StorageFileProvider muss ein LockFile providen.\par
Deault name: used.lock\par
\par
\par
Logik:\par
Ganz zu beginn der Initialisierung, bevor irgendwas gelesen oder gar geschrieben wird, muss der Locker gestartet werden.\par
Der holt sich das Lock File vom FileProvider.\par
Wenn es das File gibt:\par
Pr\'fcfen (...)\par
ansonsten:\par
Anlegen und weitermachen.\par
\par
\par
Hm. Schon mal das erste Problem:\line Was soll beim initialen Anlegen als vorheriger Wert rein? Eine Zeit aus der Vergangenheit, zu der das System noch gar nicht lief?\par
Das ist irgendwie puschig.\par
\'c4hnlich: Soll im laufenden Betrieb wirklich einfach der vorherige Wert als letzter Wert rein? Was ist mit geringen Verz\'f6gerungen usw. Sammeln die sich dann immer weiter an?\par
\par
Vielleicht w\'e4re es folgenderma\'dfen besser:\par
Der erste Wert ist die aktuelle Zeit.\par
Der zweite Wert ist die aktuelle Zeit plus das intervall, also ein Wert in der Zukunft.\par
Das hei\'dft: jeder neue write reserviert sich die Datenbank bis zu einem Verfallszeitpunkt in der Zukunft.\par
Dann kann man beim pr\'fcfen schauen, ob Verfallszeitpunkt + Intervall (wegen 2x Intervall) schon abgelaufen ist.\par
\par
\par
Pr\'fcfen:\par
Wenn Identit\'e4t gleich, dann einfach updaten und weitermachen.\par
Ansonsten:\par
Warten bis jetzt >= Verfallszeitpunkt + Intervall.\par
Wenn dann neues update der Werte: Exception: storage wird bereits verwendet.\par
Ansonsten:\par
Einfach updaten und weitermachen. (Storage \'fcbernehmen)\par
\par
Laufender Betrieb:\par
- Datei neu einlesen und pr\'fcfen, ob noch das drin steht, was zuletzte reingeschrieben wurde. Wenn nein, Exception und shutdown, ansonsten nichts machen.\par
- reinschreiben: [aktuelle zeit];[aktuelle Zeit + intervall];[identifier]\par
\par
Shutdown:\par
Datei l\'f6schen\par
\par
\par
Nat\'fcrlich muss das Ding in einem eigenen Thread laufen.\par
Eine Exception darin muss im StorageController den Betrieb abschalten, weil ja sonst das Lock nicht mehr garantiert ist und man sich das ganze Feature gleich sparen k\'f6nnte.\par
Und dabei mach ich gleich mal das Konzept, dass der Thread sich selber beendet, wenn die StorageManager Instanz nicht mehr verf\'fcgbar ist.\par
Hm oder eigentlich k\'f6nnte das zentral in das StorageController Ding rein. Oder sind beides dieselbe Instanz, dann gehts nat\'fcrlich nicht.\par
\par
Der Thread wird dann vom StorageThreadProvider geliefert. Keinen eigenen machen.\par
Siehe StorageManager#startBackupThread\par
\par
\par
ProcessId wird wieder mal nicht so einfach:\par
{\field{\*\fldinst{HYPERLINK "https://stackoverflow.com/questions/35842/how-can-a-java-program-get-its-own-process-id"}}{\fldrslt{\ul\cf1 https://stackoverflow.com/questions/35842/how-can-a-java-program-get-its-own-process-id}}}\f0\fs28\line Also ein extra Interface daf\'fcr.\par
\par
\par
2019-04-04\par
\par
Implementierung.\par
\par
Mal den StorageProcessIdentityProvider bauen.\par
\par
Hm. Aber das Problem ist: Wer garantiert, dass z.B. eine ProcessId \'fcber mehrere Maschinen hinweg eindeutig ist? Ist zwar extrem unwahrscheinlich, aber nicht ausgeschlossen.\par
Sollte ich dann jetzt anfangen, irgendwie die Mac-Adresse mit reinzuwurschteln?\par
Oder w\'e4re es nicht besser, einfach gleich eine UUID zu generieren? Da steckt genau das ja drin.\par
Es ist eigentlich v\'f6llig egal, was in der "Identity" steht, solange nur eine einzige Sache garantiert ist:\par
\'dcber beliebige Maschinen hinweg hat jeder Prozess einen anderen Wert.\line Da die UUID Mac-Adresse plus IRGENDWAS "halbwegs" eindeutiges enth\'e4lt, w\'e4re das v\'f6llig ausreichend.\par
\par
Mal recherchieren ...\par
Aha: Es gibt Versionen 1 bis 4.\par
1 ist mit Mac-Adresse.\par
Das JDK erzeugt nur version 4 (random).\par
Die API ist wieder mal eine Katastrophe: uniforme one-size-fits-all Klasse mit lauter Gettern, die je nach Version Exceptions werfen.\par
Maximaler Dreck.\par
Und wie krieg ich jetzt eine mit einer Mac-Adresse?\par
Recherchieren ...\par
Ohne 3rd Party Library ... gar nicht. JDK ist zu doof daf\'fcr.\par
\par
Seltsam. RF war ja mal so gehypt von denen.\par
Mal im Intranet nachfragen, wie die das machen.\par
Ergebnis: die nehmen \'fcberraschenderweise gar keine UUIDs.\par
Mail an RF mit paar Fragen.\par
\par
Also bis auf weiteres lass ich doch mal den StorageProcessIdentityProvider, der einen String zur\'fcckgibt.\par
Sollte der mal nicht "unique genug" sein, kann man ja die Implementierung austauschen.\par
\par
Code aus dem Link oben verwenden.\par
Testen.\par
Gibt bei mir z.B. aus:\par
11984@CORONA\par
\par
Ist jetzt nicht m\'f6rderm\'e4\'dfig unzweideutig, aber reicht mir erst mal.\par
\par
\par
2019-04-05\par
\par
StorageLockFileManager implementieren.\par
Daf\'fcr StorageLockFileSetup bauen.\par
\par
Und gleich das implizite beenden durch eine WeakReference auf den StorageManager.\par
Mal schauen, ob das in StorageChannelController geht.\par
Ja, geht.\par
\par
Foundation create~ Methode bissl konsolidieren.\par
\par
Hehe, jetzt muss der "ChannelController" aber einen allgemeineren Namen bekommen. Der kontrolliert ja nun nicht mehr nur die Channelsthreads, sondern den Betrieb der Datenbank allgemein.\par
Mal schauen, was ein guter Name w\'e4re.\par
"StorageOperationController" Mal darauf umbenennen.\par
\par
Implementierung weitermachen.\par
Oh Mann, wieder mal Verwirrung mit InterruptedException. Mal wieder ordentlich recherchieren.\par
Ergebnis: Sofern nicht explizit unterst\'fctzt ist das der gleiche gef\'e4hrliche Schwachsinn wie Thread#stop. XThreads.sleep entsprechend auf Exception umbauen, kommentieren und das verwenden.\par
\par
\par
2019-04-08\par
\par
Implementierung weitermachen.\par
Jetzt sollten langsam mal alle Widerigkeiten aus dem Weg sein ...\par
\par
\par
2019-04-09\par
\par
Implementierung weitermachen.\par
Soweit ich dazu komm vor Allianz Problemen/Fragen ...\par
Und Getting Started Review ...\par
\par
2019-04-10\par
\par
Implementierung weitermachen.\par
\par
2019-04-11\par
\par
Implementierung weitermachen.\par
Pl\'f6tzlich Maven Probleme.\par
\par
Testen...\par
\par
Die L\'f6sung mit der WeakReference geht irgendwie nicht. Checken per VisualVM.\par
Ach, der TaskBroker h\'e4lt noch eine strong reference auf den StorageManager. Umbauen auf direkte Referenzen auf die ben\'f6tigten Teile.\par
Testen.\par
Funktioniert.\par
\par
Hm, aber: Solang kein GC aufgerufen wird, l\'e4uft nat\'fcrlich alles brav weiter.\par
Hm.\par
Also einerseits ist das Konzept trotzdem gut als Sicherheitsnetz.\par
Andererseits ist es nicht verl\'e4sslich, weil es vom GC abh\'e4ngt, dass sich die Storage-Threads (und bei einem simplen Beispiel damit die ganze Anwendung) beenden.\par
Naja mei, immerhin.\par
\par
Achja: Verkabeln \'fcber die Foundation muss ich den LockManager ja noch ...\par
\par
\par
2019-04-12\par
\par
Nach Getting Started Overhaul erst mal daheim endlich repository usw. neu auschecken.\par
Die \'fcblichen kleineren Probleme:\par
Das cloud-Bitbucket bietet bei einem Branch immer nur das Clonen des ganzen Repositories und kein checkout eines branches.\par
Sourcetree sagt das Zielverzeichnis ist nicht leer, obwohl es leer ist.\par
Aber jetzt siehts gut aus.\par
\par
Jetzt den gestern gebauten Creator in die Foundation und den StorageManager einbauen und dann testen.\par
}
 