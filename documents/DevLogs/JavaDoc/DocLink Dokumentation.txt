JavaDoc-Erweiterung "DocLink"
Thomas Münz, 2019-05-27

Übersicht:
1.) Konzept
2.) Syntax
3.) Bekannte Probleme
4.) Test und Einsatz

---

1.) Konzept

Was ist das und wofür brauch ich es?

Ich habe beim Versuch, systematisch JavaDoc für MicroStream zu schreiben, festgestellt, dass es ein riesiges Problem gibt:
Überladene Methoden, gekapselte Konstruktoren, usw. haben wahnsinnig viel Redundanz in ihrer JavaDoc. Ein, sagen wir "int timeout", was konzeptionell eigentlich immer ein und dasselbe Ding ist, muss da ganz schnell an 10 verschiedenen Orten JavaDoc-beschrieben werden. Was soll man da machen? 10 mal manuell tippen wär dämlich. 1 mal manuell tippen und 9 mal "see {@link...}" schreiben, wäre für den Leser ziemlich störend beim Verstehversuch und damit irgendwie das Gegenteil von dem, was JavaDoc eigentlich leisten soll. 1 mal manuell tippen und 9 mal kopieren wäre denkbar, aber sobald an der JavaDoc mal was geändert (erweitert/verbessert) werden muss, bricht das Chaos auf. Egal, ob jedes mal 1 mal ändern und 9 mal ersetzen (hoffentlich findet man noch alle Stellen) oder 10 mal ändern, es artet immer in riesige Arbeit und Fehleranfälligkeit aus. Hat man alle Stellen erwischt? Braucht man dafür ein extra Referenz-Verzeichnis? Wartet man das auch sorgfältig mit? (natürlich nicht...)

Was hier fehlt ist doch: Man müsste JavaDoc Stellen untereinander verlinken können. So wie dieses @inheritDoc, nur eben auch für andere Fälle.

Also zum Beispiel:
Man dokumentiert den "@param timeout" für den "int timeout" einmal explizit und an den anderen 9 Stellen schreibt man dann sowas wie "@param timeout {@copy TypeName#methodName(int):timeout}".
Der Unterschied zu {@link ...} ist: Der Leser muss da nicht draufdrücken und in der JavaDoc herumspringen, sondern beim JavaDoc Generieren wird die einmal geschriebene Dokumentation für den @param timeout an die anderen 9 Stellen kopiert und man kann es direkt lesen.
Das ist die best-vorstellbare Lösung:
- Man muss es nur einmal schreiben.
- Man muss es nur einmal warten und kann keine Stelle übersehen.
- Der Leser kann an jeder der 10 Stellen trotzdem direkt die Beschreibung lesen. Ohne Herumspringen und die daraus resultierende Verwirrung/Frustration.

Meine Erfahrung ist: In einer API mit einigermaßen Convenience Schicht (viele Überladungen und viele Wrapper-Methoden) kann man überhaupt erst wirtschaftlich (und nervlich) sinnvoll JavaDoc schreiben, wenn man so einen Linking-Mechanismus hat. Ansonsten verschwendet man langfristig nur Zeit, Geld und Nerven.
Darum hab ich mal sowas gebaut.



2.) Syntax

Ist ganz simpel. Es ist nur ein neues JavaDoc Tag. Heißt nicht diffus "@copy", sondern "@docLink".
Die Syntax ist so nah wie möglich an dem, was man von JavaDoc eh schon kennt. Alles andere wäre ja dämlich.

Hier ein paar Beispiele:

Link auf die allgemeine Beschreibung des Typs "com.my.app.MyType":
{@docLink com.my.app.MyType}

Link auf die allgemeine Beschreibung des Felds "com.my.app.MyType#timeout":
{@docLink com.my.app.MyType#timeout}

Link auf die allgemeine Beschreibung der Methode "com.my.app.MyType#doStuff()":
{@docLink com.my.app.MyType#doStuff()}

Link auf die allgemeine Beschreibung der Methode "com.my.app.MyType#doStuff(int, String)":
{@docLink com.my.app.MyType#doStuff(int, String)}

Es geht auch per Namen anstatt per Typen:
{@docLink com.my.app.MyType#doStuff(timeout, name)}

Soweit so langweilig. Was ist nun, wenn man gezielt einen Parameter verlinken will, so wie im Beispiel oben?
Das hab ich oben eh schon gespoilert:
{@docLink com.my.app.MyType#doStuff(int, String):timeout}
{@docLink com.my.app.MyType#doStuff(timeout, name):timeout}

Also das heißt "von der Methode mit Namen doStuff und den beiden Parametern timeout und name, nimm die Parameter-Beschreibung von timeout."
Damit man eben wo anders, z.B. bei der Methode com.my.app.MyType#doStuff(int) mit Default-String als Name, nur noch schreiben braucht:
@param timeout {@docLink com.my.app.MyType#doStuff(int, String):timeout}
Also eben "Hol dir die Parameterbeschreibung für die überladene Variante von der Hauptvariante der Methode."
Einmal schreiben und dann nur noch verlinken. So muss das sein!

Eine kleine Optimierung kann man da noch machen:
Wenn vorne eh schon steht, dass es sich um den Parameter mit Namen "timeout" handelt, muss man dann hinten wirklich nochmal explizit ":timeout" schreiben? Das ist ja nervig ... Außerdem müsste man da wieder doppelt ändern/warten.
Richtig!
Darum geht das auch besser:
@param timeout {@docLink com.my.app.MyType#doStuff(int, String):}
Nur ein ":" heißt: "Verwend den aktuellen JavaDoc Parameternamen für den Link."
Ich denke, in 99% der Fälle wird das eh zutreffen, darum war es sinnvoll und wichtig, das einzubauen.
Der ":" ist übrigens wichtig, denn ohne den bezieht sich der Link ja auf die Methode selbst, also auf die allgemeine JavaDoc Beschreibung.

Was ist mit Tags?
Es gibt ja neben allgemeiner Beschreibung und Parametern auch noch alle möglichen Tags. Z.B. das @return. Wie verlinkt man das?

Völlig überraschenderweise so:
{@docLink com.my.app.MyType#doStuff(int, String)@return}

Also wieder bei dem Beispiel der überladenen Methode "com.my.app.MyType#doStuff(int)" bräuchte man in der JavaDoc dann nur noch schreiben:
@return {@docLink com.my.app.MyType#doStuff(int, String)@return}

Jetzt gibts aber manchmal mehrere Tags von der gleichen Sorte. Z.B. @see Tags. Das sind oft 2, 3, 4 oder noch mehr.
Darum muss man zu einem Tag auch noch einen Index angeben können:
{@docLink com.my.app.MyType@see:0}
Das erste @see Tag soll kopiert werden. Oder natürlich :1, :2, usw.

{@docLink com.my.app.MyType@return:0} müsste auch gehen (hab ich noch gar nicht getestet).
{@docLink com.my.app.MyType@return:1} ist natürlich immer Unfug.

Und es geht natürlich auch:
{@docLink com.my.app.MyType#doStuff(int, String)@param:0}
{@docLink com.my.app.MyType#doStuff(int, String)@param:1}
Wenn man die Parameter nach Reihenfolge anstatt nach Namen auswählen will.
Ich weiß nicht, ob das in bestimmten Fällen die günstigste Lösung ist. Im Zweifel ist es eher gefährlich. Jedenfalls ist es möglich.

Das wars eigentlich schon.
Zusammengefasst ist die Syntax für den Inhalt von {@docLink ... }
"typeName"[#"memberName"][("parameterList")][@"tagName"][:"extraIdentifier"]

Der "extraIdentifier" kann je nach Kontext entweder ein Parametername oder der Index für eins von mehreren Tags sein.
Die [] heißen, dass der Teil optional ist (siehe Beispiele).
Der Rest ist selbsterklärend.

Noch ein paar Specials:

Wenn in einem verlinkten Text wieder ein DocLink steht, muss der natürlich auch aufgelöst werden. Genauer gesagt: Es müssen rekursiv so lange alle docLink Tags aufgelöst werden, bis der finale Text feststeht.
Das hab ich berücksichtigt. Ein ekliger Sonderfall dabei, nämlich eine Schleife in der Rekursion, ist aber noch nicht gelöst. Siehe "Bekannte Probleme".

Wenn in einem @see eine lokale Referenz steht (z.B. @see #doStuff()), dann muss die beim Verlinken aus einer anderen Klasse natürlich in eine globale Referenz (@see com.my.app.MyType#doStuff()) umgewandelt werden, sonst ist die Referenz kaputt. Das wird automatisch mitgemacht. Für @link hab ich es dummerweise vergessen. Siehe "Bekannte Probleme".



3.) Bekannte Probleme

Mir sind während dem Testen einige Probleme und erwartbare, aber fehlende Features aufgefallen, die ich aber nicht gelöst habe, weil ich nach viel zu viel investierter Zeit (u.A. wegen fehlender Debugbarkeit dieser seltsamen Doclets) mal einen Schlusstrich ziehen wollte. Das ist halt momentan Version 1.0. Die Fixes wären dann Version 1.1, aber wann und von wem die gemacht werden wird, muss sich dann zeigen. TODOs im Sourcecode hab ich auf jeden Fall mal geschrieben.

Problem #1
Wenn JavaDoc A auf JavaDoc B verweist und B wieder auf A, gibt das momentan eine rekursive Endlosschleife, bis der Prozess auf einen Stack Overflow läuft. Die Vermeidung wäre gar nicht so schwer, simples Konzept steht schon im Code, aber Schlusstrich für Version 1.0 und so. Sollte aber nicht so dramatisch schlimm sein, weil das ohnehin ein Fehler in der JavaDoc wäre und dann halt nach der Exception entsprechend korrigiert werden muss. 

Problem #2
Ein @link Tag mit lokaler Referenz (z.B. {@link #doStuff()}) wird noch nicht in eine globale (bzw. full-qualified) Referenz umgewandelt, d.h. solche Links gehen kaputt.

Problem #3
Umgekehrt sollte das mit den lokalen Referenzen aber auch funktionieren: Innerhalb einer Klasse sollte man bei einem @docLink, genau wie bei JavaDoc allgemein, den Typenamen weglassen können. Ist technisch ja auch trivial zu machen. Das hatte ich anfangs irgendwie nicht bedacht. Aber halt Version 1.0 und so.

Problem #4
Und das Weglassen sollte, analog zu Parameternamen, auch für den Membernamen gelten, wenn das aktuell verarbeitete Element ein Feld oder Methode ist.
Also z.B. so:
{@docLink TargetType#} -> "Gleichnamiges Feld/Methode in dem anderen Typ".
Oder sogar so:
{@docLink TargetType#:} -> "Gleichnamiger Parameter der gleichnamigen Methode in dem anderen Typ".
Wäre technisch eine Kleinigkeit. Muss man halt mal schauen.



4.) Test und Einsatz

Dieser Punkt ist eigentlich auch noch Baustelle. Denn: Es geht schon. Aber eigentlich noch nicht. Es gibt da nämlich ein Problem...

Um JavaDoc Generierung zu customizen, gibt es ein "Doclet" Konzept im JDK.
Das ist gerade zwischen Java 8 und 9 auch noch komplett umgebaut worden. Bis Java 8 war es ... sehr wirr, in Java 9 ... nur noch ziemlich wirr. JDK halt.
Die Idee ist: Man gibt beim JavaDoc generieren lassen ein Stück custom Code mit (ein "doclet") und das wird dann ausgeführt.
In Eclipse geht das zum Beispiel so:
Rechtsklick auf Projekt -> Export -> Java -> JavaDoc -> Next -> "Use custom doclet":
Doclet name: [muss der full qualified class name zu einer Klasse mit der magic "start" Doclet-Methode sein.] (Pseudo-interface Bullshit Gewurschtel Lösung. Typisch JDK. Ab der Java 9 Lösung können sie sogar ECHTE Intefaces. Der Wahnsinn!)
Doclet class path: [Filesystem Pfad zu den Klassen] (Soweit ich weiß muss das ein jar sein, sonst geht es nicht. War anfangs sehr verwirrend ...)

Was momentan geht, ist, so eine pseudo-interface-mäßig implementierte Klasse (doclink.doclet.DocletJava8DocLinkPrinter), die input und output für so eine DocLink Ersetzung in die Konsole schreibt.
JavaDoc HTML Output gibts keinen, weil sich nämlich schnell herausgestellt hat, dass ein Doclet ohnehin unbrauchbare wäre.

Das Problem ist nämlich:
Es schaut ja eher selten jemand in so ein JavaDoc HTML Zeug rein, sondern man schaut ja eher öfter direkt in die JavaDoc View oder Tooltips in der IDE live beim Entwickeln. Zumindest muss die live Variante auch funktionieren.
Dummerweise bieten aber IDEs (zumindest eclipse) keine Möglichkeit, in ihre JavaDoc View ebenfalls ein Doclet einzuklinken.
(Im Umkehrschluss fragt man sich da schon irgendwie, ob denn überhaupt jemand dieses Doclet Zeug benutzt, denn die müssten ja alle dieses Problem haben)
Eine kurze Recherche von FH im eclipse Source Code hat ergeben: Das ist da drin die übliche Katastrophe. Da irgendwas zu schreiben oder zu pimpen, können wir knicken.
Und dann wären da ja auch noch alle anderen Java IDEs, die man unterstützen müsste. Sehr blöd.

Macht aber nichts, denn der ganze Doclet Aufwand ist eh gar nicht nötig. Es gibt eine viel elegantere Lösung:
Wir machen beim Deployment von Sourcecode sowieso schon so eine Art "Source Code post-processing", wo z.B. License Header usw. hinzugefügt werden.
Dort kann man die DocLink Logik mit reinklemmen, dann verschwinden alle nicht-JavaDoc-Standard @docLink Tags und man bekommt stattdessen das generierte Ergebnis mit den redundanten Texten.
Funktioniert ohne Doclets und automatisch für alle IDEs. Sehr schön!

Ironischerweise ist der einzige, für den es nicht funktioniert, der JavaDoc Schreiber live beim Schreiben.
Dafür bräuchten wir einen eigenen eclipse JavaDoc View, der die DocLink Logik enthält. Ist vielleicht mal was für die Zukunft (DocLink 2.0?), aber ich ahne, wie viel Aufwand das wäre und wie hoch dadurch die Priorität dafür sein würde. Naja mei.


Also der aktuelle Stand ist:
Mit der "doclink.doclet.DocletJava8DocLinkPrinter" Klasse kann man den DocLink Code zumindest mal grundsätzlich testen.
Das Projekt enthält praktischerweise selbst gleich zwei Testklassen:
- "doclink.test.TestTargetClass", das ist die Klasse, auf die docLinks zeigen, mit selbst ein paar docLinks, um Rekursion zu testen.
- "doclink.test.TestSubjectClass", das ist die Klasse, die mit docLinks auf die TagetClass zeigt. Deren JavaDoc muss am Ende gut aussehen (keine @docLink Tags mehr und keine seltsamen Lücken oder Verdoppelungen).

Vorgehensweise zum Testen:
1.) Das Projekt braucht eine Abhängigkeit zur "tools.jar" des JDK. Aber nur für den Doclet Test. Der DocLink Code selbst hat abgesehen vom JDK gar keine Abhängigkeiten, auch nicht zu MicroStream Code.
2.) Das DocLink Projekt als jar exportieren. (z.B. nach "D:\DocLink.jar")
3.) Für das DocLink Projekt JavaDoc erzeugten (siehe oben), mit den Angaben "doclink.doclet.DocletJava8DocLinkPrinter" und "D:\DocLink.jar".

Dann müsste in der Konsole der beschriebene Input und Output ausgegeben werden.
Inklusive ein paar Warnings für @see Tags, weil JavaDoc ja die docLink Tags nicht kennt. Das macht aber nichts, weil die docLink Tags ja ersetzt werden mit (hoffentlich!) validem Text. Also solche Warnings einfach ignorieren.
Es müsste dann auch im Working Directory ein "doc" Verzeichnis erzeugt worden sein. Das ist aber leer, weil das selbstgebastelte Doclet ja gar keinen File-Output erzeugt. Das passt also und ist kein Fehler.

Es war gerade beim Testen seltsamerweise so, dass Eclipse nach dem Neustart beim ersten Mal trotz Angabe das Doclet nicht verwendet hat. Aber beim zweiten Mal gings dann. Also falls nichts passiert, einfach nochmal versuchen. Keine Ahnung ...


Konkreter Einsatz:

Damit es wirklich funktioniert, müsste anhand der Vorlage der drei Doclet-Klassen (im Package "doclink.doclet") nun eine entsprechende Integration für das Deployment aus Eclipse heraus erstellt werden. Mit verwendeter API halt das Eclipse Syntax Tree Zeug anstatt dem "com.sun.javadoc.*" Zeug. Aktuell weiß ich nicht, wie ich das selber machen könnte oder ob es den Aufwand wert wäre, das dafür nötige dafür aufzusetzen, mich einzulesen, usw.
Sollte eigentlich recht schnell kopiet und angepasst werden können. Mal sehen ...

Der DocLink Sourcecode selbst sollte mehr oder weniger selbsterklärend sein:
Es gibt halt die schon erwähnten Unterpackages für "doclet" und für "test". Die Zentralen Klassen sind "DocLink" (statische Logik), "DocLinker" (Funktionales interface mit Defaultimplementierung) und dann ein paar Grusch-Typen für statische Util Methoden, String-bau-Interface, Mini-Datenstruktur, usw.
Abhängigkeiten gibt es, wie oben geschrieben, "eigentlich" gar keine.



Hier noch Links, die ich für die Verwendung des Doclet Zeugs gebraucht habe:
https://docs.oracle.com/javase/8/docs/jdk/api/javadoc/doclet/index.html
https://docs.oracle.com/javase/8/docs/jdk/api/javadoc/doclet/com/sun/javadoc/RootDoc.html

Dort wird auch die magic "start" Methode erklärt. Das "ListParams" Beispiel ist im DocLink Projekt als Referenz enthalten.
