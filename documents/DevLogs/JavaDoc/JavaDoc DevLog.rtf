{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 JavaDoc\par
\par
2019-05-07\par
\par
Erst mal die wichtigsten Typen zusammenschreiben:\par
\par
Storage\par
EmbeddedStorage\par
\par
StorageFoundation\par
EmbeddedStorageFoundation\par
EmbeddedStorageConnectionFoundation\par
\par
EmbeddedStorageManager\par
StorageController\par
StorageConnection\par
\par
PersistenceStoring\par
Storer\par
Unpersistable\par
Persistence\par
PersistenceFoundation\par
\par
\par
Mal mit "Storage" anfangen ...\par
JavaDoc schreiben zieht sich ...\par
\par
Dabei kleinere Struktur-Aufr\'e4um-Umformungen am Code machen.\par
\par
Hm, interessante Frage: Sollen zentrale Methoden parameter usw. redundant erkl\'e4ren? Oder soll im Gegenteil so eine zentrale Convenience-Methode nur auf die eigentliche Pseudo-Konstruktur Methode verlinken und ansonsten gar keine Doku enthalten?\par
\par
\par
2019-05-08\par
\par
Kommentar- und Namenskonsolidierung weitermachen: Alle "Implementation" umbenennen zu "Default".\par
Bevor irgendjemand JavaDoc Zeug liest, sollte das ordentlich aufger\'e4umt sein.\par
\par
Dabei verschiedene kleinere Aufr\'e4umarbeiten und paar Fixes an Benamungen (z.B. paar abstract Klassen hie\'dfen noch nicht "Abstract", usw.).\par
\par
Jetzt weiter im Text:\par
Ich nehm mal die Variante mit der redundanten JavaDoc. Mit folgender Begr\'fcndung:\par
- Jedes mal erst einen "Alias for X"-Link klicken m\'fcssen ist l\'e4stig.\par
- Kapselung: Eigentlich soll die Methode von ihrer Bedeutung her beschrieben werden. Wenn die intern nur eine andere Aufruft, ist das ein implementation detail. Vergleichbare Methoden in derselben Klassen machen intern z.B. durchaus mehr, n\'e4mlich einen Builder instanzieren und dar\'fcber erst die eigentliche Instanz erzeugen. Wenn die konsequenterweise nur auf den Builder verweisen w\'fcrden und man sich den erst wieder durchlesen muss, wird es ganz sch\'f6n m\'fchsam, eine verst\'e4ndliche Erkl\'e4rung zu bekommen, was eine trivial simple Methode macht.\par
- Die JavaDoc ist leicht copy&paste-bar von der eigentlichen New-Methode (oder eher umgekehrt). Wobei Wartung der JavaDoc dann nat\'fcrlich knifflig wird: man muss beide Varianten parallel warten, sonst laufen sie auseinander.\par
\par
\par
2019-05-09\par
\par
Recherche und Rum\'fcberlegen zum Dokumentieren von \'fcberladenen Methoden. Wenn man das alles explizit dokumentiert artet das in 10faches Copy&Paste aus.\par
\par
Entscheidung: "engere" Methoden nur ganz knapp dokumentieren und unter Erw\'e4hnung der Defaults an "weitere" verweisen.\par
Damit alle bisherigen Methoden nochmal durchschauen ...\par
\par
Ich denk das muss ein bisschen minimalistischer werden: Z.B ein @see auf einen Builder reicht. Da muss nicht noch im Text ein prosa Satz rein, der das gleiche nochmal aussagt, nur mit viel zus\'e4tzlichem Aufwand.\par
Also entsprechend k\'fcrzen...\par
\par
\par
2019-05-10\par
\par
Jetzt war schon wieder so viel anderes Zeug zwischendrin, dass ich den \'dcberblick verloren hab.\par
Nochmal von vorne durchgehen. Kleinigkeiten verbessern.\par
\par
Hm, aber das ist auch schon wieder bl\'f6d:\par
Z.B. in Storage#HousekeepingController steht eine fett detaillierte Erkl\'e4rung drin, w\'e4hrend alle Pseudo-Konstruktor-Methoden davor minimalistisch sind.\par
Wenn ich aber nur ein "See StorageHousekeepingController#New" rein mach, werden leere Parameterbeschreibungen generiert. Das ist auch bl\'f6d.\par
\par
Neue Strategie:\par
- Minimalistischer Beschreibungssatz\par
- "For Details, see ..."-Link\par
- Parameterbeschreibungen 1-zu-1 aus der oben genannten Methode kopieren.\par
- Minimalistisches Return\par
- Relevante @see Links.\par
\par
Das hei\'dft nat\'fcrlich: wieder von oben anfangen ...\par
\par
Oh Mann, ist das kompliziert:\par
Sollen Parameter von \'fcberladenen Methoden wirklich X-fach kopiert werden? Das wird ein Wartungsalbtraum.\line Aber ignorieren f\'fchrt zu generierten Parameterbeschreibungen, die halt leer sind. Das ist auch bl\'f6d.\par
\par
Vielleicht sollte ich als standard-Link-Satz auch eher "For further information, see" schreiben. das ist k\'fcrzer und klingt bekannter...\par
\par
Und: Was soll als Referenz f\'fcr die letztendlich tats\'e4chlich brauchbare Erkl\'e4rung verlinkt werden?\par
Die Pseudo-Konstruktor-Methode eines Typs oder der Typ selbst? F\'fcr und gegen beides sprechen gute Gute.\par
Oh Mann!\par
\par
Wobei es oft ja so ist, dass die Pseudo-Konstruktor-Methoden f\'fcr eine bestimmte Implementierung stehen, die man ansonsten gar nicht sieht und die der Typ nicht zwingend erfordert (Beispiel: Typ definiert 4 Methoden f\'fcr Werte, aber die Implementierung gibt f\'fcr jeden der 4 Werte denselben zur\'fcck). Also MUSS da eigentlich die detaillierte Beschreibung zur Methode und nicht zum Typ. Klassen will ich eigentlich nicht dokumentieren, weil die implementation details sind.\par
\par
Und noch was:\par
Soll die @see-Liste unten wirklich eine ma\'dfgeschneiderte Liste je nach Kontext sein, oder klatsch ich in alle Methoden eines Themas einfach die selbe volle Liste rein, auch wenn dann die Methode selbst da nochmal drin steht?\par
Gibt auch wieder f\'fcr beides gute Gr\'fcnde daf\'fcr und dagegen.\par
\par
Ich glaub, wenn ich das alles entschieden hab, muss ich zusammen mit den bisherigen Entscheidungen erst mal einen JavaDoc Konventionen Guide schreiben ... wenigstens intern f\'fcr mich.\par
\par
Also heute wieder mal sehr viele neue Designfragen gesammelt, aber wieder kaum weiter gekommen ...\par
\par
Jetzt bin ich frustriert :-[.\par
\par
\par
2019-05-13\par
\par
Daheim mal rum\'fcberlegt:\par
Es m\'fcsste eine M\'f6glichkeite geben, die Parameter-Beschreibung von einer anderen Methode zu \'fcbernehmen. So \'e4hnlich wie der @InheritDoc Mechanismus.\par
Mal googeln ..\par
\par
Uuund... das gibts nat\'fcrlich nicht.\par
\par
Dabei unteressanten Artikel gefunden:\par
{{\field{\*\fldinst{HYPERLINK https://christianmoser.me/sinn-unsinn-von-inheritdoc/ }}{\fldrslt{https://christianmoser.me/sinn-unsinn-von-inheritdoc/\ul0\cf0}}}}\f0\fs28\par
\par
Der hat Recht: Wenn das (noch immer) so ist, ist @InheritDoc kontraproduktiv.\par
Wieder mal klassische JDK-Idiotie.\par
\par
\par
MS-142 erstellen.\par
Und zwar ZWEIMAL, weil ich beim ersten Mal ganz am Ende durch eine unbekannte Kombination von zwei Tastatur-Missclicks das aktuelle Tab geschlossen und ein neues aufgemacht hab.\par
Keine R\'fcckg\'e4ngig Funktion.\par
Keine gespeicherte Datei (Fluch der Bequemlichkeit: Notepad++ temp-speichert von selbst so absturzsicher, dass man eigentlich nicht speichern muss, bevor man nicht explizit will)\par
\par
Besprechung mit MK und Issue Update.\par
\par
Recherche zu Doclet schreiben.\par
\par
Das ist schon wieder lustig:\par
Alles, was ich finde, ist entweder uralt (kein Interface sondern magic methodensignatur Konvention) oder verlinkt auf Beispielcode, der ausdr\'fccklich so alt ist, dass er nicht mehr geht.\par
\par
Aber das hier sieht sinnvoll aus:\par
{{\field{\*\fldinst{HYPERLINK https://docs.oracle.com/javase/9/docs/api/jdk/javadoc/doclet/package-summary.html }}{\fldrslt{https://docs.oracle.com/javase/9/docs/api/jdk/javadoc/doclet/package-summary.html\ul0\cf0}}}}\f0\fs28\par
\par
Die anscheinend einzige aktuelle und verst\'e4ndliche Doclet Dokumentation im ganzen Internet.\par
\par
Beispielklasse rausziehen. Erst mal die d\'e4mliche Formatierung fixen. Imports nachtragen. Ewig rumsuchen wegen der dummen "Kind" enum.\par
Ausprobieren. Egal, was ich mach, eclipse bringt eine Fehlermeldung.\par
Hilfe googeln. Die Hilfeseite von Eclipse dazu ist f\'fcrn Arsch.\par
\par
Aber das hier k\'f6nnte die L\'f6sung sein:\par
{{\field{\*\fldinst{HYPERLINK https://stackoverflow.com/questions/14522481/how-do-i-run-a-doclet-in-eclipse }}{\fldrslt{https://stackoverflow.com/questions/14522481/how-do-i-run-a-doclet-in-eclipse\ul0\cf0}}}}\f0\fs28\par
\par
Umbauen, gleich in ein eigenes Projekt.\par
Dabei k\'e4mpfen mit dem schwachsinnigen New Java Project Dialog, der die Wahlm\'f6glichkeit f\'fcr die JDK Version st\'e4ndig ausgraut.\par
Testen...\par
Wird gefunden.\par
Und sofort Exception durch einen Bug in dem Beispielcode: NoSuchElementException, weil der Autor offsensichtlich zu d\'e4mlich war, einen Iterator richtig zu benutzen.\par
Selber fixen.\par
\par
Die ganze bisherige Schei\'dfe, die schon wieder war, zusammenschreiben.\par
Im JDK sind wohl wirklich nur Deppen unterwegs. Egal, was man von denen anfast, es ist Dreck.\par
\par
Testen ...\par
\par
Oh, es funktioniert. Kaum fixt man die Bugs und motzt ein bisschen rum, schon gehts.\par
Zum speim.\par
\par
Gleich mal Guide zusammenschreiben und den gefixten Sourcecode noch bissl aufr\'e4umen und dazupacken.\par
\par
\par
\par
2019-05-14\par
\par
Issue updates (siehe dort)\par
\par
Java7 Doclet Dings ausprobieren.\par
Geht.\par
\par
PrintDocLink Logik bauen.\par
\par
\par
\par
2019-05-15\par
\par
DocLink Parser und Testcode bauen.\par
RootDoc JavaDoc googeln und durchlesen.\par
D\'e4mliche API. Da konnte jemand OOP nicht.\par
Lookup bauen, testen.\par
\par
Sehr gut.\par
Alles technisch n\'f6tige funktioniert grunds\'e4tzlich.\par
\par
Jetzt fehlt noch das parsen des Tag-Contents (das "type#method(params):paramname") und ein paar Kleinigkeiten.\par
\par
\par
2019-05-16\par
\par
Jetzt genaue Syntax f\'fcr einen DocLink \'fcberlegen und aufschreiben...\par
\par
"typeName"#"memberName"("parameterList")['@"tagName"'|':"parameterName"']\par
\par
Regeln:\par
- "typeName" ist das einzige, das zwingend ist.\par
- Ein Symbol macht alles vorherige (nach links) zwingend. Ausnahme (leider): das "@[tagName]" ist immer\par
- Wenn die "()" fehlen, wird der memberName als Feld interpretiert. Falls kein passendes Feld gefunden wird, dann als Methode mit diesem Namen ohne Parameter.\par
- ParameterList ist eine kommagetrennte Liste mit 0+ Elementen. Es sind entweder lauter Typnamen oder lauter Parameternamen, aber keine Mischung.\par
- TagName ist ein \'fcbliches BlockTag: return, author, usw. Die Frage w\'e4re noch, wie z.B. mehrere @see tags identifiziert werden sollen und ob man @param dann auch \'fcber diesen Weg identifizieren k\'f6nnen sollte.\par
- Parametername hat nur eine Bedeutung f\'fcr Methoden, ansonsten wird er ignoriert.\par
- wenn ein expliziter ParameterName angegeben ist, gilt der anstatt dem Paramternamen des aktuell verarbeiteten @param Tags.\par
- wenn aktuell kein @param Tag verarbeitet wird, bedeutet ein weggelassener Parametername, die Beschreibung der Methode zu kopieren.\par
- Um die Beschreibung der Methode explizit anzugeben: ":!"\par
\par
? Die Frage ist jetzt nur noch: wie kann man f\'fcr einen parameter definieren, die Beschreibung einer methode zu verwenden? Es darf kein g\'fcltiger java Typ- oder Identifiername sein, um keine Mehrdeutigkeiten zu erzeugen\par
M\'f6gliche L\'f6sungen:\par
- Nur das ":".\par
- Ein ":!"\par
- Oder ":*"\par
\par
Parser Implementieren ...\par
\par
Bissl testen und fixen.\par
Code besser strukturieren.\par
Fertig.\par
\par
Morgen noch Lookups in Doc-Struktur, dann ist der Prototyp fertig.\par
\par
Fertig.\par
\par
\par
\par
2019-05-17\par
\par
Doc-Struktur lookups bauen.\par
\par
Das muss alles besser getrennt werden zwischen Doclet Logik und m\'f6glichst bequem verwendbarer DocLink API.\par
Das l\'e4uft, zumindest in winzigem Umfang, wieder auf paar Interfaces mit Provider usw raus.\par
\par
Hm... Rekursion muss ich auch noch einbauen, sonst bringt das nicht viel.\par
Also wieder zwei Typen zusammenlegen zu einem. Hat paar Nachteile, aber eigentlich marginal.\par
\par
\par
Alles umgebaut. Erster Test mit Doclet:\par
Funktioniert auf Anhieb. Voll krass.\par
\par
Jetzt noch Tag Referenzierung einbauen.\par
Dabei aufgefallen: Ich muss die Syntax Reihenfolge umdrehen: Erst :parameterName, dann @see[5].\par
Umgedreht, getestet, passt.\par
Aber aufgefallen: Parameter JavaDoc kann ja gar keine tags haben. D.h. @ und : schlie\'dfen sich gegenseitig aus.\par
Das macht nichts, nur die Verarbeitung von methodenkommentaren muss entsprechend leicht anders gemacht werden.\par
Mal Reihenfolge der verarbeitungslogik \'fcberlegen ...\par
\par
Order must be:\par
1.) if explicit parameter name is present, search for that\par
2.) if explicit tag name is present, search for that\par
3.) if explicit description marker ("!") is present, use the description\par
4.) else, search for the passed parameter name\par
5.) use the description as the default\par
\par
\par
2019-05-20\par
\par
Am Wochenende ist mir auf-/eingefallen: Wenn ein param Tag selbst keine Tags mehr enthalten kann, dann kann man den extra identifier ja doch gleich auch als Index f\'fcr tags verwenden.\par
Also das "[]"-zeug wieder rausmachen. Wird einfach zu verstehen und zu programmieren. Sehr sch\'f6n.\par
\par
\par
\'dcberarbeitete Reihenfolge:\par
\par
1.) if explicit tag name is present, search for that and on hit, process accordingly\par
2.) if explicit description marker ("!") is present, use the description\par
3.) if explicit parameter name is present, search for that and on hit, process accordingly\par
4.) else, search for the passed parameter name\par
5.) use the description as the default\par
\par
\par
Hm. Neue, leicht verbesserte Regeln:\par
\par
"typeName"[#"memberName"][("parameterList")][@"tagName"][:"extraIdentifier"]\par
\par
- "typeName" ist das einzige, das zwingend ist.\par
- Ein Symbol macht alles vorherige (nach links) zwingend. Ausnahme (leider): das "@[tagName]" ist immer optional.\par
- Wenn die "()" fehlen, wird der memberName als Feld interpretiert.\par
- ParameterList ist eine kommagetrennte Liste mit 0+ Elementen. Es sind entweder lauter Typnamen oder lauter Parameternamen, aber keine Mischung.\par
- TagName ist ein \'fcbliches BlockTag: return, author, usw. F\'fcr mehrere Tags von der gleichen Art, siehe unten.\par
- "extraIdentifier" Leerstring (d.h. nur ":" angegeben): als parametername soll der Parametername des aktuell verarbeiteten Parametertags verwendet werden.\par
- "extraIdentifier" parsebar als Zahl: der Index f\'fcr die Auswahl aus mehreren gleichen Tags.\par
- "extraIdentifier" nicht parsebar als Zahl (alle restlichen F\'e4lle): wird bei einer referenzierten Methode als Parametername interpretiert und danach gesucht.\par
- Gibt es weder "tagName" noch "extraIdentifier", dann wird der Beschreibungstext verwendet.\par
\par
\par
So, soweit alles umgebaut.\par
Jetzt Tests bauen daf\'fcr ...\par
\par
Testen. Paar NPE durch Fl\'fcchtigkeitsfehler wie verdrehte Parameterargumente...\par
\par
Field funktioniert nicht bzw. das ist ja das TODO, ob commentText() \'fcberhaupt die richtige Mehode ist.\par
Mal syso-debuggen ...\par
\par
Tja, die FieldDocs sind leer, obwohl es zwei Felder mit JavaDoc gibt. Super. Lesen in der Doku...\par
Ah, da muss man erst ein d\'e4mliches Visibility-override flag mitgeben.\par
Testen. Geht.\par
\par
N\'e4chstes Problem:\par
Methodenreferenz mit leerer Parameterliste wird nicht gefunden.\par
Syso-debuggen ...\par
\par
Aha!\par
"[]" ist ein 1-elementiges array mit element "". Sehr fies.\par
Dann muss ich das Parameter parsen fixen ...\par
Gefixt. Testen.\par
Passt.\par
\par
Weiter morgen. Sollt aber so gut wie fertig sein.\par
\par
\par
}
 