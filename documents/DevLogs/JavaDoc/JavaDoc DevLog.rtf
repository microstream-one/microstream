{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 JavaDoc\par
\par
2019-05-07\par
\par
Erst mal die wichtigsten Typen zusammenschreiben:\par
\par
Storage\par
EmbeddedStorage\par
\par
StorageFoundation\par
EmbeddedStorageFoundation\par
EmbeddedStorageConnectionFoundation\par
\par
EmbeddedStorageManager\par
StorageController\par
StorageConnection\par
\par
PersistenceStoring\par
Storer\par
Unpersistable\par
Persistence\par
PersistenceFoundation\par
\par
\par
Mal mit "Storage" anfangen ...\par
JavaDoc schreiben zieht sich ...\par
\par
Dabei kleinere Struktur-Aufr\'e4um-Umformungen am Code machen.\par
\par
Hm, interessante Frage: Sollen zentrale Methoden parameter usw. redundant erkl\'e4ren? Oder soll im Gegenteil so eine zentrale Convenience-Methode nur auf die eigentliche Pseudo-Konstruktur Methode verlinken und ansonsten gar keine Doku enthalten?\par
\par
\par
2019-05-08\par
\par
Kommentar- und Namenskonsolidierung weitermachen: Alle "Implementation" umbenennen zu "Default".\par
Bevor irgendjemand JavaDoc Zeug liest, sollte das ordentlich aufger\'e4umt sein.\par
\par
Dabei verschiedene kleinere Aufr\'e4umarbeiten und paar Fixes an Benamungen (z.B. paar abstract Klassen hie\'dfen noch nicht "Abstract", usw.).\par
\par
Jetzt weiter im Text:\par
Ich nehm mal die Variante mit der redundanten JavaDoc. Mit folgender Begr\'fcndung:\par
- Jedes mal erst einen "Alias for X"-Link klicken m\'fcssen ist l\'e4stig.\par
- Kapselung: Eigentlich soll die Methode von ihrer Bedeutung her beschrieben werden. Wenn die intern nur eine andere Aufruft, ist das ein implementation detail. Vergleichbare Methoden in derselben Klassen machen intern z.B. durchaus mehr, n\'e4mlich einen Builder instanzieren und dar\'fcber erst die eigentliche Instanz erzeugen. Wenn die konsequenterweise nur auf den Builder verweisen w\'fcrden und man sich den erst wieder durchlesen muss, wird es ganz sch\'f6n m\'fchsam, eine verst\'e4ndliche Erkl\'e4rung zu bekommen, was eine trivial simple Methode macht.\par
- Die JavaDoc ist leicht copy&paste-bar von der eigentlichen New-Methode (oder eher umgekehrt). Wobei Wartung der JavaDoc dann nat\'fcrlich knifflig wird: man muss beide Varianten parallel warten, sonst laufen sie auseinander.\par
\par
\par
2019-05-09\par
\par
Recherche und Rum\'fcberlegen zum Dokumentieren von \'fcberladenen Methoden. Wenn man das alles explizit dokumentiert artet das in 10faches Copy&Paste aus.\par
\par
Entscheidung: "engere" Methoden nur ganz knapp dokumentieren und unter Erw\'e4hnung der Defaults an "weitere" verweisen.\par
Damit alle bisherigen Methoden nochmal durchschauen ...\par
\par
Ich denk das muss ein bisschen minimalistischer werden: Z.B ein @see auf einen Builder reicht. Da muss nicht noch im Text ein prosa Satz rein, der das gleiche nochmal aussagt, nur mit viel zus\'e4tzlichem Aufwand.\par
Also entsprechend k\'fcrzen...\par
\par
\par
2019-05-10\par
\par
Jetzt war schon wieder so viel anderes Zeug zwischendrin, dass ich den \'dcberblick verloren hab.\par
Nochmal von vorne durchgehen. Kleinigkeiten verbessern.\par
\par
Hm, aber das ist auch schon wieder bl\'f6d:\par
Z.B. in Storage#HousekeepingController steht eine fett detaillierte Erkl\'e4rung drin, w\'e4hrend alle Pseudo-Konstruktor-Methoden davor minimalistisch sind.\par
Wenn ich aber nur ein "See StorageHousekeepingController#New" rein mach, werden leere Parameterbeschreibungen generiert. Das ist auch bl\'f6d.\par
\par
Neue Strategie:\par
- Minimalistischer Beschreibungssatz\par
- "For Details, see ..."-Link\par
- Parameterbeschreibungen 1-zu-1 aus der oben genannten Methode kopieren.\par
- Minimalistisches Return\par
- Relevante @see Links.\par
\par
Das hei\'dft nat\'fcrlich: wieder von oben anfangen ...\par
\par
Oh Mann, ist das kompliziert:\par
Sollen Parameter von \'fcberladenen Methoden wirklich X-fach kopiert werden? Das wird ein Wartungsalbtraum.\line Aber ignorieren f\'fchrt zu generierten Parameterbeschreibungen, die halt leer sind. Das ist auch bl\'f6d.\par
\par
Vielleicht sollte ich als standard-Link-Satz auch eher "For further information, see" schreiben. das ist k\'fcrzer und klingt bekannter...\par
\par
Und: Was soll als Referenz f\'fcr die letztendlich tats\'e4chlich brauchbare Erkl\'e4rung verlinkt werden?\par
Die Pseudo-Konstruktor-Methode eines Typs oder der Typ selbst? F\'fcr und gegen beides sprechen gute Gute.\par
Oh Mann!\par
\par
Wobei es oft ja so ist, dass die Pseudo-Konstruktor-Methoden f\'fcr eine bestimmte Implementierung stehen, die man ansonsten gar nicht sieht und die der Typ nicht zwingend erfordert (Beispiel: Typ definiert 4 Methoden f\'fcr Werte, aber die Implementierung gibt f\'fcr jeden der 4 Werte denselben zur\'fcck). Also MUSS da eigentlich die detaillierte Beschreibung zur Methode und nicht zum Typ. Klassen will ich eigentlich nicht dokumentieren, weil die implementation details sind.\par
\par
Und noch was:\par
Soll die @see-Liste unten wirklich eine ma\'dfgeschneiderte Liste je nach Kontext sein, oder klatsch ich in alle Methoden eines Themas einfach die selbe volle Liste rein, auch wenn dann die Methode selbst da nochmal drin steht?\par
Gibt auch wieder f\'fcr beides gute Gr\'fcnde daf\'fcr und dagegen.\par
\par
Ich glaub, wenn ich das alles entschieden hab, muss ich zusammen mit den bisherigen Entscheidungen erst mal einen JavaDoc Konventionen Guide schreiben ... wenigstens intern f\'fcr mich.\par
\par
Also heute wieder mal sehr viele neue Designfragen gesammelt, aber wieder kaum weiter gekommen ...\par
\par
Jetzt bin ich frustriert :-[.\par
\par
\par
2019-05-13\par
\par
Daheim mal rum\'fcberlegt:\par
Es m\'fcsste eine M\'f6glichkeite geben, die Parameter-Beschreibung von einer anderen Methode zu \'fcbernehmen. So \'e4hnlich wie der @InheritDoc Mechanismus.\par
Mal googeln ..\par
\par
Uuund... das gibts nat\'fcrlich nicht.\par
\par
Dabei unteressanten Artikel gefunden:\par
{{\field{\*\fldinst{HYPERLINK https://christianmoser.me/sinn-unsinn-von-inheritdoc/ }}{\fldrslt{https://christianmoser.me/sinn-unsinn-von-inheritdoc/\ul0\cf0}}}}\f0\fs28\par
\par
Der hat Recht: Wenn das (noch immer) so ist, ist @InheritDoc kontraproduktiv.\par
Wieder mal klassische JDK-Idiotie.\par
\par
\par
MS-142 erstellen.\par
Und zwar ZWEIMAL, weil ich beim ersten Mal ganz am Ende durch eine unbekannte Kombination von zwei Tastatur-Missclicks das aktuelle Tab geschlossen und ein neues aufgemacht hab.\par
Keine R\'fcckg\'e4ngig Funktion.\par
Keine gespeicherte Datei (Fluch der Bequemlichkeit: Notepad++ temp-speichert von selbst so absturzsicher, dass man eigentlich nicht speichern muss, bevor man nicht explizit will)\par
\par
Besprechung mit MK und Issue Update.\par
\par
Recherche zu Doclet schreiben.\par
\par
Das ist schon wieder lustig:\par
Alles, was ich finde, ist entweder uralt (kein Interface sondern magic methodensignatur Konvention) oder verlinkt auf Beispielcode, der ausdr\'fccklich so alt ist, dass er nicht mehr geht.\par
\par
Aber das hier sieht sinnvoll aus:\par
{{\field{\*\fldinst{HYPERLINK https://docs.oracle.com/javase/9/docs/api/jdk/javadoc/doclet/package-summary.html }}{\fldrslt{https://docs.oracle.com/javase/9/docs/api/jdk/javadoc/doclet/package-summary.html\ul0\cf0}}}}\f0\fs28\par
\par
Die anscheinend einzige aktuelle und verst\'e4ndliche Doclet Dokumentation im ganzen Internet.\par
\par
Beispielklasse rausziehen. Erst mal die d\'e4mliche Formatierung fixen. Imports nachtragen. Ewig rumsuchen wegen der dummen "Kind" enum.\par
Ausprobieren. Egal, was ich mach, eclipse bringt eine Fehlermeldung.\par
Hilfe googeln. Die Hilfeseite von Eclipse dazu ist f\'fcrn Arsch.\par
\par
Aber das hier k\'f6nnte die L\'f6sung sein:\par
{{\field{\*\fldinst{HYPERLINK https://stackoverflow.com/questions/14522481/how-do-i-run-a-doclet-in-eclipse }}{\fldrslt{https://stackoverflow.com/questions/14522481/how-do-i-run-a-doclet-in-eclipse\ul0\cf0}}}}\f0\fs28\par
\par
Umbauen, gleich in ein eigenes Projekt.\par
Dabei k\'e4mpfen mit dem schwachsinnigen New Java Project Dialog, der die Wahlm\'f6glichkeit f\'fcr die JDK Version st\'e4ndig ausgraut.\par
Testen...\par
Wird gefunden.\par
Und sofort Exception durch einen Bug in dem Beispielcode: NoSuchElementException, weil der Autor offsensichtlich zu d\'e4mlich war, einen Iterator richtig zu benutzen.\par
Selber fixen.\par
\par
Die ganze bisherige Schei\'dfe, die schon wieder war, zusammenschreiben.\par
Im JDK sind wohl wirklich nur Deppen unterwegs. Egal, was man von denen anfast, es ist Dreck.\par
\par
Testen ...\par
\par
Oh, es funktioniert. Kaum fixt man die Bugs und motzt ein bisschen rum, schon gehts.\par
Zum speim.\par
\par
Gleich mal Guide zusammenschreiben und den gefixten Sourcecode noch bissl aufr\'e4umen und dazupacken.\par
\par
\par
\par
2019-05-14\par
\par
Issue updates (siehe dort)\par
\par
Java7 Doclet Dings ausprobieren.\par
Geht.\par
\par
PrintDocLink Logik bauen.\par
}
 