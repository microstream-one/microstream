{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 JavaDoc\par
\par
2019-05-07\par
\par
Erst mal die wichtigsten Typen zusammenschreiben:\par
\par
v Storage\par
v EmbeddedStorage\par
\par
v StorageFoundation\par
EmbeddedStorageFoundation\par
EmbeddedStorageConnectionFoundation\par
\par
EmbeddedStorageManager\par
StorageController\par
StorageConnection\par
\par
PersistenceStoring\par
Storer\par
Unpersistable\par
Persistence\par
PersistenceFoundation\par
\par
\par
Mal mit "Storage" anfangen ...\par
JavaDoc schreiben zieht sich ...\par
\par
Dabei kleinere Struktur-Aufr\'e4um-Umformungen am Code machen.\par
\par
Hm, interessante Frage: Sollen zentrale Methoden parameter usw. redundant erkl\'e4ren? Oder soll im Gegenteil so eine zentrale Convenience-Methode nur auf die eigentliche Pseudo-Konstruktur Methode verlinken und ansonsten gar keine Doku enthalten?\par
\par
\par
2019-05-24\par
\par
Implementierung entsprechend umbauen\par
\par
2019-05-08\par
\par
Kommentar- und Namenskonsolidierung weitermachen: Alle "Implementation" umbenennen zu "Default".\par
Bevor irgendjemand JavaDoc Zeug liest, sollte das ordentlich aufger\'e4umt sein.\par
\par
Dabei verschiedene kleinere Aufr\'e4umarbeiten und paar Fixes an Benamungen (z.B. paar abstract Klassen hie\'dfen noch nicht "Abstract", usw.).\par
\par
Jetzt weiter im Text:\par
Ich nehm mal die Variante mit der redundanten JavaDoc. Mit folgender Begr\'fcndung:\par
- Jedes mal erst einen "Alias for X"-Link klicken m\'fcssen ist l\'e4stig.\par
- Kapselung: Eigentlich soll die Methode von ihrer Bedeutung her beschrieben werden. Wenn die intern nur eine andere Aufruft, ist das ein implementation detail. Vergleichbare Methoden in derselben Klassen machen intern z.B. durchaus mehr, n\'e4mlich einen Builder instanzieren und dar\'fcber erst die eigentliche Instanz erzeugen. Wenn die konsequenterweise nur auf den Builder verweisen w\'fcrden und man sich den erst wieder durchlesen muss, wird es ganz sch\'f6n m\'fchsam, eine verst\'e4ndliche Erkl\'e4rung zu bekommen, was eine trivial simple Methode macht.\par
- Die JavaDoc ist leicht copy&paste-bar von der eigentlichen New-Methode (oder eher umgekehrt). Wobei Wartung der JavaDoc dann nat\'fcrlich knifflig wird: man muss beide Varianten parallel warten, sonst laufen sie auseinander.\par
\par
\par
2019-05-09\par
\par
Recherche und Rum\'fcberlegen zum Dokumentieren von \'fcberladenen Methoden. Wenn man das alles explizit dokumentiert artet das in 10faches Copy&Paste aus.\par
\par
Entscheidung: "engere" Methoden nur ganz knapp dokumentieren und unter Erw\'e4hnung der Defaults an "weitere" verweisen.\par
Damit alle bisherigen Methoden nochmal durchschauen ...\par
\par
Ich denk das muss ein bisschen minimalistischer werden: Z.B ein @see auf einen Builder reicht. Da muss nicht noch im Text ein prosa Satz rein, der das gleiche nochmal aussagt, nur mit viel zus\'e4tzlichem Aufwand.\par
Also entsprechend k\'fcrzen...\par
\par
\par
2019-05-10\par
\par
Jetzt war schon wieder so viel anderes Zeug zwischendrin, dass ich den \'dcberblick verloren hab.\par
Nochmal von vorne durchgehen. Kleinigkeiten verbessern.\par
\par
Hm, aber das ist auch schon wieder bl\'f6d:\par
Z.B. in Storage#HousekeepingController steht eine fett detaillierte Erkl\'e4rung drin, w\'e4hrend alle Pseudo-Konstruktor-Methoden davor minimalistisch sind.\par
Wenn ich aber nur ein "See StorageHousekeepingController#New" rein mach, werden leere Parameterbeschreibungen generiert. Das ist auch bl\'f6d.\par
\par
Neue Strategie:\par
- Minimalistischer Beschreibungssatz\par
- "For Details, see ..."-Link\par
- Parameterbeschreibungen 1-zu-1 aus der oben genannten Methode kopieren.\par
- Minimalistisches Return\par
- Relevante @see Links.\par
\par
Das hei\'dft nat\'fcrlich: wieder von oben anfangen ...\par
\par
Oh Mann, ist das kompliziert:\par
Sollen Parameter von \'fcberladenen Methoden wirklich X-fach kopiert werden? Das wird ein Wartungsalbtraum.\line Aber ignorieren f\'fchrt zu generierten Parameterbeschreibungen, die halt leer sind. Das ist auch bl\'f6d.\par
\par
Vielleicht sollte ich als standard-Link-Satz auch eher "For further information, see" schreiben. das ist k\'fcrzer und klingt bekannter...\par
\par
Und: Was soll als Referenz f\'fcr die letztendlich tats\'e4chlich brauchbare Erkl\'e4rung verlinkt werden?\par
Die Pseudo-Konstruktor-Methode eines Typs oder der Typ selbst? F\'fcr und gegen beides sprechen gute Gute.\par
Oh Mann!\par
\par
Wobei es oft ja so ist, dass die Pseudo-Konstruktor-Methoden f\'fcr eine bestimmte Implementierung stehen, die man ansonsten gar nicht sieht und die der Typ nicht zwingend erfordert (Beispiel: Typ definiert 4 Methoden f\'fcr Werte, aber die Implementierung gibt f\'fcr jeden der 4 Werte denselben zur\'fcck). Also MUSS da eigentlich die detaillierte Beschreibung zur Methode und nicht zum Typ. Klassen will ich eigentlich nicht dokumentieren, weil die implementation details sind.\par
\par
Und noch was:\par
Soll die @see-Liste unten wirklich eine ma\'dfgeschneiderte Liste je nach Kontext sein, oder klatsch ich in alle Methoden eines Themas einfach die selbe volle Liste rein, auch wenn dann die Methode selbst da nochmal drin steht?\par
Gibt auch wieder f\'fcr beides gute Gr\'fcnde daf\'fcr und dagegen.\par
\par
Ich glaub, wenn ich das alles entschieden hab, muss ich zusammen mit den bisherigen Entscheidungen erst mal einen JavaDoc Konventionen Guide schreiben ... wenigstens intern f\'fcr mich.\par
\par
Also heute wieder mal sehr viele neue Designfragen gesammelt, aber wieder kaum weiter gekommen ...\par
\par
Jetzt bin ich frustriert :-[.\par
\par
\par
2019-05-13\par
\par
Daheim mal rum\'fcberlegt:\par
Es m\'fcsste eine M\'f6glichkeite geben, die Parameter-Beschreibung von einer anderen Methode zu \'fcbernehmen. So \'e4hnlich wie der @InheritDoc Mechanismus.\par
Mal googeln ..\par
\par
Uuund... das gibts nat\'fcrlich nicht.\par
\par
Dabei unteressanten Artikel gefunden:\par
{{\field{\*\fldinst{HYPERLINK https://christianmoser.me/sinn-unsinn-von-inheritdoc/ }}{\fldrslt{https://christianmoser.me/sinn-unsinn-von-inheritdoc/\ul0\cf0}}}}\f0\fs28\par
\par
Der hat Recht: Wenn das (noch immer) so ist, ist @InheritDoc kontraproduktiv.\par
Wieder mal klassische JDK-Idiotie.\par
\par
\par
MS-142 erstellen.\par
Und zwar ZWEIMAL, weil ich beim ersten Mal ganz am Ende durch eine unbekannte Kombination von zwei Tastatur-Missclicks das aktuelle Tab geschlossen und ein neues aufgemacht hab.\par
Keine R\'fcckg\'e4ngig Funktion.\par
Keine gespeicherte Datei (Fluch der Bequemlichkeit: Notepad++ temp-speichert von selbst so absturzsicher, dass man eigentlich nicht speichern muss, bevor man nicht explizit will)\par
\par
Besprechung mit MK und Issue Update.\par
\par
Recherche zu Doclet schreiben.\par
\par
Das ist schon wieder lustig:\par
Alles, was ich finde, ist entweder uralt (kein Interface sondern magic methodensignatur Konvention) oder verlinkt auf Beispielcode, der ausdr\'fccklich so alt ist, dass er nicht mehr geht.\par
\par
Aber das hier sieht sinnvoll aus:\par
{{\field{\*\fldinst{HYPERLINK https://docs.oracle.com/javase/9/docs/api/jdk/javadoc/doclet/package-summary.html }}{\fldrslt{https://docs.oracle.com/javase/9/docs/api/jdk/javadoc/doclet/package-summary.html\ul0\cf0}}}}\f0\fs28\par
\par
Die anscheinend einzige aktuelle und verst\'e4ndliche Doclet Dokumentation im ganzen Internet.\par
\par
Beispielklasse rausziehen. Erst mal die d\'e4mliche Formatierung fixen. Imports nachtragen. Ewig rumsuchen wegen der dummen "Kind" enum.\par
Ausprobieren. Egal, was ich mach, eclipse bringt eine Fehlermeldung.\par
Hilfe googeln. Die Hilfeseite von Eclipse dazu ist f\'fcrn Arsch.\par
\par
Aber das hier k\'f6nnte die L\'f6sung sein:\par
{{\field{\*\fldinst{HYPERLINK https://stackoverflow.com/questions/14522481/how-do-i-run-a-doclet-in-eclipse }}{\fldrslt{https://stackoverflow.com/questions/14522481/how-do-i-run-a-doclet-in-eclipse\ul0\cf0}}}}\f0\fs28\par
\par
Umbauen, gleich in ein eigenes Projekt.\par
Dabei k\'e4mpfen mit dem schwachsinnigen New Java Project Dialog, der die Wahlm\'f6glichkeit f\'fcr die JDK Version st\'e4ndig ausgraut.\par
Testen...\par
Wird gefunden.\par
Und sofort Exception durch einen Bug in dem Beispielcode: NoSuchElementException, weil der Autor offsensichtlich zu d\'e4mlich war, einen Iterator richtig zu benutzen.\par
Selber fixen.\par
\par
Die ganze bisherige Schei\'dfe, die schon wieder war, zusammenschreiben.\par
Im JDK sind wohl wirklich nur Deppen unterwegs. Egal, was man von denen anfast, es ist Dreck.\par
\par
Testen ...\par
\par
Oh, es funktioniert. Kaum fixt man die Bugs und motzt ein bisschen rum, schon gehts.\par
Zum speim.\par
\par
Gleich mal Guide zusammenschreiben und den gefixten Sourcecode noch bissl aufr\'e4umen und dazupacken.\par
\par
\par
\par
2019-05-14\par
\par
Issue updates (siehe dort)\par
\par
Java7 Doclet Dings ausprobieren.\par
Geht.\par
\par
PrintDocLink Logik bauen.\par
\par
\par
\par
2019-05-15\par
\par
DocLink Parser und Testcode bauen.\par
RootDoc JavaDoc googeln und durchlesen.\par
D\'e4mliche API. Da konnte jemand OOP nicht.\par
Lookup bauen, testen.\par
\par
Sehr gut.\par
Alles technisch n\'f6tige funktioniert grunds\'e4tzlich.\par
\par
Jetzt fehlt noch das parsen des Tag-Contents (das "type#method(params):paramname") und ein paar Kleinigkeiten.\par
\par
\par
2019-05-16\par
\par
Jetzt genaue Syntax f\'fcr einen DocLink \'fcberlegen und aufschreiben...\par
\par
"typeName"#"memberName"("parameterList")['@"tagName"'|':"parameterName"']\par
\par
Regeln:\par
- "typeName" ist das einzige, das zwingend ist.\par
- Ein Symbol macht alles vorherige (nach links) zwingend. Ausnahme (leider): das "@[tagName]" ist immer\par
- Wenn die "()" fehlen, wird der memberName als Feld interpretiert. Falls kein passendes Feld gefunden wird, dann als Methode mit diesem Namen ohne Parameter.\par
- ParameterList ist eine kommagetrennte Liste mit 0+ Elementen. Es sind entweder lauter Typnamen oder lauter Parameternamen, aber keine Mischung.\par
- TagName ist ein \'fcbliches BlockTag: return, author, usw. Die Frage w\'e4re noch, wie z.B. mehrere @see tags identifiziert werden sollen und ob man @param dann auch \'fcber diesen Weg identifizieren k\'f6nnen sollte.\par
- Parametername hat nur eine Bedeutung f\'fcr Methoden, ansonsten wird er ignoriert.\par
- wenn ein expliziter ParameterName angegeben ist, gilt der anstatt dem Paramternamen des aktuell verarbeiteten @param Tags.\par
- wenn aktuell kein @param Tag verarbeitet wird, bedeutet ein weggelassener Parametername, die Beschreibung der Methode zu kopieren.\par
- Um die Beschreibung der Methode explizit anzugeben: ":!"\par
\par
? Die Frage ist jetzt nur noch: wie kann man f\'fcr einen parameter definieren, die Beschreibung einer methode zu verwenden? Es darf kein g\'fcltiger java Typ- oder Identifiername sein, um keine Mehrdeutigkeiten zu erzeugen\par
M\'f6gliche L\'f6sungen:\par
- Nur das ":".\par
- Ein ":!"\par
- Oder ":*"\par
\par
Parser Implementieren ...\par
\par
Bissl testen und fixen.\par
Code besser strukturieren.\par
Fertig.\par
\par
Morgen noch Lookups in Doc-Struktur, dann ist der Prototyp fertig.\par
\par
Fertig.\par
\par
\par
\par
2019-05-17\par
\par
Doc-Struktur lookups bauen.\par
\par
Das muss alles besser getrennt werden zwischen Doclet Logik und m\'f6glichst bequem verwendbarer DocLink API.\par
Das l\'e4uft, zumindest in winzigem Umfang, wieder auf paar Interfaces mit Provider usw raus.\par
\par
Hm... Rekursion muss ich auch noch einbauen, sonst bringt das nicht viel.\par
Also wieder zwei Typen zusammenlegen zu einem. Hat paar Nachteile, aber eigentlich marginal.\par
\par
\par
Alles umgebaut. Erster Test mit Doclet:\par
Funktioniert auf Anhieb. Voll krass.\par
\par
Jetzt noch Tag Referenzierung einbauen.\par
Dabei aufgefallen: Ich muss die Syntax Reihenfolge umdrehen: Erst :parameterName, dann @see[5].\par
Umgedreht, getestet, passt.\par
Aber aufgefallen: Parameter JavaDoc kann ja gar keine tags haben. D.h. @ und : schlie\'dfen sich gegenseitig aus.\par
Das macht nichts, nur die Verarbeitung von methodenkommentaren muss entsprechend leicht anders gemacht werden.\par
Mal Reihenfolge der verarbeitungslogik \'fcberlegen ...\par
\par
Order must be:\par
1.) if explicit parameter name is present, search for that\par
2.) if explicit tag name is present, search for that\par
3.) if explicit description marker ("!") is present, use the description\par
4.) else, search for the passed parameter name\par
5.) use the description as the default\par
\par
\par
2019-05-20\par
\par
Am Wochenende ist mir auf-/eingefallen: Wenn ein param Tag selbst keine Tags mehr enthalten kann, dann kann man den extra identifier ja doch gleich auch als Index f\'fcr tags verwenden.\par
Also das "[]"-zeug wieder rausmachen. Wird einfach zu verstehen und zu programmieren. Sehr sch\'f6n.\par
\par
\par
\'dcberarbeitete Reihenfolge:\par
\par
1.) if explicit tag name is present, search for that and on hit, process accordingly\par
2.) if explicit description marker ("!") is present, use the description\par
3.) if explicit parameter name is present, search for that and on hit, process accordingly\par
4.) else, search for the passed parameter name\par
5.) use the description as the default\par
\par
\par
Hm. Neue, leicht verbesserte Regeln:\par
\par
"typeName"[#"memberName"][("parameterList")][@"tagName"][:"extraIdentifier"]\par
\par
- "typeName" ist das einzige, das zwingend ist.\par
- Ein Symbol macht alles vorherige (nach links) zwingend. Ausnahme (leider): das "@[tagName]" ist immer optional.\par
- Wenn die "()" fehlen, wird der memberName als Feld interpretiert.\par
- ParameterList ist eine kommagetrennte Liste mit 0+ Elementen. Es sind entweder lauter Typnamen oder lauter Parameternamen, aber keine Mischung.\par
- TagName ist ein \'fcbliches BlockTag: return, author, usw. F\'fcr mehrere Tags von der gleichen Art, siehe unten.\par
- "extraIdentifier" Leerstring (d.h. nur ":" angegeben): als parametername soll der Parametername des aktuell verarbeiteten Parametertags verwendet werden.\par
- "extraIdentifier" parsebar als Zahl: der Index f\'fcr die Auswahl aus mehreren gleichen Tags.\par
- "extraIdentifier" nicht parsebar als Zahl (alle restlichen F\'e4lle): wird bei einer referenzierten Methode als Parametername interpretiert und danach gesucht.\par
- Gibt es weder "tagName" noch "extraIdentifier", dann wird der Beschreibungstext verwendet.\par
\par
\par
So, soweit alles umgebaut.\par
Jetzt Tests bauen daf\'fcr ...\par
\par
Testen. Paar NPE durch Fl\'fcchtigkeitsfehler wie verdrehte Parameterargumente...\par
\par
Field funktioniert nicht bzw. das ist ja das TODO, ob commentText() \'fcberhaupt die richtige Mehode ist.\par
Mal syso-debuggen ...\par
\par
Tja, die FieldDocs sind leer, obwohl es zwei Felder mit JavaDoc gibt. Super. Lesen in der Doku...\par
Ah, da muss man erst ein d\'e4mliches Visibility-override flag mitgeben.\par
Testen. Geht.\par
\par
N\'e4chstes Problem:\par
Methodenreferenz mit leerer Parameterliste wird nicht gefunden.\par
Syso-debuggen ...\par
\par
Aha!\par
"[]" ist ein 1-elementiges array mit element "". Sehr fies.\par
Dann muss ich das Parameter parsen fixen ...\par
Gefixt. Testen.\par
Passt.\par
\par
Weiter morgen. Sollt aber so gut wie fertig sein.\par
\par
\par
2019-05-21\par
\par
Mal kurz reflektieren zu der bisher investierten Zeit.\par
\par
Mo\tab 5,50\par
Di\tab 2,50\par
Mi\tab 6,75\par
Do\tab 7,00\par
Fr\tab 7,00\par
\par
Mo\tab 6,50\par
\par
Stand Dienstag Morgen sind es bisher ca. 35h.\par
\par
Darin enthalten:\par
- Issue erstellen mit Beschreibung des Problems.\par
- Kleinere Besprechungen mit MK und FH zu dem Thema.\par
- Recherche zu DocLink API, Verwirrung zu alt und neu, Recherche und Testen zu Verwendung in eclipse (jar n\'f6tig usw.)\par
- Konzeptionierung (Grammatik, Anwendungsf\'e4lle). Iterativ (Handling von Tags hinzuf\'fcgen, Grammatik verbessern).\par
- Eigentliche Implementierung.\par
- Zus\'e4tzlich Code so strukturieren, dass m\'f6glichst viel f\'fcr Deployment in Eclipse anstatt Doclets wiederverwendet werden kann (besprochene L\'f6sung mit FH).\par
- Tests \'fcberlegen und schreiben.\par
- Debugging geht nicht bei Doclets (zumindest w\'fcsste ich nicht, wie), darum war testen und Fixen von Fl\'fcchtigkeitsfehlern sehr zeitaufwendig mit 90er Style Sys-Outs schreiben.\par
\par
Fazit:\par
Die "eigentliche Arbeit", Konzeptionierung, Implementierung und "normales" Testen, werden am Ende ca. 2 Tage Aufwand sein.\par
Der Rest von ca. 3 Tagen ist der \'fcbliche Overhead, der im Detail vorher nicht vorhersehbar ist, aber in der ein oder anderen Form immer dazukommt. Hier: Issueverwaltung, umst\'e4ndliche Recherche und Verwirrung, umst\'e4ndliches Debuggen, zus\'e4tzlich n\'f6tige Strukturierung.\par
\par
\par
Jetzt ordentliche Testklassen bauen, die alle Varianten abdecken.\par
\par
Hm. Dabei aufgefallen:\par
\par
1.)\par
Parameternamen sind eigentlich keine eindeutige Identifierungsm\'f6glichkeit, weil zwei Methodenvarianten mit unterschiedlichen Parametertypen trotzdem gleiche Parameternamen haben k\'f6nnen.\par
Ich glaub aber, ich lass das trotzdem drin. Denn: Die Wahrscheinlichkeit, dass das wirklich mal eine Kollision ergibt, ist sehr gering. Und wenn es so einen Fall \'fcberhaupt mal gibt, kann man ihn durch Angabe der Parametertypen anstatt der Namen sicher aufl\'f6sen. Das sch\'f6ne an JavaDoc schreiben ist, dass das kein Programmcode ist, der absolut korrekt sein muss oder es kracht, sondern ein Link kann auch mal falsch sein, man kann dann problemlos nachbessern, usw.\par
Daf\'fcr wird in den restlichen ~99% der F\'e4lle die Verwendung bequemer und aussagekr\'e4ftiger f\'fcr menschliche Leser.\par
\par
2.)\par
Ein \'fcbernommenes @see Tag mit lokaler Referenz muss von der Logik zu einer globalen / full qualified Referenz umgebogen werden, sonst wird der Link unbrauchbar oder \'e4ndert sogar seine Bedeutung.\par
Das muss ich fixen.\par
Gefixt. Test wird dann gleich von den allgemeinen Tests abgedeckt.\par
\par
Ach und field und class doc handling braucht ja auch noch Tag handling.\par
Bissl abstrahiert und eingebaut. Test wird auch hier dann gleich von den allgemeinen Tests abgedeckt.\par
\par
Jetzt weiter Tests schreiben.\par
\par
\par
2019-05-22\par
\par
TestSubjectClass JavaDoc schreiben.\par
Paar aufgefallene TODOs in den DocLinker Code schreiben.\par
\par
Code noch bissl aufr\'e4umen und zumindest JavaDoc Ein-Satz-Klassenbeschreibungen schreiben f\'fcr die Klassen, die zum verstehen und nachbauen wichtig sind.\par
\par
Testen.\par
\par
Oh, interessante Erkenntnis: Um @Tags zu referenzieren, sollte nicht wieder ein @ verwendet werden, sonst interpretiert das JavaDoc Dings das als das eigentliche Tag (z.B. @see) und wirft entsprechende Warnings oder treibt sogar mal was ungew\'fcnschtes mit dem Code.\par
Jetzt ist die Frage, was ich stattdessen nehmen sollte, was halbwegs nachvollziehbar ist und keine Zweideutigkeiten erzeugt. Vielleicht "\'a7".\par
Umbauen.\par
\par
Achso, hehe: der beschwert sich dar\'fcber, dass (durch das @docLink tag) grunds\'e4tzlich ung\'fcltige Zeichen in einem @see stehen.\par
F\'fcr die richtige JavaDoc wird das ja durch das sourcecode-post-processing behoben und den eclipse javadoc view st\'f6rt es nicht. Also kein Handlungsbedarf, nur mein Doclet Test mault bissl, aber das ist egal.\par
\par
Hm, aber w\'e4re das @ nicht trotzdem ein Problem?\par
Naja, ich machs jetzt mal so: Ich mach wieder das @ rein und wenn es Probleme geben sollte, kann man ja wieder tauschen.\par
\par
N\'e4chstes Problem:\par
Exception 'No parameter found with name "null"'.\par
\par
OMG. EWIG syso-pseudo-debuggt, bis ich gefunden habe, dass das ja nur in einer print methode im Doclet~Printer drin war.\par
Das ist halt das Problem, wenn man nicht richtig debuggen kann ...\par
\par
Ah, Parserbug entdeckt: Nicht das erste Vorkommen von "\{" in einem String mit @docLink ist das richtige, sondern das n\'e4heste vor dem  @docLink mit nur WhiteSpaces dazwischen.\par
Fixen.\par
\par
Achso, hm, der Parser macht eigentlich schon:\par
Bei einem gefundenen "\{" bis zum n\'e4chsten "\}" scrollen und dann schauen, ob der inhalt ein docLink ist. Wenn nein, skippen. Das sollte eigentlich alle nicht-docLink-Tags sauber \'fcberspringen.\par
Warum tut es das nicht? Oder wird nur der geskippte Teil des Texts nicht als Text weitergegeben? Das k\'f6nnte es sein...\par
Jup, das isses.\par
Fixen.\par
Bissl rumprobieren. Alles nicht so einfach hier. Der initiale Teil vor dem ersten "\{" muss auch mit.\par
Jetzt passts.\par
\par
Weiter testen/fixen.\par
Haha: Paar nicht aufl\'f6sbare Links kommen einfach daher, dass ich die falsche Methode reingeschrieben hab.\par
\par
Weiter testen.\par
Da werden Ersetzungen doppelt gemacht. Aber die Frage ist jetzt: kommt das von der DocLink Logik oder von dem Test-Printer assemblen?\par
Ohne richtiges Debuggen m\'fchsam rauszufinden ...\par
*seufz*\par
\par
\par
2019-05-23\par
\par
Mal durchdenken.\par
Ich glaub, das Problem kommt davon, dass bei einer rekursion zwei kollidierende Arten von Stringbuilding verwendet werden:\par
1.) charBuilder wird \'fcbergeben, resettet, gef\'fcllt, geyieldet.\par
2.) geyieldeter String wird zur\'fcckgegeben und vom aufruferkontext zum charBuilder hinzugef\'fcgt.\par
Da k\'f6nnte es irgendwie sein, dass bei einer Rekurionstiefe gr\'f6\'dfer 0 der String verdoppelt hinzugef\'fcgt wird.\par
Andererseits: was ist dann eigentlich mit dem reset? Hm...\par
\par
Das muss ich mal durchdenken und aufr\'e4umen.\par
Es muss reichen, eine der beiden Varianten zu verwenden. Idealerweise die ohne String umkopieren und dann den Inhalt nochmal kopieren, sondern ein direkt durchgereichter char sammeler.\par
Dann wird zwar die API minimal komplizierter, aber besser als verwirrende konflikete Strategien.\par
Hm... oder wird sie \'fcberhaupt komplizierter? Wird sie nicht einfach einfach, wenn der linker seinen char builder ja eh intern h\'e4lt?\par
Mal durchdenken ...\par
\par
Hm, oder kommt der Fehler eher von dem gestern eingebauten nachtragen von \'fcbersprungenen Tags bzw. Text allgemein und bei Rekursionen wird der falsche Startindex \'fcbergeben, so dass die Ebene tiefer zu viel mitloggt...\par
mal untersuchen ...\par
\par
\par
2019-05-24\par
\par
Die gestern daheim und heute morgen zusammengegr\'fcbelte L\'f6sung umsetzen.\par
Testen.\par
Dabei aufgefallen: @link Tags mit lokaler Referenz m\'fcssten auch globalisiert werden.\par
Ich mach zumindest mal ein TODO daf\'fcr.\par
\par
Testergebnisse durchschauen. Sieht soweit gut aus.\par
\par
Noch das Referenz-globalisieren testen.\par
Oh, dabei \'fcberraschende Exception: kein "see" Tag gefunden bei einer Methode mit drei @see tags.\par
Syso-debuggen.\par
Also die drei sind drin. Warum findet der die nicht?\par
Genauer debuggen...\par
Kind ist see, name ist see, gesucht wird nach see. Alles ist see. Wieso geht das nicht?\par
Evtl. liegts am index runterz\'e4hlen ...\par
\par
Ach ich bein ja ein Depp:\par
Der Name ist nicht "see", sondern "@see".\par
Also @ wieder an den geparsten Tagnamen ranbauen.\par
Testen.\par
\par
Na also, geht.\par
Die Referenz-Globalisierung geht auch.\par
\par
Generierten Output weiter anschauen ... sieht gut aus.\par
\par
Jetzt die paar Aufr\'e4um-TODOs machen.\par
\par
\par
Und jetzt muss ich das noch grob beschreiben, damit das f\'fcr andere verwendbar wird.\par
\par
Gliederung:\par
1.) Konzeptbeschreibung\par
2.) Grammatik mit Beispielen\par
3.) Bekannte Probleme / offene Baustellen\par
4.) Verwendung\par
\par
\par
\par
\par
JavaDoc-Erweiterung "DocLink"\par
Thomas M\'fcnz, 2019-05-27\par
\par
\'dcbersicht:\par
1.) Konzept\par
2.) Syntax\par
3.) Bekannte Probleme\par
4.) Test und Einsatz\par
\par
---\par
\par
1.) Konzept\par
\par
Was ist das und wof\'fcr brauch ich es?\par
\par
Ich habe beim Versuch, systematisch JavaDoc f\'fcr MicroStream zu schreiben, festgestellt, dass es ein riesiges Problem gibt:\par
\'dcberladene Methoden, gekapselte Konstruktoren, usw. haben wahnsinnig viel Redundanz in ihrer JavaDoc. Ein, sagen wir "int timeout", was konzeptionell eigentlich immer ein und dasselbe Ding ist, muss da ganz schnell an 10 verschiedenen Orten JavaDoc-beschrieben werden. Was soll man da machen? 10 mal manuell tippen w\'e4r d\'e4mlich. 1 mal manuell tippen und 9 mal "see \{@link...\}" schreiben, w\'e4re f\'fcr den Leser ziemlich st\'f6rend beim Verstehversuch und damit irgendwie das Gegenteil von dem, was JavaDoc eigentlich leisten soll. 1 mal manuell tippen und 9 mal kopieren w\'e4re denkbar, aber sobald an der JavaDoc mal was ge\'e4ndert (erweitert/verbessert) werden muss, bricht das Chaos auf. Egal, ob jedes mal 1 mal \'e4ndern und 9 mal ersetzen (hoffentlich findet man noch alle Stellen) oder 10 mal \'e4ndern, es artet immer in riesige Arbeit und Fehleranf\'e4lligkeit aus. Hat man alle Stellen erwischt? Braucht man daf\'fcr ein extra Referenz-Verzeichnis? Wartet man das auch sorgf\'e4ltig mit? (nat\'fcrlich nicht...)\par
\par
Was hier fehlt ist doch: Man m\'fcsste JavaDoc Stellen untereinander verlinken k\'f6nnen. So wie dieses @inheritDoc, nur eben auch f\'fcr andere F\'e4lle.\par
\par
Also zum Beispiel:\par
Man dokumentiert den "@param timeout" f\'fcr den "int timeout" einmal explizit und an den anderen 9 Stellen schreibt man dann sowas wie "@param timeout \{@copy TypeName#methodName(int):timeout\}".\par
Der Unterschied zu \{@link ...\} ist: Der Leser muss da nicht draufdr\'fccken und in der JavaDoc herumspringen, sondern beim JavaDoc Generieren wird die einmal geschriebene Dokumentation f\'fcr den @param timeout an die anderen 9 Stellen kopiert und man kann es direkt lesen.\par
Das ist die best-vorstellbare L\'f6sung:\par
- Man muss es nur einmal schreiben.\par
- Man muss es nur einmal warten und kann keine Stelle \'fcbersehen.\par
- Der Leser kann an jeder der 10 Stellen trotzdem direkt die Beschreibung lesen. Ohne Herumspringen und die daraus resultierende Verwirrung/Frustration.\par
\par
Meine Erfahrung ist: In einer API mit einigerma\'dfen Convenience Schicht (viele \'dcberladungen und viele Wrapper-Methoden) kann man \'fcberhaupt erst wirtschaftlich (und nervlich) sinnvoll JavaDoc schreiben, wenn man so einen Linking-Mechanismus hat. Ansonsten verschwendet man langfristig nur Zeit, Geld und Nerven.\par
Darum hab ich mal sowas gebaut.\par
\par
\par
\par
2.) Syntax\par
\par
Ist ganz simpel. Es ist nur ein neues JavaDoc Tag. Hei\'dft nicht diffus "@copy", sondern "@docLink".\par
Die Syntax ist so nah wie m\'f6glich an dem, was man von JavaDoc eh schon kennt. Alles andere w\'e4re ja d\'e4mlich.\par
\par
Hier ein paar Beispiele:\par
\par
Link auf die allgemeine Beschreibung des Typs "com.my.app.MyType":\par
\{@docLink com.my.app.MyType\}\par
\par
Link auf die allgemeine Beschreibung des Felds "com.my.app.MyType#timeout":\par
\{@docLink com.my.app.MyType#timeout\}\par
\par
Link auf die allgemeine Beschreibung der Methode "com.my.app.MyType#doStuff()":\par
\{@docLink com.my.app.MyType#doStuff()\}\par
\par
Link auf die allgemeine Beschreibung der Methode "com.my.app.MyType#doStuff(int, String)":\par
\{@docLink com.my.app.MyType#doStuff(int, String)\}\par
\par
Es geht auch per Namen anstatt per Typen:\par
\{@docLink com.my.app.MyType#doStuff(timeout, name)\}\par
\par
Soweit so langweilig. Was ist nun, wenn man gezielt einen Parameter verlinken will, so wie im Beispiel oben?\par
Das hab ich oben eh schon gespoilert:\par
\{@docLink com.my.app.MyType#doStuff(int, String):timeout\}\par
\{@docLink com.my.app.MyType#doStuff(timeout, name):timeout\}\par
\par
Also das hei\'dft "von der Methode mit Namen doStuff und den beiden Parametern timeout und name, nimm die Parameter-Beschreibung von timeout."\par
Damit man eben wo anders, z.B. bei der Methode com.my.app.MyType#doStuff(int) mit Default-String als Name, nur noch schreiben braucht:\par
@param timeout \{@docLink com.my.app.MyType#doStuff(int, String):timeout\}\par
Also eben "Hol dir die Parameterbeschreibung f\'fcr die \'fcberladene Variante von der Hauptvariante der Methode."\par
Einmal schreiben und dann nur noch verlinken. So muss das sein!\par
\par
Eine kleine Optimierung kann man da noch machen:\par
Wenn vorne eh schon steht, dass es sich um den Parameter mit Namen "timeout" handelt, muss man dann hinten wirklich nochmal explizit ":timeout" schreiben? Das ist ja nervig ... Au\'dferdem m\'fcsste man da wieder doppelt \'e4ndern/warten.\par
Richtig!\par
Darum geht das auch besser:\par
@param timeout \{@docLink com.my.app.MyType#doStuff(int, String):\}\par
Nur ein ":" hei\'dft: "Verwend den aktuellen JavaDoc Parameternamen f\'fcr den Link."\par
Ich denke, in 99% der F\'e4lle wird das eh zutreffen, darum war es sinnvoll und wichtig, das einzubauen.\par
Der ":" ist \'fcbrigens wichtig, denn ohne den bezieht sich der Link ja auf die Methode selbst, also auf die allgemeine JavaDoc Beschreibung.\par
\par
Was ist mit Tags?\par
Es gibt ja neben allgemeiner Beschreibung und Parametern auch noch alle m\'f6glichen Tags. Z.B. das @return. Wie verlinkt man das?\par
\par
V\'f6llig \'fcberraschenderweise so:\par
\{@docLink com.my.app.MyType#doStuff(int, String)@return\}\par
\par
Also wieder bei dem Beispiel der \'fcberladenen Methode "com.my.app.MyType#doStuff(int)" br\'e4uchte man in der JavaDoc dann nur noch schreiben:\par
@return \{@docLink com.my.app.MyType#doStuff(int, String)@return\}\par
\par
Jetzt gibts aber manchmal mehrere Tags von der gleichen Sorte. Z.B. @see Tags. Das sind oft 2, 3, 4 oder noch mehr.\par
Darum muss man zu einem Tag auch noch einen Index angeben k\'f6nnen:\par
\{@docLink com.my.app.MyType@see:0\}\par
Das erste @see Tag soll kopiert werden. Oder nat\'fcrlich :1, :2, usw.\par
\par
\{@docLink com.my.app.MyType@return:0\} m\'fcsste auch gehen (hab ich noch gar nicht getestet).\par
\{@docLink com.my.app.MyType@return:1\} ist nat\'fcrlich immer Unfug.\par
\par
Und es geht nat\'fcrlich auch:\par
\{@docLink com.my.app.MyType#doStuff(int, String)@param:0\}\par
\{@docLink com.my.app.MyType#doStuff(int, String)@param:1\}\par
Wenn man die Parameter nach Reihenfolge anstatt nach Namen ausw\'e4hlen will.\par
Ich wei\'df nicht, ob das in bestimmten F\'e4llen die g\'fcnstigste L\'f6sung ist. Im Zweifel ist es eher gef\'e4hrlich. Jedenfalls ist es m\'f6glich.\par
\par
Das wars eigentlich schon.\par
Zusammengefasst ist die Syntax f\'fcr den Inhalt von \{@docLink ... \}\par
"typeName"[#"memberName"][("parameterList")][@"tagName"][:"extraIdentifier"]\par
\par
Der "extraIdentifier" kann je nach Kontext entweder ein Parametername oder der Index f\'fcr eins von mehreren Tags sein.\par
Die [] hei\'dfen, dass der Teil optional ist (siehe Beispiele).\par
Der Rest ist selbsterkl\'e4rend.\par
\par
Noch ein paar Specials:\par
\par
Wenn in einem verlinkten Text wieder ein DocLink steht, muss der nat\'fcrlich auch aufgel\'f6st werden. Genauer gesagt: Es m\'fcssen rekursiv so lange alle docLink Tags aufgel\'f6st werden, bis der finale Text feststeht.\par
Das hab ich ber\'fccksichtigt. Ein ekliger Sonderfall dabei, n\'e4mlich eine Schleife in der Rekursion, ist aber noch nicht gel\'f6st. Siehe "Bekannte Probleme".\par
\par
Wenn in einem @see eine lokale Referenz steht (z.B. @see #doStuff()), dann muss die beim Verlinken aus einer anderen Klasse nat\'fcrlich in eine globale Referenz (@see com.my.app.MyType#doStuff()) umgewandelt werden, sonst ist die Referenz kaputt. Das wird automatisch mitgemacht. F\'fcr @link hab ich es dummerweise vergessen. Siehe "Bekannte Probleme".\par
\par
\par
\par
3.) Bekannte Probleme\par
\par
Mir sind w\'e4hrend dem Testen einige Probleme und erwartbare, aber fehlende Features aufgefallen, die ich aber nicht gel\'f6st habe, weil ich nach viel zu viel investierter Zeit (u.A. wegen fehlender Debugbarkeit dieser seltsamen Doclets) mal einen Schlusstrich ziehen wollte. Das ist halt momentan Version 1.0. Die Fixes w\'e4ren dann Version 1.1, aber wann und von wem die gemacht werden wird, muss sich dann zeigen. TODOs im Sourcecode hab ich auf jeden Fall mal geschrieben.\par
\par
Problem #1\par
Wenn JavaDoc A auf JavaDoc B verweist und B wieder auf A, gibt das momentan eine rekursive Endlosschleife, bis der Prozess auf einen Stack Overflow l\'e4uft. Die Vermeidung w\'e4re gar nicht so schwer, simples Konzept steht schon im Code, aber Schlusstrich f\'fcr Version 1.0 und so. Sollte aber nicht so dramatisch schlimm sein, weil das ohnehin ein Fehler in der JavaDoc w\'e4re und dann halt nach der Exception entsprechend korrigiert werden muss. \par
\par
Problem #2\par
Ein @link Tag mit lokaler Referenz (z.B. \{@link #doStuff()\}) wird noch nicht in eine globale (bzw. full-qualified) Referenz umgewandelt, d.h. solche Links gehen kaputt.\par
\par
Problem #3\par
Umgekehrt sollte das mit den lokalen Referenzen aber auch funktionieren: Innerhalb einer Klasse sollte man bei einem @docLink, genau wie bei JavaDoc allgemein, den Typenamen weglassen k\'f6nnen. Ist technisch ja auch trivial zu machen. Das hatte ich anfangs irgendwie nicht bedacht. Aber halt Version 1.0 und so.\par
\par
Problem #4\par
Und das Weglassen sollte, analog zu Parameternamen, auch f\'fcr den Membernamen gelten, wenn das aktuell verarbeitete Element ein Feld oder Methode ist.\par
Also z.B. so:\par
\{@docLink TargetType#\} -> "Gleichnamiges Feld/Methode in dem anderen Typ".\par
Oder sogar so:\par
\{@docLink TargetType#:\} -> "Gleichnamiger Parameter der gleichnamigen Methode in dem anderen Typ".\par
W\'e4re technisch eine Kleinigkeit. Muss man halt mal schauen.\par
\par
\par
\par
4.) Test und Einsatz\par
\par
Dieser Punkt ist eigentlich auch noch Baustelle. Denn: Es geht schon. Aber eigentlich noch nicht. Es gibt da n\'e4mlich ein Problem...\par
\par
Um JavaDoc Generierung zu customizen, gibt es ein "Doclet" Konzept im JDK.\par
Das ist gerade zwischen Java 8 und 9 auch noch komplett umgebaut worden. Bis Java 8 war es ... sehr wirr, in Java 9 ... nur noch ziemlich wirr. JDK halt.\par
Die Idee ist: Man gibt beim JavaDoc generieren lassen ein St\'fcck custom Code mit (ein "doclet") und das wird dann ausgef\'fchrt.\par
In Eclipse geht das zum Beispiel so:\par
Rechtsklick auf Projekt -> Export -> Java -> JavaDoc -> Next -> "Use custom doclet":\par
Doclet name: [muss der full qualified class name zu einer Klasse mit der magic "start" Doclet-Methode sein.] (Pseudo-interface Bullshit Gewurschtel L\'f6sung. Typisch JDK. Ab der Java 9 L\'f6sung k\'f6nnen sie sogar ECHTE Intefaces. Der Wahnsinn!)\par
Doclet class path: [Filesystem Pfad zu den Klassen] (Soweit ich wei\'df muss das ein jar sein, sonst geht es nicht. War anfangs sehr verwirrend ...)\par
\par
Was momentan geht, ist, so eine pseudo-interface-m\'e4\'dfig implementierte Klasse (doclink.doclet.DocletJava8DocLinkPrinter), die input und output f\'fcr so eine DocLink Ersetzung in die Konsole schreibt.\par
JavaDoc HTML Output gibts keinen, weil sich n\'e4mlich schnell herausgestellt hat, dass ein Doclet ohnehin unbrauchbare w\'e4re.\par
\par
Das Problem ist n\'e4mlich:\par
Es schaut ja eher selten jemand in so ein JavaDoc HTML Zeug rein, sondern man schaut ja eher \'f6fter direkt in die JavaDoc View oder Tooltips in der IDE live beim Entwickeln. Zumindest muss die live Variante auch funktionieren.\par
Dummerweise bieten aber IDEs (zumindest eclipse) keine M\'f6glichkeit, in ihre JavaDoc View ebenfalls ein Doclet einzuklinken.\par
(Im Umkehrschluss fragt man sich da schon irgendwie, ob denn \'fcberhaupt jemand dieses Doclet Zeug benutzt, denn die m\'fcssten ja alle dieses Problem haben)\par
Eine kurze Recherche von FH im eclipse Source Code hat ergeben: Das ist da drin die \'fcbliche Katastrophe. Da irgendwas zu schreiben oder zu pimpen, k\'f6nnen wir knicken.\par
Und dann w\'e4ren da ja auch noch alle anderen Java IDEs, die man unterst\'fctzen m\'fcsste. Sehr bl\'f6d.\par
\par
Macht aber nichts, denn der ganze Doclet Aufwand ist eh gar nicht n\'f6tig. Es gibt eine viel elegantere L\'f6sung:\par
Wir machen beim Deployment von Sourcecode sowieso schon so eine Art "Source Code post-processing", wo z.B. License Header usw. hinzugef\'fcgt werden.\par
Dort kann man die DocLink Logik mit reinklemmen, dann verschwinden alle nicht-JavaDoc-Standard @docLink Tags und man bekommt stattdessen das generierte Ergebnis mit den redundanten Texten.\par
Funktioniert ohne Doclets und automatisch f\'fcr alle IDEs. Sehr sch\'f6n!\par
\par
Ironischerweise ist der einzige, f\'fcr den es nicht funktioniert, der JavaDoc Schreiber live beim Schreiben.\par
Daf\'fcr br\'e4uchten wir einen eigenen eclipse JavaDoc View, der die DocLink Logik enth\'e4lt. Ist vielleicht mal was f\'fcr die Zukunft (DocLink 2.0?), aber ich ahne, wie viel Aufwand das w\'e4re und wie hoch dadurch die Priorit\'e4t daf\'fcr sein w\'fcrde. Naja mei.\par
\par
\par
Also der aktuelle Stand ist:\par
Mit der "doclink.doclet.DocletJava8DocLinkPrinter" Klasse kann man den DocLink Code zumindest mal grunds\'e4tzlich testen.\par
Das Projekt enth\'e4lt praktischerweise selbst gleich zwei Testklassen:\par
- "doclink.test.TestTargetClass", das ist die Klasse, auf die docLinks zeigen, mit selbst ein paar docLinks, um Rekursion zu testen.\par
- "doclink.test.TestSubjectClass", das ist die Klasse, die mit docLinks auf die TagetClass zeigt. Deren JavaDoc muss am Ende gut aussehen (keine @docLink Tags mehr und keine seltsamen L\'fccken oder Verdoppelungen).\par
\par
Vorgehensweise zum Testen:\par
1.) Das Projekt braucht eine Abh\'e4ngigkeit zur "tools.jar" des JDK. Aber nur f\'fcr den Doclet Test. Der DocLink Code selbst hat abgesehen vom JDK gar keine Abh\'e4ngigkeiten, auch nicht zu MicroStream Code.\par
2.) Das DocLink Projekt als jar exportieren. (z.B. nach "D:\\DocLink.jar")\par
3.) F\'fcr das DocLink Projekt JavaDoc erzeugten (siehe oben), mit den Angaben "doclink.doclet.DocletJava8DocLinkPrinter" und "D:\\DocLink.jar".\par
\par
Dann m\'fcsste in der Konsole der beschriebene Input und Output ausgegeben werden.\par
Inklusive ein paar Warnings f\'fcr @see Tags, weil JavaDoc ja die docLink Tags nicht kennt. Das macht aber nichts, weil die docLink Tags ja ersetzt werden mit (hoffentlich!) validem Text. Also solche Warnings einfach ignorieren.\par
Es m\'fcsste dann auch im Working Directory ein "doc" Verzeichnis erzeugt worden sein. Das ist aber leer, weil das selbstgebastelte Doclet ja gar keinen File-Output erzeugt. Das passt also und ist kein Fehler.\par
\par
Es war gerade beim Testen seltsamerweise so, dass Eclipse nach dem Neustart beim ersten Mal trotz Angabe das Doclet nicht verwendet hat. Aber beim zweiten Mal gings dann. Also falls nichts passiert, einfach nochmal versuchen. Keine Ahnung ...\par
\par
\par
Konkreter Einsatz:\par
\par
Damit es wirklich funktioniert, m\'fcsste anhand der Vorlage der drei Doclet-Klassen (im Package "doclink.doclet") nun eine entsprechende Integration f\'fcr das Deployment aus Eclipse heraus erstellt werden. Mit verwendeter API halt das Eclipse Syntax Tree Zeug anstatt dem "com.sun.javadoc.*" Zeug. Aktuell wei\'df ich nicht, wie ich das selber machen k\'f6nnte oder ob es den Aufwand wert w\'e4re, das daf\'fcr n\'f6tige daf\'fcr aufzusetzen, mich einzulesen, usw.\par
Sollte eigentlich recht schnell kopiet und angepasst werden k\'f6nnen. Mal sehen ...\par
\par
Der DocLink Sourcecode selbst sollte mehr oder weniger selbsterkl\'e4rend sein:\par
Es gibt halt die schon erw\'e4hnten Unterpackages f\'fcr "doclet" und f\'fcr "test". Die Zentralen Klassen sind "DocLink" (statische Logik), "DocLinker" (Funktionales interface mit Defaultimplementierung) und dann ein paar Grusch-Typen f\'fcr statische Util Methoden, String-bau-Interface, Mini-Datenstruktur, usw.\par
Abh\'e4ngigkeiten gibt es, wie oben geschrieben, "eigentlich" gar keine.\par
\par
\par
\par
Hier noch Links, die ich f\'fcr die Verwendung des Doclet Zeugs gebraucht habe:\par
{{\field{\*\fldinst{HYPERLINK https://docs.oracle.com/javase/8/docs/jdk/api/javadoc/doclet/index.html }}{\fldrslt{https://docs.oracle.com/javase/8/docs/jdk/api/javadoc/doclet/index.html\ul0\cf0}}}}\f0\fs28\par
{{\field{\*\fldinst{HYPERLINK https://docs.oracle.com/javase/8/docs/jdk/api/javadoc/doclet/com/sun/javadoc/RootDoc.html }}{\fldrslt{https://docs.oracle.com/javase/8/docs/jdk/api/javadoc/doclet/com/sun/javadoc/RootDoc.html\ul0\cf0}}}}\f0\fs28\par
\par
Dort wird auch die magic "start" Methode erkl\'e4rt. Das "ListParams" Beispiel ist im DocLink Projekt als Referenz enthalten.\par
\par
\par
---\par
\par
2019-05-27\par
\par
Dokumentation fertigstellen.\par
Zippen.\par
MS-142 updaten.\par
Fertig.\par
\par
JavaDoch an sich weitermachen. DocLink verwenden.\par
\par
\par
2019-05-28\par
\par
JavaDoc weitermachen.\par
\par
Templates:\par
\par
Pseudo-constructor method to create a new \{@link XXXXXXXXXXXXXXXXXXXXXXXXX\} instance\par
using the passed value and default values defined by \{@link XXXXXXXXXXXXXXXXXXXXXXXXX.Defaults\}.\par
<p>\par
For explanations and customizing values, see \{@link XXXXXXXXXXXXXXXXXXXXXXXXX#YYYYYYYYYYYYYYY()\}.\par
\par
@return a new \{@link XXXXXXXXXXXXXXXXXXXXXXXXX\} instance.\par
\par
\{@docLink XXXXXXXXXXXXXXXXXXXXXXXXX#New(YYYYYYYYYYYYYYY)\}\par
\par
\{@docLink XXXXXXXXXXXXXXXXXXXXXXXXX#New(YYYYYYYYYYYYYYY):\}\par
\par
\{@docLink XXXXXXXXXXXXXXXXXXXXXXXXX#New(YYYYYYYYYYYYYYY)@return\}\par
\par
\par
\par
\par
2019-05-29\par
\par
Weitermachen.\par
\par
2019-05-31\par
\par
Weitermachen.\par
\par
\par
\par
2019-06-02\par
\par
Weitermachen.\par
\par
\par
2019-06-03\par
\par
Weitermachen.\par
\par
\par
2019-06-04\par
\par
Weitermachen.\par
Mal schnell neue Version von DocLink machen. MS-142 updaten.\par
\par
\par
2019-06-05\par
\par
Weitermachen.\par
\par
\par
\par
2019-06-06\par
\par
Weitermachen.\par
\par
Hm. Die #start Varianten sollten analog zu den #Foundation Varianten sein.\par
\par
\par
\par
2019-06-07\par
\par
Weitermachen.\par
\par
EmbeddedStorage fertigstellen, optimieren, aufr\'e4umen.\par
\par
\par
\par
2019-06-09\par
\par
Mal schauen, was als n\'e4chstes kommt. Storer und Foundation.\par
\par
\par
2019-06-11\par
\par
Anstatt gar nichts schreib ich doch lieber mal generische JavaDocs \'fcber die Foundation getter und setter.\par
\par
Oh Mann, da fehlt schon wieder eine docLink Funktionalit\'e4t. Muss ich vorerst \'fcber copy&paste machen. Hinweiskommentar dazu schreiben. MS-142 aktualisieren.\par
}
 