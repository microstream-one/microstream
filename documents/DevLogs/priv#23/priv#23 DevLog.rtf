{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-07-26\par
\par
Also mal Brainstorming ...\par
\par
Die Konsistenz der enums muss gleich beim Typen Initialisieren bzw. sp\'e4testens beim roots laden \'fcberpr\'fcft werden.\par
Also m\'fcssen eigentlich alle enums als root Referenzen registriert werden.\par
Das hei\'dft nat\'fcrlich auch: Wenn zur Laufzeit ein neuer Enum Typ gesehen wird, muss die Roots Instanz aktualisiert werden.\par
Vielleicht w\'e4re es das beste, als enum root gleich das values array abzuspeichern, sonst hat man tausende root instanzen, alle per String identifiziert, die man erst wieder zusammengruppieren muss, usw.\par
Und am besten k\'f6nnte man als root String gleich die TypeId hernehmen ...\par
Oder vielleicht "enum:100053:com.MyApp.stuff.AppCategory".\par
Denn vielleicht muss mal noch was anderes in dieser type:name Form gespeichert werden.\par
Das Array dahinter wird geladen. Da stecken alle enum instanzen mit ordinal und name drin.\par
\'dcber die TypeId und ggf. den namen holt man sich die aktuelle Laufzeit enum Klasse und deren values.\par
Dann wird index f\'fcr index verglichen: ordinal gleich? Name gleich? Wenn ja, passt, wenn nein: mismatch.\par
Aber ne, Moment: dann ist es ja schon zu sp\'e4t. Das muss der RootResolver machen und wenn alles passt, gleich die JVM-erzeugten enum Konstanten mit den TypeIds assoziieren. Hm, knifflig.\par
\par
Keine Thema f\'fcr Freitag 16:30 mit 29,8\'b0 im B\'fcro.\par
Ende f\'fcr Heute.\par
\par
\par
2019-07-29\par
\par
Ein paar Konzept\'fcberlegungen vom Wochenende:\par
\par
1.)\par
Der Root Eintrag darf nicht den Typnamen enthalten. Muss er auch gar nicht, es reicht die TypeId.\par
Also sowas: "enum 100097".\par
Damit ist klar: es ist eine enum und der eigentliche Typename kann \'fcber das Dictionary aufgel\'f6st werden.\par
\par
2.)\par
es spricht eigentlich nichts dagegen, die Namen (genauer: Identfikation) und Reihenfolge der enum Konstanten direkt in der TypeDescription zu hinterlegen.\par
Ein einfachsten Fall genauso wie in Java:\par
MINOR,\par
MAJOR,\par
CRITICAL,\par
\par
Optional muss man noch ein Identit\'e4tsmapping angeben k\'f6nnen, das w\'e4re dann das '@PersistenceId("Priority1")' aus dem Issue.\par
Also so:\par
MINOR:"Priority1",\par
MAJOR:"Priority1.5",\par
CRITICAL:"Priority2",\par
\par
\par
Der zweite String w\'e4re dann die Zuordnung im Runtime Type.\par
Falls so eine Annotation vorhanden ist, dann z\'e4hlt die, ansonsten wird es als Feldname interpretiert. Damit man z.B. auch schreiben kann:\par
MAJOR:CRITICAL\par
\par
Also was bisher in der persistenten Form die Instanz "MAJOR" ist, soll in der aktuellen Runtime Form zu der Instanz "CRITICAL" aufgel\'f6st werden.\par
\par
Damit kann genau abgeglichen werden, dass alle bisher existierenden Eintr\'e4ge in die Laufzeit gemappt werden k\'f6nnen:\par
- Fehlt die zweite Angabe, muss es den Namen genau so in der aktuellen Runtime Definitions des enums auch geben.\par
- Ist die zweite Angabe da, wird daraufhin umgemappt. Alle effektiven Identifier (Einzelangaben und zweite Angabe von Doppelangaben) m\'fcssen eindeutig sein.\par
(D.h. es k\'f6nnen nicht zwei bisherige enum Instanzen auf eine konsolidiert werden. Denn es werden hier keine OID umgeschrieben, sondern OID zu Instanzen aufgel\'f6st. 2 OIDs m\'fcssen 2 Instanzen ergeben)\par
- In der aktuellen Runtime definition \'fcberz\'e4hlige Instanzen sind kein Problem. Die kommen einfach dazu (siehe unten).\par
- Es muss auch eine M\'f6glichkeit geben, in der persistenten Form bestehende enum Instanzen explizit zu "l\'f6schen". Beim Laden wird dann stattdessen null zur\'fcckgegeben. Das ist konsistent mit der expliziten Vorgabe.\par
\par
\par
Unter der OID des Root Eintrags wird immer ein Object[] abgespeichert (NICHT ein Array des enum types, sondern spezifisch Object[]!), in dem alle enum Konstanten in Reihenfolge aufgelistet sind.\par
Beim Typen Validieren wird ja schon ein Abgleich vorgenommen und das Mapping, falls es keine Exception gibt, vorgehalten.\par
Beim Roots laden wird dann dieses mapping mit dem Inhalt des Array abgeglichen: Stimmt es genau \'fcberein (Namen und Reihenfolge!), dann wird weiter nichts gemacht.\par
Ansonsten wird ein neues Object[] mit der neuen Reihenfolge erstellt.\par
\par
Ein bisschen knifflig wird noch, an welcher Stelle OID und JVM-erzeugte Konstanteninstanzen miteinander assoziiert werden, so dass es nicht "zu sp\'e4t" (Registrierung in der ObjectID) ist.\par
Das musste im create des enum handlers sein.\par
\par
Die Frage ist noch, welche "Reihenfolge":\par
Bisherige Typdefinition oder aktuell gemappte.\par
Eigentlich muss es die aktuell gemappte sein, weil ja \'c4nderungen (z.B. neue Konstanteninstanzen) hier schon ber\'fccksichtigt werden m\'fcssen, damit der Abgleich eine korrekte, aktuelle Form ergibt.\par
\par
Und die Frage ist noch: Wie bekommt diese Stelle (also wahrscheinlich die BinaryHandlerEnum Instanz) die Referenz auf dieses Mapping her? Referenz auf diese \par
\par
Soweit die bisherigen \'dcberlegungen am Wochenende. Das sollte so funktionieren.\par
\par
\par
Dann mal als ersten Schritt den TypeDictionary Parser erweitern ...\par
\par
Hm. Dabei gleich Parserlogik umstellen von bound-ignoranz auf ordentliches iStart/iBound Konzept.\par
Das TODO dazu ist 6 Jahre alt :D. Wie die Zeit vergeht... Ich hab das immer noch als "Achja, da m\'fcsste ich demn\'e4chst mal den Parser verbessern" im Kopf.  6 jahre ...\par
\par
Parserverbesserung fertig.\par
Parsererweiterung f\'fcr enum fertig.\par
Den neuen Membertype daf\'fcr muss ich morgen noch fertig bauen.\par
\par
\par
2019-07-30\par
\par
Wieder \'dcberlegung von daheim:\par
In das Type Dictionary kommt kein Mapping rein. Sonst m\'fcsste man da ja doch manuell reinfassen und sonst m\'fcsste man bei jeder Typ\'e4nderung (neue Typversion) alle alten Typen nachbessern.\par
F\'fcr das alles gibt es die Refactorings Datei.\par
Also kommt in das TypeDictionary nur eine Auflistung der enum Konstanten rein, der ":"-Teil danach fliegt raus.\par
Dieser Teil war nicht viel Arbeit, vielleicht 1h. Den kommentier ich mal nur aus, denn wer wei\'df, wof\'fcr man (vereinfachte) Literals parsen darin zuk\'fcnftig mal brauchen kann.\par
\par
Rausmachen/auskommentieren.\par
\par
MemberDescription nach Kopieren und umbenennen anpassen.\par
MemberDefinition.\par
Logik daf\'fcr (Assembler, Creator).\par
\par
\'dcberlegen zu Validierung von enum Konstanten in nicht Enum typen: Sollte noch irgendwo validiert werden.\par
\par
\'dcberlegen zu \'c4ndern von enum zu nicht-enum Typ und umgekehrt von einer Version zur anderen.\par
Und Mapping der enum Konstanten dazwischen.\par
Solle kein Problem sein, denn:\par
Eine bestimmte Version eines Typs ist entweder eine enum oder nicht. So steht es im TypeDictionary und das ist fest "f\'fcr die Ewigkeit".\par
Wenn sich daran im Laufzeit Typ was \'e4ndert, ergibt das ja einen neuen Type Entry und auch der ist entweder enum oder nicht.\par
Enum Konstanteninstanzen werden per Refactoring Mapping von einem Konstantenfeld zum anderen gemappt, typ\'fcbergreifen. Das macht kein Problem.\par
Also insgesamt: alles kein Problem.\par
\par
hm... aber wie ist das: Wenn aus einem enum Typ ein nicht-enum-typ wird:\par
Die bisher existierenden Instanzen davon k\'f6nnen ja nur ausschlie\'dflich enum Instanzen sein.\par
Wenn der Typ nun ein nicht-enum ist, dann d\'fcrfen die existierenden enum Instanzen daf\'fcr doch gar nicht mehr auf irgendwelche neuen enums umgemappt werden, sondern dann m\'fcssen die enum Konstantenfelder einfach ungemappt sein und die persistent herumliegenden enum Instanzen sind dann einfach normale Instanzen, die referenziert werden k\'f6nnen oder auch nicht.\par
\par
Umgekehrt ... puh. Also wenn aus einem nicht-enum Typ auf einmal ein enum Typ wird.\par
Davon liegen ja beliebig viele Instanzen rum. Vielleicht zuf\'e4llig nur ein paar einzigartige, vielleicht auch Millionen mit beliebig viel Redundanzen zwischeneinander. Und alle davon unverankert.\par
Daraus kann man keine enum machen.\par
Oder sagen wir so: Der Typ is nun eine enum, definiert enum Konstanteninstanzen, die auch ordentlich verankert werden, alles super. Aber in der persistenten Form liegen noch beliebig viele "Schatteninstanzen" dieses enum Typs, die referenziert und geladen werden k\'f6nnen. Bzw beim Laden w\'fcrde es dann wohl eine Exception geben. Oder da m\'fcsst ich eine "grace" Logik machen, die bei nicht aufl\'f6sbarer enum Instanz trotzdem eine Instanz erzeugt. Oder ich werf eine Exception, aber diesen crazy special Sonderfall kann man dann per custom handler l\'f6sen.\par
\par
Ist schon wieder alles nicht so einfach ...l\par
\par
Das mit dem Validieren vom Punkt davor ist aber so eine Sache:\par
Ees wird angenommen, dass jeder Type Dictionary Eintrag korrekt ist, d.h. WAR zum Zeitpunkt, als er erstellt worden ist.\par
Wenn er nicht mehr passt (z.B. Typ mit gleichem Namen hat sich von enum zu nicht-enum ge\'e4ndert), dann ist das kein zu validierender Fehler, sondern ein Legacy Type Handling Thema.\par
Wenn also eine type definition f\'fcr einen enum type einen nicht-enum type als runtime type hat, dann ist das keine inkonsistenz, sondern n\'f6tige Daten f\'fcr den Typabgleich. Mismatches zwischen Typbeschreibung und Laufzeittyp m\'fcssen dann von der Mapping Logik aufgel\'f6st oder ggf. dann als Fehler angezeigt werden. Aber beim TypeDefinition instanzieren an sich kommt erst mal keine Validierung.\par
\par
Dann jetzt mal weitermachen mit der BinaryHandler generierung: enum Konstantenfelder per Reflection zusammensammeln.\par
\par
Ah, wenn jetzt Members f\'fcr static Felder dazukommen, sind ein paar \'c4nderungen n\'f6tig, wie die Member zur\'fcckgegeben werden. Aber soweit es momentan aussieht, sollte es reichen, in der einen Klasse die Methode zu \'fcberschreiben.\par
\par
Ne, nat\'fcrlich doch nicht, weil die members() Methode an 1000 Stellen verwendet wird, um die Instanz-Struktur zu vergleichen.\par
Dann folgende Idee:\par
- members umbenennen zu instanceMembers.\par
- Neue methode "allMembers" einf\'fchren, die dann instancemembers plus enum constant members enth\'e4lt.\par
- die primtive definition wird dann auch gleich so ge\'e4ndert, dass sie keine instanceMembers mehr zur\'fcckgibt.\par
\par
Dann muss in den member typ aber noch eine isInstanceField Methode rein.\par
\par
Witzig: Fr\'fcher hatte ich mal handling von statischen Feldern einer Klasse mit drin, aber habs dann rausgeworfen.\par
Jetzt kommt das - zumindest ganz begrenzt - doch wieder rein.\par
\par
Das allMembers Zeug zieht sich ziemlich weit durch das Projekt. Aber macht alles Sinn, so.\par
So, fertig.\par
\par
Jetzt Erweiterung dabei f\'fcr enums implementieren.\par
Fertig.\par
\par
Wie jetzt weiter?\par
Erst mal Lookup-Code f\'fcr die beiden java.lang.Enum Instanzfelder schreiben. Die braucht die update Methode f\'fcr die Validierung.\par
\par
\par
2019-07-31\par
\par
Zwei \'dcberlegungen:\par
1.) Der "normale" BinaryHandlerEnum macht kein Lookup und Mapping und Stuff. Daf\'fcr gibts LTM und wahrscheinlich dann einen extra LegacyEnumHandler, mal sehen.\par
\cf1\b 2.) Das ganze LTM Strukturvergleichszeug muss Enum Felder mit ber\'fccksichtigen, bzw. "all" statt "instance".\cf0\b0\par
3.) Der Reflective TypeHandler braucht eine Filtermethode f\'fcr "updatingFields", die normalerweise no-op ist, aber bei enums die beiden Enum Felder ausfiltert, sonst \'fcberschreibt der die in der Instanz.\par
\par
\par
#3 implementieren.\par
Dabei gleich mal den AbstractBinaryHandlerReflective Konstruktur aufr\'e4umen und das l\'e4stige TODO damit loswerden.\par
\par
Beim Testen kleinen Bug von gestern entdeckt: Primitive Definitions werden nicht mehr assembled. Schnell suchen und fixen.\par
Jup, Kleinigkeit.\par
\line Weiter im Text.\par
\par
Das mit dem Enum Felder rauswerfen zieht weitere Kreise:\par
Dann muss man auch unterscheiden zwischen allStoringBinaryOffsets und allSettingBinaryOffsets.\par
Und das dann wieder \'fcber eine Instanzmethode, damit die enum Implementierung das overriden kann, w\'e4hrend die default einfach zweimal dassselbe Array hernimmt, damit nicht noch mehr speicher von den eh schon ziemlich gro\'dfen Handlern belegt wird.\par
\par
Dann muss es auch zwei referenceOffsetStart geben...\par
\par
Ne, muss es nicht, weil die (aktuell) nur f\'fcr eine Variante gebraucht werden. Nur vorsichtshalber umbenennen.\par
\par
Baustelle aufr\'e4umen, alles bissl ordentlich machen und Kommentare schreiben.\par
\par
Damit w\'e4re die AbstractBinaryHandlerReflective Klasse fertig vorbereitet f\'fcr das enum special handling. Und ENDLICH mal aufger\'e4umt. Nach ... 6 Jahren ... .\par
\par
\par
2019-08-01\par
\par
BinaryHandlerEnum implementieren.\par
Binary Offsets m\'fcssen dynamisch festgestellt werden, weil unterschiedliche enum Typen unterschiedliche persistent form offsets haben k\'f6nnen.\par
\par
Hm. Eigentlich m\'fcsste der enum Name f\'fcr die Validierung im update() irrelevant sein. Denn:\par
- Ordinal kann validiert werden, damit ist die Instanz schon eindeutig definiert.\par
- Die JVM-erzeugte enum Instanz hat einen Name, der z\'e4hlt und der allein.\par
- Was im persistierten Datensatz als Namensstring verlinkt ist, ist -  zumindest zum Laden der sonstigen Daten in die enum Instanz - herzlich egal.\par
- Bei der Validierung der Roots Instanzen usw. zu Beginn ist das nochmal was anderes, aber das findet ja eben nicht im update() statt.\par
\par
Also update() Methode so bauen.\par
Hm, das ist eigentlich nur die ordinal Validierung und der Rest findet ja in der Superklasse statt. Nice. Dann ist das schon fertig.\par
\par
\par
\par
Uff! Per Zufall wichtigen Hinweis entdeckt.\par
Siehe Enum#getDeclaringClass.\par
Das wird ein riesiges Problem f\'fcr das Persistence TypeHandling. Klassen, die "eigentlich" eine andere Klasse sind, aber trotzdem als eigenst\'e4ndige Klasse gehandelt werden m\'fcssen, um special state darin richtig abzubilden.\par
Oder erst mal testen, ob man da \'fcberhaupt noch extra Felder reinpacken kann. Wenn nicht und das ganze nur eine Syntax Hackerei der JVM f\'fcr Methoden ist, dann kann ich das insgesamt ausklammern...\par
Wobei ich dann nirgends im TypeHandling mehr ".getClass()" aufrufen d\'fcrfte ... na mal sehen, was bei de Researcherei rauskommt.\par
\par
Ergebnis:\par
Ja, man kann in solche Enum-AICs nochmal Felder reinpacken und die normal verwenden.\par
Also das schlie\'df ich aus. Da gibts dann einfach eine not supported Exception.\par
99% aller Enums haben gar keinen State.\par
Und 99,99% aller Enums haben wenn \'fcberhaupt, dann nur nicht-crazy state. Die zwei F\'e4lle, wo einer crazy shit baut, muss man nicht supporten und da wirds auch Verst\'e4ndnis geben, dass so ein Mist nicht unterst\'fctzt wird.\par
Ich wette, das kann auch keine andere Persistierungsl\'f6sung.\par
\par
Die Frage ist jetzt nur: Wie schmei\'dft man die Klasse am einfachsten raus?\par
Es w\'e4re ja unproblematisch, eine MyEnum$1 Instanz ohne extra state als MyEnum Instanz abzuspeichern und beim laden dann die JVM-erzeugte MyEnum$1 Instanz mit dem MyEnum Datensatz zu bef\'fcllen.\par
Aber \'fcberall, wo .getClass() aufgerufen wird, m\'fcsste dann ein Specialcasing rein...\par
Vielleicht w\'e4re aber folgendes geschickter:\par
- Enum-AIC Felder werden ausgeschlossen, d.h. das Feld-Layout ist immer identisch zu der Enum selbst.\par
- Die Klasse wird einfach 1-zu-1 durchgeschleust.\par
- Die Instanzenzuordnung findet ja von der Enum "Hauptklasse" aus statt.\par
- Es gibt halt dann einen redundanten BinaryHandler mit anderer TypeId, aber der kriegt letztendlich die richtige Instanz zum updaten und die Struktur passt ja genau. Selbst, wenn sich codem\'e4\'dfig mal was \'e4ndern sollte.\par
\par
\par
Hm... f\'fcr das Felder ausfiltern nehm ich einfach den "problematic fields" Mechanismus f\'fcr die Collections her. Hehe.\par
\par
Oh, dabei gleich potenziellen Bug im Fall einer custom persistable Logik entdeckt:\par
f\'fcr handleable Collection Felder darf NICHT transient gepr\'fcft werden, denn das wird von der isPersistable Logik schon entschieden. Sollte da mal eine andere als der transient keyword check verwendet werden,\par
darf die collction special Logik nicht einfach trotzdem wieder transient checken. \'c4ndern und kommentieren.\par
Das gleiche gilt dann auch f\'fcr die Enum Feld Checks.\par
\par
Default Check in Persistence Klasse einbauen und kommentieren.\par
\par
Foundation entsprechend erweitern.\par
\par
Ok, dann h\'e4tt ich das schon mal.\par
\par
Jetzt noch checken, ob ich im BinaryHandlerEnum irgendwo sicherstellen muss, dass die "top level" enum Klasse anstatt der AIC verwendet wird.\par
Ne, sollte passen.\par
\par
Dann ... bau jetzt ich eine MainTest, w\'fcrd ich sagen.\par
\par
Testen ... oh, JVM Crash, noch vor irgendeinem Breakpoints.\par
Dump anschauen ...\par
\par
Ah, schnell gefunden: storing Offsets [16, 0] kann nicht stimmen f\'fcr die zwei Referenzen in EmptyTable. Da hab ich gestern irgendwas ruiniert. Seltsam, dass es gestern beim Testen geklappt hat. Evtl. danach ruiniert? Na mal schauen ...\par
Ah. Arrayindex nicht inkrementiert, lol.\par
[12, 16] sieht schon sehr viel sinnvoller aus als [16, 0].\par
\par
Testen ... und scho gehts.\par
\par
Wenn jetzt sogar noch die Enum Analyse Logik betreten werden w\'fcrde, w\'e4r das super...\par
Mal im Code schauen.\par
\par
Achja! Da wird ja auf den Generic umgeleitet, damit der JM seine Enums generisch speichern und inkonsistent laden kann.\par
FIXME und debugout hinmachen und auf testcode umstellen.\par
\par
Seltsam: CrazyEnum erzeugt keine Exception und wird nicht als enum gehandelt.\par
Untersuchen.\par
\par
OMFG: bei der Klasse gibt .isEnum() false zur\'fcck. Wie bl\'f6d kann man sein?\par
\par
Also korrekte Version implementierung und sorgf\'e4ltig dokumentieren.\par
Alle Vorkommen des kaputten Class#isEnum ersetzen durch XReflect#isEnum(Class).\par
\par
Test erweitern um persistierbare CrazyEnum mit transient Feld.\par
Benamungen verbessern.\par
\par
Da f\'e4llt mir auf:\par
Sobald das Typehandling der ersten neuen Enum begegnet, muss es ALLE enum Instanzen des Typs durchchecken, damit nicht "halb persistierte" enum Listen entstehen.\par
So ein Shit.\par
\par
Erst mal weiter testen.\par
\par
Und noch ein Sonderfall im Sonderfall: Felder in einem Crazy Shit Enum Subtype, die in Superklassen deklariert sind, m\'fcssen akzeptiert werden, die bilden ja die kompatible Struktur.\par
\par
Damit l\'e4uft das Storen durch, wie geplant.\par
Allerdings: Im Crazy Shit $1 Typ fehlden die Enum Konstanten. Die Frage ist jetzt, ob das so sein muss, oder ob das ein Fehler ist ... hm ...\par
\par
Und noch ein Problem: das $1 ist gef\'e4hrlich. \'c4ndert sich mal die Reihenfolge der Enums, zeit das $1 auf einmal auf eine andere Implementierung, d.h. potenziall andere Logik, aber $1 (alt) wird nat\'fcrlich trotzdem problemlos zu $1 (neu) aufgel\'f6st und schwups, hat die geladene Enum Instanz den falschen Typ.\par
\par
Wobei ... ne, denn:\par
1.) Das w\'e4re eine LTM Sache, die ich erst noch handeln muss.\par
2.) Es werden keine Enum Instanzen erzeugt, sondern die Datens\'e4tze nur anhand des Namens und der OID auf existierende Instanzen gemappt. Dann ist der Typ immer richtig.\par
Hm. Aber dann \'e4ndert sich ja ggf. der Typ, d.h. die TypeId im Datensatz passt nicht mehr zur TypeId des Handlers, obwohl es gar kein LTM gab.\par
\par
Man, ist das alles kompliziert ...\par
\par
Zeit f\'fcr Feierabend :-[\par
\par
\par
\par
2019-08-02\par
\par
Paar Einf\'e4lle von daheim:\par
\par
1.)\par
Die Enum crazy shit subtypes einfach so wie der Compiler sie benennt, also $1, $2, usw. abspeichern, w\'e4re fatal bzw. zumindest sehr ung\'fcnstig und verwirrend.\par
Sagen wir ordinal 0 ist eine "normale" Enum, ordinal 1 eine crazy shit enum.\par
Dann wird die Subklasse f\'fcr ordinal 1 als $1 generiert und auch dementsprechend abgespeichert.\par
\'c4ndert man nun das Programm, dass auch ordinal 0 so ein crazy shit type ist, dann wird auf einmal der ordinal 0 type die $1 und der ordinal 1 wird die $2.\par
F\'fcr die JVM spielt das keine Rolle. F\'fcr die beginnt bei jedem Start das Universum komplett von Neuem und was davor war, spielt keine Rolle mehr. Sowas wie fr\'fcher mal persistierte und sp\'e4ter wieder zu verkn\'fcpfende Typnamen kennt die JVM nicht, darum muss der Compiler darauf keine R\'fccksicht nehmen.\par
Mit MS gibt es das aber nun doch und der Versuch, $1 zu einem Runtime Type aufzul\'f6sen, ergibt nicht den - inzwischen - n\'f6tigen Typ $2, sondern nat\'fcrlich einfach die $1. Und schwups, hat die zweite Enum Konstante den crazy shit typ der ersten Enum Konstante. Das ist dann h\'f6chstwahrscheinlich ein Bug, denn wenn die Subtypen sich nicht unterscheiden w\'fcrden, w\'e4ren sie ja gleich nicht gemacht worden.\par
\par
L\'f6sung (leider):\par
Den Typnamen selber bauen.\par
Anstatt com.app.MyEnum$1 sowas wie com.app.MyEnum$:TYPE_A\par
\par
Die Class resolving Logik muss daf\'fcr ein klein bisschen aufgebohrt werden:\par
if contains "$:", dann erst mal das davor als Typ aufl\'f6sen und dann das danach als Identifier innerhalb dieses Typs aufl\'f6sen.\par
Wenn der Typ ein Enum ist, dann ist der Identifier ein Enum Konstantennamen.\par
Wenn der Typ kein Enum ist, dann Klasse und alle Membes darin mit eine modularen Reflection Funktion nach einem Persistence Identifier durchsuchen (typischerweise Annotation, aber das ist frei w\'e4hlbar).\par
Damit kann man dann n\'e4mlich auch gleich die Anonymous Inner Class Instances ordentlich identifizieren, die dieses Problem genauso haben.\par
\par
2.)\par
Aus #1 ... oder vielleicht sogar unabh\'e4ngig davon ... folgt auch eine andere Erkenntnis:\par
Den State der Crazy Shit Enum Subtypes kann man sehr wohl mitpersistieren. Wenn der Typ eh seinen eigenen handler bekommt und auf nur genau die richtige Instanz angewendet wird, dann spricht ja nichts dagegen, noch ein paar Felder mehr mitzunehmen.\par
\par
\par
Der erste Schritt f\'fcr die Implementierung ist, erst mal eine XReflect Methode zu schreiben, die die crazy SubTypes erkennt, damit man die Fallunterscheidung bauen kann.\par
Und dann gleich noch eine Methode, um immer die enum top-level Klasse zu holen. Das brauch ich dann, um bei der ersten Begegnung mit einer enum gleich alle Konstanteninstanzen durchzuanalysieren, damit Enumtypen nicht "halb" persistiert werden und die andere H\'e4lfte sp\'e4ter vielleicht mal eine Exception erzeugt.\par
\par
\par
\par
TODOS:\par
v XReflect Enum Subtyp Erkennungsmethode\par
v XReflect Methode zum holen der top-level Enum Klasse\par
v TODO: Alle RefactoringResolver umbenennen zu TypeDescriptionResolver.\par
v Explizit benannte Enum Subtypen\par
v Class Resolving um explizite Benamungen erweitern\par
- Bei Begegnung mit einem neuen Enum Typen gleich alle Enum Instanzen analysieren\par
- Bei Begegnung mit einem neuen Enum Typen persistence root erweitern um ein Array daf\'fcr\par
- Root Initialisierung um einen Abgleich mit den aktuellen JVM-generierten enum Konstanteninstanzen des Typs erweitern\par
- Und dann noch das ganze Thema Legacy Type Mapping f\'fcr \'c4nderungen an Enums.\par
- Das ganze LTM Strukturvergleichszeug muss Enum Felder mit ber\'fccksichtigen, bzw. "all" statt "instance".\par
(offene Punkte unten repliziert)\par
\par
... Nach einer Woche Enum Handling Implementierung ist es mehr Arbeit als zu Beginn. Aber daf\'fcr ist jetzt der Umfang klar, alles ist sauber l\'f6sbar und das Licht am Ende des Tunnels ist zu sehen.\par
\par
XReflect Erweiterungen gebaut.\par
\par
Jetzt expliziten Typename einbauen und durch alle beteiligten Konstruktoren ziehen.\par
\par
PersistenceTypeNameDeriver anlegen und in der Foundation verbandeln.\par
\par
Hm... oder Moment mal: Sollte PersistenceTypeNameDeriver und TypeResolver nicht zwangsweise dieselber Implementierung sein? Ansonsten k\'f6nnen die inkonsistent zueinander gesetzt werden, so dass der Resolver die Strings\par
des NameDerivers nicht erkennt...\par
Jup, mach ich so.\par
\par
PersistenceTypeResolver entsprechend erweitern und umbenennen zu PesistenceTypeNameMapper.\par
Hm. Das sind zwei Stufen beteiligt und f\'fcr beide Richtungen sehen die Methoden f\'fcr unterschiedliche Stufen so aus, als w\'e4ren sie Equivalente f\'fcr dieselbe Stufe, was falsch ist.\par
Beide ordentlich kommentieren, sonst verwirrt das zu sehr.\par
\par
Projektweit umbennen und nameDeriver wieder rausschmeissen.\par
\par
Aber das alles \'fcber den PersistenceRefactoringResolver laufen zu lassen ist unn\'f6tig kompliziert, namentlich verwirrend und evtl. sogar mal durch die Initialisierungsreihenfolge problematisch.\par
Also das eigentliche type<->name mapping als eigenes, kombiniertes Ding rausziehen. Dann sind auch gleich diese zwei Stufen sauber getrennt.\par
\par
Dann benenn ich das Ding doch wieder auf TypeResolver um, weil "TypeNameMapper" zu ... kurz gegriffen klingt.\par
\par
Irgendwie ist das beim TypeDictionaryBuilder ein bisschen wirr. Nur deswegen muss der TypeResolver einen Provider haben. Das ist alles bissl seltsam.\par
Au\'dferdem muss der nur wegen dem Builder eine resolve Methode f\'fcr TypeDescriptions haben.\par
Und letztendlich wird dem Builder ja doch gleich RefactoringResolver \'fcbergeben.\par
Alles wirr...\par
\par
\par
Ah, jetzt hab ichs:\par
PersistenceRefactoringResolver wird umbenannt zu PersistenceTypeDescriptionResolver\par
Und der wrappt einen simplen PersistenceTypeResolver.\par
Der TypeHandlerCreator verwendet dann nur den (selben) PersistenceTypeResolver, ohne PersistenceTypeDescriptionResolver drum rum.\par
So passts.\par
\par
Umsetzen. Fertig.\par
\par
Jetzt das Benamungszeug bauen: deriver Methode erweitern und resolver Methode analog.\par
Testen.\par
Geht.\par
\par
handleable Enum Logik drin lassen, aber body durch return true ersetzen.\par
Testen.\par
Passt.\par
\par
Okay, dann sollte das Enum Handling jetzt grunds\'e4tzlich passen. Fehlt nur noch:\par
\par
\cf1\b TODOS:\par
\b0 - Bei Begegnung mit einem neuen Enum Typen gleich alle Enum Instanzen analysieren\par
- Bei Begegnung mit einem neuen Enum Typen persistence root erweitern um ein Array daf\'fcr\par
- Root Initialisierung um einen Abgleich mit den aktuellen JVM-generierten enum Konstanteninstanzen des Typs erweitern\par
- Und dann noch das ganze Thema Legacy Type Mapping f\'fcr \'c4nderungen an Enums.\par
- Das ganze LTM Strukturvergleichszeug muss Enum Felder mit ber\'fccksichtigen, bzw. "all" statt "instance".\par
\cf0\par
\par
\par
2019-08-05\par
\par
Wieder mal eine Idee aus dem Wochenende:\par
Ich wollte das mit den Konzept Identifiern ja auch benutzen, um optional Anonymous Inner Classes eindeutig zu identifizieren.\par
Das ist ja aber nicht, weil es in der Class API keine M\'f6glichkeit gibt, alle member types zu iterieren.\par
Durchnummeriert benannte Klassennamen sind aber brandgef\'e4hrlich, weil sie nicht einfach nicht aufgel\'f6st werden, sondern potenziell falsch aufgel\'f6st werden, einfach nur dadurch, dass sich die Reihenfolge von Sourcecode Teilen \'e4ndert.\par
Darum folgende Idee:\par
\'c4hnlich dem Lambda Recognizer einen TypeNameMapper oder sowas machen.\par
Defaultm\'e4\'dfig reicht der alles unver\'e4ndert durch, nur bei $1 etc. Namen wirft er eine Exception mit einer detaillierten Erkl\'e4rung.\par
Hei\'dft: AICs sind dann nicht mehr persistierbar. Macht ja eigentlich auch keinen Sinn, wenn es um ein Entity Datenmodell geht.\par
Alles, was man mit AICs machen kann, kann man auch zu ordentlich benannten Klassen umformen und dann geht es. Z.B. Comparators definieren, wenn man die unbedingt mitpersistieren muss.\par
Falls doch jemand unbedingt AICs unordentlich persistieren will, kann er das "auf eigene Gefahr" machen, indem er den TypeNameMapper durch einen ersetzt, der ALLES einfach durchreicht, inklusive AICs.\par
Oder der sich irgendwie eine Implementierung schreibt, die die Dinger ordentlich aufl\'f6st.\par
Beispiel: Brute-force-m\'e4\'dfig alle $1... dynamisch durchiterieren, bis keine so benannte Klasse mehr gefunden werden kann und all diese Klassen dann durchanalysieren, welche von denen wohl zu der im Dictionary beschriebenen passt.\par
Das geht, k\'f6nnte ich auch gleich so machen, aber mal ehrlich:\par
AIC Instanzen persistieren wollen ist schon ein bisschen d\'e4mlich. Die sind technisch zwar Klassen mit Instanzen, aber logisch sind es eigentlich nur Logik-Bestandteile. Wer ordentlich handlebare Klassen will, soll in Gott's Namen einen Klassennamen dranschreiben.\par
\par
Bzw., nach einem kurzen Blick in den aktuellen Sourcecode muss das gar kein zus\'e4tzlicher Typ werden, sondern das macht der PersistenceTypeResolver gleich direkt mit. Das ist ja genau das Ding, das die Transformation Class <-> Classname durchf\'fchrt. Bzw. die tats\'e4chliche Fallunterscheidung kommt in  Persistence#derivePersistentTypeName rein, neben die f\'fcr enums. Passt.\par
\par
Implementiert und getestet. Passt.\par
Noch priv#23 updaten, priv#124 erstellen und verlinken. Fertig.\par
\par
\par
}
 