{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-07-26\par
\par
Also mal Brainstorming ...\par
\par
Die Konsistenz der enums muss gleich beim Typen Initialisieren bzw. sp\'e4testens beim roots laden \'fcberpr\'fcft werden.\par
Also m\'fcssen eigentlich alle enums als root Referenzen registriert werden.\par
Das hei\'dft nat\'fcrlich auch: Wenn zur Laufzeit ein neuer Enum Typ gesehen wird, muss die Roots Instanz aktualisiert werden.\par
Vielleicht w\'e4re es das beste, als enum root gleich das values array abzuspeichern, sonst hat man tausende root instanzen, alle per String identifiziert, die man erst wieder zusammengruppieren muss, usw.\par
Und am besten k\'f6nnte man als root String gleich die TypeId hernehmen ...\par
Oder vielleicht "enum:100053:com.MyApp.stuff.AppCategory".\par
Denn vielleicht muss mal noch was anderes in dieser type:name Form gespeichert werden.\par
Das Array dahinter wird geladen. Da stecken alle enum instanzen mit ordinal und name drin.\par
\'dcber die TypeId und ggf. den namen holt man sich die aktuelle Laufzeit enum Klasse und deren values.\par
Dann wird index f\'fcr index verglichen: ordinal gleich? Name gleich? Wenn ja, passt, wenn nein: mismatch.\par
Aber ne, Moment: dann ist es ja schon zu sp\'e4t. Das muss der RootResolver machen und wenn alles passt, gleich die JVM-erzeugten enum Konstanten mit den TypeIds assoziieren. Hm, knifflig.\par
\par
Keine Thema f\'fcr Freitag 16:30 mit 29,8\'b0 im B\'fcro.\par
Ende f\'fcr Heute.\par
\par
\par
2019-07-29\par
\par
Ein paar Konzept\'fcberlegungen vom Wochenende:\par
\par
1.)\par
Der Root Eintrag darf nicht den Typnamen enthalten. Muss er auch gar nicht, es reicht die TypeId.\par
Also sowas: "enum 100097".\par
Damit ist klar: es ist eine enum und der eigentliche Typename kann \'fcber das Dictionary aufgel\'f6st werden.\par
\par
2.)\par
es spricht eigentlich nichts dagegen, die Namen (genauer: Identfikation) und Reihenfolge der enum Konstanten direkt in der TypeDescription zu hinterlegen.\par
Ein einfachsten Fall genauso wie in Java:\par
MINOR,\par
MAJOR,\par
CRITICAL,\par
\par
Optional muss man noch ein Identit\'e4tsmapping angeben k\'f6nnen, das w\'e4re dann das '@PersistenceId("Priority1")' aus dem Issue.\par
Also so:\par
MINOR:"Priority1",\par
MAJOR:"Priority1.5",\par
CRITICAL:"Priority2",\par
\par
\par
Der zweite String w\'e4re dann die Zuordnung im Runtime Type.\par
Falls so eine Annotation vorhanden ist, dann z\'e4hlt die, ansonsten wird es als Feldname interpretiert. Damit man z.B. auch schreiben kann:\par
MAJOR:CRITICAL\par
\par
Also was bisher in der persistenten Form die Instanz "MAJOR" ist, soll in der aktuellen Runtime Form zu der Instanz "CRITICAL" aufgel\'f6st werden.\par
\par
Damit kann genau abgeglichen werden, dass alle bisher existierenden Eintr\'e4ge in die Laufzeit gemappt werden k\'f6nnen:\par
- Fehlt die zweite Angabe, muss es den Namen genau so in der aktuellen Runtime Definitions des enums auch geben.\par
- Ist die zweite Angabe da, wird daraufhin umgemappt. Alle effektiven Identifier (Einzelangaben und zweite Angabe von Doppelangaben) m\'fcssen eindeutig sein.\par
(D.h. es k\'f6nnen nicht zwei bisherige enum Instanzen auf eine konsolidiert werden. Denn es werden hier keine OID umgeschrieben, sondern OID zu Instanzen aufgel\'f6st. 2 OIDs m\'fcssen 2 Instanzen ergeben)\par
- In der aktuellen Runtime definition \'fcberz\'e4hlige Instanzen sind kein Problem. Die kommen einfach dazu (siehe unten).\par
- Es muss auch eine M\'f6glichkeit geben, in der persistenten Form bestehende enum Instanzen explizit zu "l\'f6schen". Beim Laden wird dann stattdessen null zur\'fcckgegeben. Das ist konsistent mit der expliziten Vorgabe.\par
\par
\par
Unter der OID des Root Eintrags wird immer ein Object[] abgespeichert (NICHT ein Array des enum types, sondern spezifisch Object[]!), in dem alle enum Konstanten in Reihenfolge aufgelistet sind.\par
Beim Typen Validieren wird ja schon ein Abgleich vorgenommen und das Mapping, falls es keine Exception gibt, vorgehalten.\par
Beim Roots laden wird dann dieses mapping mit dem Inhalt des Array abgeglichen: Stimmt es genau \'fcberein (Namen und Reihenfolge!), dann wird weiter nichts gemacht.\par
Ansonsten wird ein neues Object[] mit der neuen Reihenfolge erstellt.\par
\par
Ein bisschen knifflig wird noch, an welcher Stelle OID und JVM-erzeugte Konstanteninstanzen miteinander assoziiert werden, so dass es nicht "zu sp\'e4t" (Registrierung in der ObjectID) ist.\par
Das musste im create des enum handlers sein.\par
\par
Die Frage ist noch, welche "Reihenfolge":\par
Bisherige Typdefinition oder aktuell gemappte.\par
Eigentlich muss es die aktuell gemappte sein, weil ja \'c4nderungen (z.B. neue Konstanteninstanzen) hier schon ber\'fccksichtigt werden m\'fcssen, damit der Abgleich eine korrekte, aktuelle Form ergibt.\par
\par
Und die Frage ist noch: Wie bekommt diese Stelle (also wahrscheinlich die BinaryHandlerEnum Instanz) die Referenz auf dieses Mapping her? Referenz auf diese \par
\par
Soweit die bisherigen \'dcberlegungen am Wochenende. Das sollte so funktionieren.\par
\par
\par
Dann mal als ersten Schritt den TypeDictionary Parser erweitern ...\par
\par
Hm. Dabei gleich Parserlogik umstellen von bound-ignoranz auf ordentliches iStart/iBound Konzept.\par
Das TODO dazu ist 6 Jahre alt :D. Wie die Zeit vergeht... Ich hab das immer noch als "Achja, da m\'fcsste ich demn\'e4chst mal den Parser verbessern" im Kopf.  6 jahre ...\par
\par
Parserverbesserung fertig.\par
Parsererweiterung f\'fcr enum fertig.\par
Den neuen Membertype daf\'fcr muss ich morgen noch fertig bauen.\par
\par
\par
2019-07-30\par
\par
Wieder \'dcberlegung von daheim:\par
In das Type Dictionary kommt kein Mapping rein. Sonst m\'fcsste man da ja doch manuell reinfassen und sonst m\'fcsste man bei jeder Typ\'e4nderung (neue Typversion) alle alten Typen nachbessern.\par
F\'fcr das alles gibt es die Refactorings Datei.\par
Also kommt in das TypeDictionary nur eine Auflistung der enum Konstanten rein, der ":"-Teil danach fliegt raus.\par
Dieser Teil war nicht viel Arbeit, vielleicht 1h. Den kommentier ich mal nur aus, denn wer wei\'df, wof\'fcr man (vereinfachte) Literals parsen darin zuk\'fcnftig mal brauchen kann.\par
\par
Rausmachen/auskommentieren.\par
\par
MemberDescription nach Kopieren und umbenennen anpassen.\par
MemberDefinition.\par
Logik daf\'fcr (Assembler, Creator).\par
\par
\'dcberlegen zu Validierung von enum Konstanten in nicht Enum typen: Sollte noch irgendwo validiert werden.\par
\par
\'dcberlegen zu \'c4ndern von enum zu nicht-enum Typ und umgekehrt von einer Version zur anderen.\par
Und Mapping der enum Konstanten dazwischen.\par
Solle kein Problem sein, denn:\par
Eine bestimmte Version eines Typs ist entweder eine enum oder nicht. So steht es im TypeDictionary und das ist fest "f\'fcr die Ewigkeit".\par
Wenn sich daran im Laufzeit Typ was \'e4ndert, ergibt das ja einen neuen Type Entry und auch der ist entweder enum oder nicht.\par
Enum Konstanteninstanzen werden per Refactoring Mapping von einem Konstantenfeld zum anderen gemappt, typ\'fcbergreifen. Das macht kein Problem.\par
Also insgesamt: alles kein Problem.\par
\par
hm... aber wie ist das: Wenn aus einem enum Typ ein nicht-enum-typ wird:\par
Die bisher existierenden Instanzen davon k\'f6nnen ja nur ausschlie\'dflich enum Instanzen sein.\par
Wenn der Typ nun ein nicht-enum ist, dann d\'fcrfen die existierenden enum Instanzen daf\'fcr doch gar nicht mehr auf irgendwelche neuen enums umgemappt werden, sondern dann m\'fcssen die enum Konstantenfelder einfach ungemappt sein und die persistent herumliegenden enum Instanzen sind dann einfach normale Instanzen, die referenziert werden k\'f6nnen oder auch nicht.\par
\par
Umgekehrt ... puh. Also wenn aus einem nicht-enum Typ auf einmal ein enum Typ wird.\par
Davon liegen ja beliebig viele Instanzen rum. Vielleicht zuf\'e4llig nur ein paar einzigartige, vielleicht auch Millionen mit beliebig viel Redundanzen zwischeneinander. Und alle davon unverankert.\par
Daraus kann man keine enum machen.\par
Oder sagen wir so: Der Typ is nun eine enum, definiert enum Konstanteninstanzen, die auch ordentlich verankert werden, alles super. Aber in der persistenten Form liegen noch beliebig viele "Schatteninstanzen" dieses enum Typs, die referenziert und geladen werden k\'f6nnen. Bzw beim Laden w\'fcrde es dann wohl eine Exception geben. Oder da m\'fcsst ich eine "grace" Logik machen, die bei nicht aufl\'f6sbarer enum Instanz trotzdem eine Instanz erzeugt. Oder ich werf eine Exception, aber diesen crazy special Sonderfall kann man dann per custom handler l\'f6sen.\par
\par
Ist schon wieder alles nicht so einfach ...l\par
\par
Das mit dem Validieren vom Punkt davor ist aber so eine Sache:\par
Ees wird angenommen, dass jeder Type Dictionary Eintrag korrekt ist, d.h. WAR zum Zeitpunkt, als er erstellt worden ist.\par
Wenn er nicht mehr passt (z.B. Typ mit gleichem Namen hat sich von enum zu nicht-enum ge\'e4ndert), dann ist das kein zu validierender Fehler, sondern ein Legacy Type Handling Thema.\par
Wenn also eine type definition f\'fcr einen enum type einen nicht-enum type als runtime type hat, dann ist das keine inkonsistenz, sondern n\'f6tige Daten f\'fcr den Typabgleich. Mismatches zwischen Typbeschreibung und Laufzeittyp m\'fcssen dann von der Mapping Logik aufgel\'f6st oder ggf. dann als Fehler angezeigt werden. Aber beim TypeDefinition instanzieren an sich kommt erst mal keine Validierung.\par
\par
Dann jetzt mal weitermachen mit der BinaryHandler generierung: enum Konstantenfelder per Reflection zusammensammeln.\par
\par
Ah, wenn jetzt Members f\'fcr static Felder dazukommen, sind ein paar \'c4nderungen n\'f6tig, wie die Member zur\'fcckgegeben werden. Aber soweit es momentan aussieht, sollte es reichen, in der einen Klasse die Methode zu \'fcberschreiben.\par
\par
Ne, nat\'fcrlich doch nicht, weil die members() Methode an 1000 Stellen verwendet wird, um die Instanz-Struktur zu vergleichen.\par
Dann folgende Idee:\par
- members umbenennen zu instanceMembers.\par
- Neue methode "allMembers" einf\'fchren, die dann instancemembers plus enum constant members enth\'e4lt.\par
- die primtive definition wird dann auch gleich so ge\'e4ndert, dass sie keine instanceMembers mehr zur\'fcckgibt.\par
\par
Dann muss in den member typ aber noch eine isInstanceField Methode rein.\par
\par
Witzig: Fr\'fcher hatte ich mal handling von statischen Feldern einer Klasse mit drin, aber habs dann rausgeworfen.\par
Jetzt kommt das - zumindest ganz begrenzt - doch wieder rein.\par
\par
Das allMembers Zeug zieht sich ziemlich weit durch das Projekt. Aber macht alles Sinn, so.\par
So, fertig.\par
\par
Jetzt Erweiterung dabei f\'fcr enums implementieren.\par
Fertig.\par
\par
Wie jetzt weiter?\par
Erst mal Lookup-Code f\'fcr die beiden java.lang.Enum Instanzfelder schreiben. Die braucht die update Methode f\'fcr die Validierung.\par
\par
\par
2019-07-31\par
\par
Zwei \'dcberlegungen:\par
1.) Der "normale" BinaryHandlerEnum macht kein Lookup und Mapping und Stuff. Daf\'fcr gibts LTM und wahrscheinlich dann einen extra LegacyEnumHandler, mal sehen.\par
\cf1\b 2.) Das ganze LTM Strukturvergleichszeug muss Enum Felder mit ber\'fccksichtigen, bzw. "all" statt "instance".\cf0\b0\par
3.) Der Reflective TypeHandler braucht eine Filtermethode f\'fcr "updatingFields", die normalerweise no-op ist, aber bei enums die beiden Enum Felder ausfiltert, sonst \'fcberschreibt der die in der Instanz.\par
\par
\par
#3 implementieren.\par
Dabei gleich mal den AbstractBinaryHandlerReflective Konstruktur aufr\'e4umen und das l\'e4stige TODO damit loswerden.\par
\par
Beim Testen kleinen Bug von gestern entdeckt: Primitive Definitions werden nicht mehr assembled. Schnell suchen und fixen.\par
Jup, Kleinigkeit.\par
\line Weiter im Text.\par
\par
Das mit dem Enum Felder rauswerfen zieht weitere Kreise:\par
Dann muss man auch unterscheiden zwischen allStoringBinaryOffsets und allSettingBinaryOffsets.\par
Und das dann wieder \'fcber eine Instanzmethode, damit die enum Implementierung das overriden kann, w\'e4hrend die default einfach zweimal dassselbe Array hernimmt, damit nicht noch mehr speicher von den eh schon ziemlich gro\'dfen Handlern belegt wird.\par
\par
Dann muss es auch zwei referenceOffsetStart geben...\par
}
 