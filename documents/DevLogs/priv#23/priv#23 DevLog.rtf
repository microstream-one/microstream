{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 2019-07-26\par
\par
Also mal Brainstorming ...\par
\par
Die Konsistenz der enums muss gleich beim Typen Initialisieren bzw. sp\'e4testens beim roots laden \'fcberpr\'fcft werden.\par
Also m\'fcssen eigentlich alle enums als root Referenzen registriert werden.\par
Das hei\'dft nat\'fcrlich auch: Wenn zur Laufzeit ein neuer Enum Typ gesehen wird, muss die Roots Instanz aktualisiert werden.\par
Vielleicht w\'e4re es das beste, als enum root gleich das values array abzuspeichern, sonst hat man tausende root instanzen, alle per String identifiziert, die man erst wieder zusammengruppieren muss, usw.\par
Und am besten k\'f6nnte man als root String gleich die TypeId hernehmen ...\par
Oder vielleicht "enum:100053:com.MyApp.stuff.AppCategory".\par
Denn vielleicht muss mal noch was anderes in dieser type:name Form gespeichert werden.\par
Das Array dahinter wird geladen. Da stecken alle enum instanzen mit ordinal und name drin.\par
\'dcber die TypeId und ggf. den namen holt man sich die aktuelle Laufzeit enum Klasse und deren values.\par
Dann wird index f\'fcr index verglichen: ordinal gleich? Name gleich? Wenn ja, passt, wenn nein: mismatch.\par
Aber ne, Moment: dann ist es ja schon zu sp\'e4t. Das muss der RootResolver machen und wenn alles passt, gleich die JVM-erzeugten enum Konstanten mit den TypeIds assoziieren. Hm, knifflig.\par
\par
Keine Thema f\'fcr Freitag 16:30 mit 29,8\'b0 im B\'fcro.\par
Ende f\'fcr Heute.\par
\par
\par
2019-07-29\par
\par
Ein paar Konzept\'fcberlegungen vom Wochenende:\par
\par
1.)\par
Der Root Eintrag darf nicht den Typnamen enthalten. Muss er auch gar nicht, es reicht die TypeId.\par
Also sowas: "enum 100097".\par
Damit ist klar: es ist eine enum und der eigentliche Typename kann \'fcber das Dictionary aufgel\'f6st werden.\par
\par
2.)\par
es spricht eigentlich nichts dagegen, die Namen (genauer: Identfikation) und Reihenfolge der enum Konstanten direkt in der TypeDescription zu hinterlegen.\par
Ein einfachsten Fall genauso wie in Java:\par
MINOR,\par
MAJOR,\par
CRITICAL,\par
\par
Optional muss man noch ein Identit\'e4tsmapping angeben k\'f6nnen, das w\'e4re dann das '@PersistenceId("Priority1")' aus dem Issue.\par
Also so:\par
MINOR:"Priority1",\par
MAJOR:"Priority1.5",\par
CRITICAL:"Priority2",\par
\par
\par
Der zweite String w\'e4re dann die Zuordnung im Runtime Type.\par
Falls so eine Annotation vorhanden ist, dann z\'e4hlt die, ansonsten wird es als Feldname interpretiert. Damit man z.B. auch schreiben kann:\par
MAJOR:CRITICAL\par
\par
Also was bisher in der persistenten Form die Instanz "MAJOR" ist, soll in der aktuellen Runtime Form zu der Instanz "CRITICAL" aufgel\'f6st werden.\par
\par
Damit kann genau abgeglichen werden, dass alle bisher existierenden Eintr\'e4ge in die Laufzeit gemappt werden k\'f6nnen:\par
- Fehlt die zweite Angabe, muss es den Namen genau so in der aktuellen Runtime Definitions des enums auch geben.\par
- Ist die zweite Angabe da, wird daraufhin umgemappt. Alle effektiven Identifier (Einzelangaben und zweite Angabe von Doppelangaben) m\'fcssen eindeutig sein.\par
(D.h. es k\'f6nnen nicht zwei bisherige enum Instanzen auf eine konsolidiert werden. Denn es werden hier keine OID umgeschrieben, sondern OID zu Instanzen aufgel\'f6st. 2 OIDs m\'fcssen 2 Instanzen ergeben)\par
- In der aktuellen Runtime definition \'fcberz\'e4hlige Instanzen sind kein Problem. Die kommen einfach dazu (siehe unten).\par
- Es muss auch eine M\'f6glichkeit geben, in der persistenten Form bestehende enum Instanzen explizit zu "l\'f6schen". Beim Laden wird dann stattdessen null zur\'fcckgegeben. Das ist konsistent mit der expliziten Vorgabe.\par
\par
\par
Unter der OID des Root Eintrags wird immer ein Object[] abgespeichert (NICHT ein Array des enum types, sondern spezifisch Object[]!), in dem alle enum Konstanten in Reihenfolge aufgelistet sind.\par
Beim Typen Validieren wird ja schon ein Abgleich vorgenommen und das Mapping, falls es keine Exception gibt, vorgehalten.\par
Beim Roots laden wird dann dieses mapping mit dem Inhalt des Array abgeglichen: Stimmt es genau \'fcberein (Namen und Reihenfolge!), dann wird weiter nichts gemacht.\par
Ansonsten wird ein neues Object[] mit der neuen Reihenfolge erstellt.\par
\par
Ein bisschen knifflig wird noch, an welcher Stelle OID und JVM-erzeugte Konstanteninstanzen miteinander assoziiert werden, so dass es nicht "zu sp\'e4t" (Registrierung in der ObjectID) ist.\par
Das musste im create des enum handlers sein.\par
\par
Die Frage ist noch, welche "Reihenfolge":\par
Bisherige Typdefinition oder aktuell gemappte.\par
Eigentlich muss es die aktuell gemappte sein, weil ja \'c4nderungen (z.B. neue Konstanteninstanzen) hier schon ber\'fccksichtigt werden m\'fcssen, damit der Abgleich eine korrekte, aktuelle Form ergibt.\par
\par
Und die Frage ist noch: Wie bekommt diese Stelle (also wahrscheinlich die BinaryHandlerEnum Instanz) die Referenz auf dieses Mapping her? Referenz auf diese \par
\par
Soweit die bisherigen \'dcberlegungen am Wochenende. Das sollte so funktionieren.\par
\par
\par
Dann mal als ersten Schritt den TypeDictionary Parser erweitern ...\par
\par
Hm. Dabei gleich Parserlogik umstellen von bound-ignoranz auf ordentliches iStart/iBound Konzept.\par
Das TODO dazu ist 6 Jahre alt :D. Wie die Zeit vergeht... Ich hab das immer noch als "Achja, da m\'fcsste ich demn\'e4chst mal den Parser verbessern" im Kopf.  6 jahre ...\par
\par
Parserverbesserung fertig.\par
Parsererweiterung f\'fcr enum fertig.\par
Den neuen Membertype daf\'fcr muss ich morgen noch fertig bauen.\par
\par
\par
2019-07-30\par
\par
Wieder \'dcberlegung von daheim:\par
In das Type Dictionary kommt kein Mapping rein. Sonst m\'fcsste man da ja doch manuell reinfassen und sonst m\'fcsste man bei jeder Typ\'e4nderung (neue Typversion) alle alten Typen nachbessern.\par
F\'fcr das alles gibt es die Refactorings Datei.\par
Also kommt in das TypeDictionary nur eine Auflistung der enum Konstanten rein, der ":"-Teil danach fliegt raus.\par
Dieser Teil war nicht viel Arbeit, vielleicht 1h. Den kommentier ich mal nur aus, denn wer wei\'df, wof\'fcr man (vereinfachte) Literals parsen darin zuk\'fcnftig mal brauchen kann.\par
\par
Rausmachen/auskommentieren.\par
\par
MemberDescription nach Kopieren und umbenennen anpassen.\par
MemberDefinition.\par
Logik daf\'fcr (Assembler, Creator).\par
\par
\'dcberlegen zu Validierung von enum Konstanten in nicht Enum typen: Sollte noch irgendwo validiert werden.\par
\par
\'dcberlegen zu \'c4ndern von enum zu nicht-enum Typ und umgekehrt von einer Version zur anderen.\par
Und Mapping der enum Konstanten dazwischen.\par
Solle kein Problem sein, denn:\par
Eine bestimmte Version eines Typs ist entweder eine enum oder nicht. So steht es im TypeDictionary und das ist fest "f\'fcr die Ewigkeit".\par
Wenn sich daran im Laufzeit Typ was \'e4ndert, ergibt das ja einen neuen Type Entry und auch der ist entweder enum oder nicht.\par
Enum Konstanteninstanzen werden per Refactoring Mapping von einem Konstantenfeld zum anderen gemappt, typ\'fcbergreifen. Das macht kein Problem.\par
Also insgesamt: alles kein Problem.\par
\par
hm... aber wie ist das: Wenn aus einem enum Typ ein nicht-enum-typ wird:\par
Die bisher existierenden Instanzen davon k\'f6nnen ja nur ausschlie\'dflich enum Instanzen sein.\par
Wenn der Typ nun ein nicht-enum ist, dann d\'fcrfen die existierenden enum Instanzen daf\'fcr doch gar nicht mehr auf irgendwelche neuen enums umgemappt werden, sondern dann m\'fcssen die enum Konstantenfelder einfach ungemappt sein und die persistent herumliegenden enum Instanzen sind dann einfach normale Instanzen, die referenziert werden k\'f6nnen oder auch nicht.\par
\par
Umgekehrt ... puh. Also wenn aus einem nicht-enum Typ auf einmal ein enum Typ wird.\par
Davon liegen ja beliebig viele Instanzen rum. Vielleicht zuf\'e4llig nur ein paar einzigartige, vielleicht auch Millionen mit beliebig viel Redundanzen zwischeneinander. Und alle davon unverankert.\par
Daraus kann man keine enum machen.\par
Oder sagen wir so: Der Typ is nun eine enum, definiert enum Konstanteninstanzen, die auch ordentlich verankert werden, alles super. Aber in der persistenten Form liegen noch beliebig viele "Schatteninstanzen" dieses enum Typs, die referenziert und geladen werden k\'f6nnen. Bzw beim Laden w\'fcrde es dann wohl eine Exception geben. Oder da m\'fcsst ich eine "grace" Logik machen, die bei nicht aufl\'f6sbarer enum Instanz trotzdem eine Instanz erzeugt. Oder ich werf eine Exception, aber diesen crazy special Sonderfall kann man dann per custom handler l\'f6sen.\par
\par
Ist schon wieder alles nicht so einfach ...l\par
\par
Das mit dem Validieren vom Punkt davor ist aber so eine Sache:\par
Ees wird angenommen, dass jeder Type Dictionary Eintrag korrekt ist, d.h. WAR zum Zeitpunkt, als er erstellt worden ist.\par
Wenn er nicht mehr passt (z.B. Typ mit gleichem Namen hat sich von enum zu nicht-enum ge\'e4ndert), dann ist das kein zu validierender Fehler, sondern ein Legacy Type Handling Thema.\par
Wenn also eine type definition f\'fcr einen enum type einen nicht-enum type als runtime type hat, dann ist das keine inkonsistenz, sondern n\'f6tige Daten f\'fcr den Typabgleich. Mismatches zwischen Typbeschreibung und Laufzeittyp m\'fcssen dann von der Mapping Logik aufgel\'f6st oder ggf. dann als Fehler angezeigt werden. Aber beim TypeDefinition instanzieren an sich kommt erst mal keine Validierung.\par
\par
Dann jetzt mal weitermachen mit der BinaryHandler generierung: enum Konstantenfelder per Reflection zusammensammeln.\par
\par
Ah, wenn jetzt Members f\'fcr static Felder dazukommen, sind ein paar \'c4nderungen n\'f6tig, wie die Member zur\'fcckgegeben werden. Aber soweit es momentan aussieht, sollte es reichen, in der einen Klasse die Methode zu \'fcberschreiben.\par
\par
Ne, nat\'fcrlich doch nicht, weil die members() Methode an 1000 Stellen verwendet wird, um die Instanz-Struktur zu vergleichen.\par
Dann folgende Idee:\par
- members umbenennen zu instanceMembers.\par
- Neue methode "allMembers" einf\'fchren, die dann instancemembers plus enum constant members enth\'e4lt.\par
- die primtive definition wird dann auch gleich so ge\'e4ndert, dass sie keine instanceMembers mehr zur\'fcckgibt.\par
\par
Dann muss in den member typ aber noch eine isInstanceField Methode rein.\par
\par
Witzig: Fr\'fcher hatte ich mal handling von statischen Feldern einer Klasse mit drin, aber habs dann rausgeworfen.\par
Jetzt kommt das - zumindest ganz begrenzt - doch wieder rein.\par
\par
Das allMembers Zeug zieht sich ziemlich weit durch das Projekt. Aber macht alles Sinn, so.\par
So, fertig.\par
\par
Jetzt Erweiterung dabei f\'fcr enums implementieren.\par
Fertig.\par
\par
Wie jetzt weiter?\par
Erst mal Lookup-Code f\'fcr die beiden java.lang.Enum Instanzfelder schreiben. Die braucht die update Methode f\'fcr die Validierung.\par
\par
\par
2019-07-31\par
\par
Zwei \'dcberlegungen:\par
1.) Der "normale" BinaryHandlerEnum macht kein Lookup und Mapping und Stuff. Daf\'fcr gibts LTM und wahrscheinlich dann einen extra LegacyEnumHandler, mal sehen.\par
\cf1\b 2.) Das ganze LTM Strukturvergleichszeug muss Enum Felder mit ber\'fccksichtigen, bzw. "all" statt "instance".\cf0\b0\par
3.) Der Reflective TypeHandler braucht eine Filtermethode f\'fcr "updatingFields", die normalerweise no-op ist, aber bei enums die beiden Enum Felder ausfiltert, sonst \'fcberschreibt der die in der Instanz.\par
\par
\par
#3 implementieren.\par
Dabei gleich mal den AbstractBinaryHandlerReflective Konstruktur aufr\'e4umen und das l\'e4stige TODO damit loswerden.\par
\par
Beim Testen kleinen Bug von gestern entdeckt: Primitive Definitions werden nicht mehr assembled. Schnell suchen und fixen.\par
Jup, Kleinigkeit.\par
\line Weiter im Text.\par
\par
Das mit dem Enum Felder rauswerfen zieht weitere Kreise:\par
Dann muss man auch unterscheiden zwischen allStoringBinaryOffsets und allSettingBinaryOffsets.\par
Und das dann wieder \'fcber eine Instanzmethode, damit die enum Implementierung das overriden kann, w\'e4hrend die default einfach zweimal dassselbe Array hernimmt, damit nicht noch mehr speicher von den eh schon ziemlich gro\'dfen Handlern belegt wird.\par
\par
Dann muss es auch zwei referenceOffsetStart geben...\par
\par
Ne, muss es nicht, weil die (aktuell) nur f\'fcr eine Variante gebraucht werden. Nur vorsichtshalber umbenennen.\par
\par
Baustelle aufr\'e4umen, alles bissl ordentlich machen und Kommentare schreiben.\par
\par
Damit w\'e4re die AbstractBinaryHandlerReflective Klasse fertig vorbereitet f\'fcr das enum special handling. Und ENDLICH mal aufger\'e4umt. Nach ... 6 Jahren ... .\par
\par
\par
2019-08-01\par
\par
BinaryHandlerEnum implementieren.\par
Binary Offsets m\'fcssen dynamisch festgestellt werden, weil unterschiedliche enum Typen unterschiedliche persistent form offsets haben k\'f6nnen.\par
\par
Hm. Eigentlich m\'fcsste der enum Name f\'fcr die Validierung im update() irrelevant sein. Denn:\par
- Ordinal kann validiert werden, damit ist die Instanz schon eindeutig definiert.\par
- Die JVM-erzeugte enum Instanz hat einen Name, der z\'e4hlt und der allein.\par
- Was im persistierten Datensatz als Namensstring verlinkt ist, ist -  zumindest zum Laden der sonstigen Daten in die enum Instanz - herzlich egal.\par
- Bei der Validierung der Roots Instanzen usw. zu Beginn ist das nochmal was anderes, aber das findet ja eben nicht im update() statt.\par
\par
Also update() Methode so bauen.\par
Hm, das ist eigentlich nur die ordinal Validierung und der Rest findet ja in der Superklasse statt. Nice. Dann ist das schon fertig.\par
\par
\par
\par
Uff! Per Zufall wichtigen Hinweis entdeckt.\par
Siehe Enum#getDeclaringClass.\par
Das wird ein riesiges Problem f\'fcr das Persistence TypeHandling. Klassen, die "eigentlich" eine andere Klasse sind, aber trotzdem als eigenst\'e4ndige Klasse gehandelt werden m\'fcssen, um special state darin richtig abzubilden.\par
Oder erst mal testen, ob man da \'fcberhaupt noch extra Felder reinpacken kann. Wenn nicht und das ganze nur eine Syntax Hackerei der JVM f\'fcr Methoden ist, dann kann ich das insgesamt ausklammern...\par
Wobei ich dann nirgends im TypeHandling mehr ".getClass()" aufrufen d\'fcrfte ... na mal sehen, was bei de Researcherei rauskommt.\par
\par
Ergebnis:\par
Ja, man kann in solche Enum-AICs nochmal Felder reinpacken und die normal verwenden.\par
Also das schlie\'df ich aus. Da gibts dann einfach eine not supported Exception.\par
99% aller Enums haben gar keinen State.\par
Und 99,99% aller Enums haben wenn \'fcberhaupt, dann nur nicht-crazy state. Die zwei F\'e4lle, wo einer crazy shit baut, muss man nicht supporten und da wirds auch Verst\'e4ndnis geben, dass so ein Mist nicht unterst\'fctzt wird.\par
Ich wette, das kann auch keine andere Persistierungsl\'f6sung.\par
\par
Die Frage ist jetzt nur: Wie schmei\'dft man die Klasse am einfachsten raus?\par
Es w\'e4re ja unproblematisch, eine MyEnum$1 Instanz ohne extra state als MyEnum Instanz abzuspeichern und beim laden dann die JVM-erzeugte MyEnum$1 Instanz mit dem MyEnum Datensatz zu bef\'fcllen.\par
Aber \'fcberall, wo .getClass() aufgerufen wird, m\'fcsste dann ein Specialcasing rein...\par
Vielleicht w\'e4re aber folgendes geschickter:\par
- Enum-AIC Felder werden ausgeschlossen, d.h. das Feld-Layout ist immer identisch zu der Enum selbst.\par
- Die Klasse wird einfach 1-zu-1 durchgeschleust.\par
- Die Instanzenzuordnung findet ja von der Enum "Hauptklasse" aus statt.\par
- Es gibt halt dann einen redundanten BinaryHandler mit anderer TypeId, aber der kriegt letztendlich die richtige Instanz zum updaten und die Struktur passt ja genau. Selbst, wenn sich codem\'e4\'dfig mal was \'e4ndern sollte.\par
\par
\par
Hm... f\'fcr das Felder ausfiltern nehm ich einfach den "problematic fields" Mechanismus f\'fcr die Collections her. Hehe.\par
\par
Oh, dabei gleich potenziellen Bug im Fall einer custom persistable Logik entdeckt:\par
f\'fcr handleable Collection Felder darf NICHT transient gepr\'fcft werden, denn das wird von der isPersistable Logik schon entschieden. Sollte da mal eine andere als der transient keyword check verwendet werden,\par
darf die collction special Logik nicht einfach trotzdem wieder transient checken. \'c4ndern und kommentieren.\par
Das gleiche gilt dann auch f\'fcr die Enum Feld Checks.\par
\par
Default Check in Persistence Klasse einbauen und kommentieren.\par
\par
Foundation entsprechend erweitern.\par
\par
Ok, dann h\'e4tt ich das schon mal.\par
\par
Jetzt noch checken, ob ich im BinaryHandlerEnum irgendwo sicherstellen muss, dass die "top level" enum Klasse anstatt der AIC verwendet wird.\par
Ne, sollte passen.\par
\par
Dann ... bau jetzt ich eine MainTest, w\'fcrd ich sagen.\par
\par
Testen ... oh, JVM Crash, noch vor irgendeinem Breakpoints.\par
Dump anschauen ...\par
\par
Ah, schnell gefunden: storing Offsets [16, 0] kann nicht stimmen f\'fcr die zwei Referenzen in EmptyTable. Da hab ich gestern irgendwas ruiniert. Seltsam, dass es gestern beim Testen geklappt hat. Evtl. danach ruiniert? Na mal schauen ...\par
Ah. Arrayindex nicht inkrementiert, lol.\par
[12, 16] sieht schon sehr viel sinnvoller aus als [16, 0].\par
\par
Testen ... und scho gehts.\par
\par
Wenn jetzt sogar noch die Enum Analyse Logik betreten werden w\'fcrde, w\'e4r das super...\par
Mal im Code schauen.\par
\par
Achja! Da wird ja auf den Generic umgeleitet, damit der JM seine Enums generisch speichern und inkonsistent laden kann.\par
FIXME und debugout hinmachen und auf testcode umstellen.\par
\par
Seltsam: CrazyEnum erzeugt keine Exception und wird nicht als enum gehandelt.\par
Untersuchen.\par
\par
OMFG: bei der Klasse gibt .isEnum() false zur\'fcck. Wie bl\'f6d kann man sein?\par
\par
Also korrekte Version implementierung und sorgf\'e4ltig dokumentieren.\par
Alle Vorkommen des kaputten Class#isEnum ersetzen durch XReflect#isEnum(Class).\par
\par
Test erweitern um persistierbare CrazyEnum mit transient Feld.\par
Benamungen verbessern.\par
\par
Da f\'e4llt mir auf:\par
Sobald das Typehandling der ersten neuen Enum begegnet, muss es ALLE enum Instanzen des Typs durchchecken, damit nicht "halb persistierte" enum Listen entstehen.\par
So ein Shit.\par
\par
Erst mal weiter testen.\par
\par
Und noch ein Sonderfall im Sonderfall: Felder in einem Crazy Shit Enum Subtype, die in Superklassen deklariert sind, m\'fcssen akzeptiert werden, die bilden ja die kompatible Struktur.\par
\par
Damit l\'e4uft das Storen durch, wie geplant.\par
Allerdings: Im Crazy Shit $1 Typ fehlden die Enum Konstanten. Die Frage ist jetzt, ob das so sein muss, oder ob das ein Fehler ist ... hm ...\par
\par
Und noch ein Problem: das $1 ist gef\'e4hrlich. \'c4ndert sich mal die Reihenfolge der Enums, zeit das $1 auf einmal auf eine andere Implementierung, d.h. potenziall andere Logik, aber $1 (alt) wird nat\'fcrlich trotzdem problemlos zu $1 (neu) aufgel\'f6st und schwups, hat die geladene Enum Instanz den falschen Typ.\par
\par
Wobei ... ne, denn:\par
1.) Das w\'e4re eine LTM Sache, die ich erst noch handeln muss.\par
2.) Es werden keine Enum Instanzen erzeugt, sondern die Datens\'e4tze nur anhand des Namens und der OID auf existierende Instanzen gemappt. Dann ist der Typ immer richtig.\par
Hm. Aber dann \'e4ndert sich ja ggf. der Typ, d.h. die TypeId im Datensatz passt nicht mehr zur TypeId des Handlers, obwohl es gar kein LTM gab.\par
\par
Man, ist das alles kompliziert ...\par
\par
Zeit f\'fcr Feierabend :-[\par
\par
\par
\par
2019-08-02\par
\par
Paar Einf\'e4lle von daheim:\par
\par
1.)\par
Die Enum crazy shit subtypes einfach so wie der Compiler sie benennt, also $1, $2, usw. abspeichern, w\'e4re fatal bzw. zumindest sehr ung\'fcnstig und verwirrend.\par
Sagen wir ordinal 0 ist eine "normale" Enum, ordinal 1 eine crazy shit enum.\par
Dann wird die Subklasse f\'fcr ordinal 1 als $1 generiert und auch dementsprechend abgespeichert.\par
\'c4ndert man nun das Programm, dass auch ordinal 0 so ein crazy shit type ist, dann wird auf einmal der ordinal 0 type die $1 und der ordinal 1 wird die $2.\par
F\'fcr die JVM spielt das keine Rolle. F\'fcr die beginnt bei jedem Start das Universum komplett von Neuem und was davor war, spielt keine Rolle mehr. Sowas wie fr\'fcher mal persistierte und sp\'e4ter wieder zu verkn\'fcpfende Typnamen kennt die JVM nicht, darum muss der Compiler darauf keine R\'fccksicht nehmen.\par
Mit MS gibt es das aber nun doch und der Versuch, $1 zu einem Runtime Type aufzul\'f6sen, ergibt nicht den - inzwischen - n\'f6tigen Typ $2, sondern nat\'fcrlich einfach die $1. Und schwups, hat die zweite Enum Konstante den crazy shit typ der ersten Enum Konstante. Das ist dann h\'f6chstwahrscheinlich ein Bug, denn wenn die Subtypen sich nicht unterscheiden w\'fcrden, w\'e4ren sie ja gleich nicht gemacht worden.\par
\par
L\'f6sung (leider):\par
Den Typnamen selber bauen.\par
Anstatt com.app.MyEnum$1 sowas wie com.app.MyEnum$:TYPE_A\par
\par
Die Class resolving Logik muss daf\'fcr ein klein bisschen aufgebohrt werden:\par
if contains "$:", dann erst mal das davor als Typ aufl\'f6sen und dann das danach als Identifier innerhalb dieses Typs aufl\'f6sen.\par
Wenn der Typ ein Enum ist, dann ist der Identifier ein Enum Konstantennamen.\par
Wenn der Typ kein Enum ist, dann Klasse und alle Membes darin mit eine modularen Reflection Funktion nach einem Persistence Identifier durchsuchen (typischerweise Annotation, aber das ist frei w\'e4hlbar).\par
Damit kann man dann n\'e4mlich auch gleich die Anonymous Inner Class Instances ordentlich identifizieren, die dieses Problem genauso haben.\par
\par
2.)\par
Aus #1 ... oder vielleicht sogar unabh\'e4ngig davon ... folgt auch eine andere Erkenntnis:\par
Den State der Crazy Shit Enum Subtypes kann man sehr wohl mitpersistieren. Wenn der Typ eh seinen eigenen handler bekommt und auf nur genau die richtige Instanz angewendet wird, dann spricht ja nichts dagegen, noch ein paar Felder mehr mitzunehmen.\par
\par
\par
Der erste Schritt f\'fcr die Implementierung ist, erst mal eine XReflect Methode zu schreiben, die die crazy SubTypes erkennt, damit man die Fallunterscheidung bauen kann.\par
Und dann gleich noch eine Methode, um immer die enum top-level Klasse zu holen. Das brauch ich dann, um bei der ersten Begegnung mit einer enum gleich alle Konstanteninstanzen durchzuanalysieren, damit Enumtypen nicht "halb" persistiert werden und die andere H\'e4lfte sp\'e4ter vielleicht mal eine Exception erzeugt.\par
\par
\par
\par
TODOS:\par
v XReflect Enum Subtyp Erkennungsmethode\par
v XReflect Methode zum holen der top-level Enum Klasse\par
v TODO: Alle RefactoringResolver umbenennen zu TypeDescriptionResolver.\par
v Explizit benannte Enum Subtypen\par
v Class Resolving um explizite Benamungen erweitern\par
- Bei Begegnung mit einem neuen Enum Typen gleich alle Enum Instanzen analysieren\par
- Bei Begegnung mit einem neuen Enum Typen persistence root erweitern um ein Array daf\'fcr\par
- Root Initialisierung um einen Abgleich mit den aktuellen JVM-generierten enum Konstanteninstanzen des Typs erweitern\par
- Und dann noch das ganze Thema Legacy Type Mapping f\'fcr \'c4nderungen an Enums.\par
- Das ganze LTM Strukturvergleichszeug muss Enum Felder mit ber\'fccksichtigen, bzw. "all" statt "instance".\par
(offene Punkte unten repliziert)\par
\par
... Nach einer Woche Enum Handling Implementierung ist es mehr Arbeit als zu Beginn. Aber daf\'fcr ist jetzt der Umfang klar, alles ist sauber l\'f6sbar und das Licht am Ende des Tunnels ist zu sehen.\par
\par
XReflect Erweiterungen gebaut.\par
\par
Jetzt expliziten Typename einbauen und durch alle beteiligten Konstruktoren ziehen.\par
\par
PersistenceTypeNameDeriver anlegen und in der Foundation verbandeln.\par
\par
Hm... oder Moment mal: Sollte PersistenceTypeNameDeriver und TypeResolver nicht zwangsweise dieselber Implementierung sein? Ansonsten k\'f6nnen die inkonsistent zueinander gesetzt werden, so dass der Resolver die Strings\par
des NameDerivers nicht erkennt...\par
Jup, mach ich so.\par
\par
PersistenceTypeResolver entsprechend erweitern und umbenennen zu PesistenceTypeNameMapper.\par
Hm. Das sind zwei Stufen beteiligt und f\'fcr beide Richtungen sehen die Methoden f\'fcr unterschiedliche Stufen so aus, als w\'e4ren sie Equivalente f\'fcr dieselbe Stufe, was falsch ist.\par
Beide ordentlich kommentieren, sonst verwirrt das zu sehr.\par
\par
Projektweit umbennen und nameDeriver wieder rausschmeissen.\par
\par
Aber das alles \'fcber den PersistenceRefactoringResolver laufen zu lassen ist unn\'f6tig kompliziert, namentlich verwirrend und evtl. sogar mal durch die Initialisierungsreihenfolge problematisch.\par
Also das eigentliche type<->name mapping als eigenes, kombiniertes Ding rausziehen. Dann sind auch gleich diese zwei Stufen sauber getrennt.\par
\par
Dann benenn ich das Ding doch wieder auf TypeResolver um, weil "TypeNameMapper" zu ... kurz gegriffen klingt.\par
\par
Irgendwie ist das beim TypeDictionaryBuilder ein bisschen wirr. Nur deswegen muss der TypeResolver einen Provider haben. Das ist alles bissl seltsam.\par
Au\'dferdem muss der nur wegen dem Builder eine resolve Methode f\'fcr TypeDescriptions haben.\par
Und letztendlich wird dem Builder ja doch gleich RefactoringResolver \'fcbergeben.\par
Alles wirr...\par
\par
\par
Ah, jetzt hab ichs:\par
PersistenceRefactoringResolver wird umbenannt zu PersistenceTypeDescriptionResolver\par
Und der wrappt einen simplen PersistenceTypeResolver.\par
Der TypeHandlerCreator verwendet dann nur den (selben) PersistenceTypeResolver, ohne PersistenceTypeDescriptionResolver drum rum.\par
So passts.\par
\par
Umsetzen. Fertig.\par
\par
Jetzt das Benamungszeug bauen: deriver Methode erweitern und resolver Methode analog.\par
Testen.\par
Geht.\par
\par
handleable Enum Logik drin lassen, aber body durch return true ersetzen.\par
Testen.\par
Passt.\par
\par
Okay, dann sollte das Enum Handling jetzt grunds\'e4tzlich passen. Fehlt nur noch:\par
\par
\cf1\b TODOS:\par
\b0 - Bei Begegnung mit einem neuen Enum Typen gleich alle Enum Instanzen analysieren\par
- Bei Begegnung mit einem neuen Enum Typen persistence root erweitern um ein Array daf\'fcr\par
- Root Initialisierung um einen Abgleich mit den aktuellen JVM-generierten enum Konstanteninstanzen des Typs erweitern\par
- Und dann noch das ganze Thema Legacy Type Mapping f\'fcr \'c4nderungen an Enums.\par
- Das ganze LTM Strukturvergleichszeug muss Enum Felder mit ber\'fccksichtigen, bzw. "all" statt "instance".\par
\cf0\par
\par
\par
2019-08-05\par
\par
Wieder mal eine Idee aus dem Wochenende:\par
Ich wollte das mit den Konzept Identifiern ja auch benutzen, um optional Anonymous Inner Classes eindeutig zu identifizieren.\par
Das ist ja aber nicht, weil es in der Class API keine M\'f6glichkeit gibt, alle member types zu iterieren.\par
Durchnummeriert benannte Klassennamen sind aber brandgef\'e4hrlich, weil sie nicht einfach nicht aufgel\'f6st werden, sondern potenziell falsch aufgel\'f6st werden, einfach nur dadurch, dass sich die Reihenfolge von Sourcecode Teilen \'e4ndert.\par
Darum folgende Idee:\par
\'c4hnlich dem Lambda Recognizer einen TypeNameMapper oder sowas machen.\par
Defaultm\'e4\'dfig reicht der alles unver\'e4ndert durch, nur bei $1 etc. Namen wirft er eine Exception mit einer detaillierten Erkl\'e4rung.\par
Hei\'dft: AICs sind dann nicht mehr persistierbar. Macht ja eigentlich auch keinen Sinn, wenn es um ein Entity Datenmodell geht.\par
Alles, was man mit AICs machen kann, kann man auch zu ordentlich benannten Klassen umformen und dann geht es. Z.B. Comparators definieren, wenn man die unbedingt mitpersistieren muss.\par
Falls doch jemand unbedingt AICs unordentlich persistieren will, kann er das "auf eigene Gefahr" machen, indem er den TypeNameMapper durch einen ersetzt, der ALLES einfach durchreicht, inklusive AICs.\par
Oder der sich irgendwie eine Implementierung schreibt, die die Dinger ordentlich aufl\'f6st.\par
Beispiel: Brute-force-m\'e4\'dfig alle $1... dynamisch durchiterieren, bis keine so benannte Klasse mehr gefunden werden kann und all diese Klassen dann durchanalysieren, welche von denen wohl zu der im Dictionary beschriebenen passt.\par
Das geht, k\'f6nnte ich auch gleich so machen, aber mal ehrlich:\par
AIC Instanzen persistieren wollen ist schon ein bisschen d\'e4mlich. Die sind technisch zwar Klassen mit Instanzen, aber logisch sind es eigentlich nur Logik-Bestandteile. Wer ordentlich handlebare Klassen will, soll in Gott's Namen einen Klassennamen dranschreiben.\par
\par
Bzw., nach einem kurzen Blick in den aktuellen Sourcecode muss das gar kein zus\'e4tzlicher Typ werden, sondern das macht der PersistenceTypeResolver gleich direkt mit. Das ist ja genau das Ding, das die Transformation Class <-> Classname durchf\'fchrt. Bzw. die tats\'e4chliche Fallunterscheidung kommt in  Persistence#derivePersistentTypeName rein, neben die f\'fcr enums. Passt.\par
\par
Implementiert und getestet. Passt.\par
Noch priv#23 updaten, priv#124 erstellen und verlinken. Fertig.\par
\par
\par
2019-08-06\par
\par
Jetzt Root Handling erweitern.\par
\par
Idee dazu:\par
Es m\'fcsste f\'fcr enum Konstanteninstanzen eigentlich gar keinen eintrag in den Roots geben, weil man einfach von allen Enum Typen alle Konstanteninstanzen pauschal als Roots behandeln kann.\par
D.h. es m\'fcsste beim Roots synchen eigentlich nur eine Abfrage nach Typ oder evtl. eine special Abfrage (loadRootTypeInstances oder so) geben. Dann w\'fcrden in den PersistenceRoots wirklich nur "echte" Roots drinstehen und nicht endlose Array an allen m\'f6glichen enumn.\par
\par
Hm, allerdings:\par
Die PersistenceRoots werden auch gebraucht als Ausgangspunkt f\'fcr den GC. Und das sollte m\'f6glichst einfach gehalten sein ("starte beim root") und nicht wieder extra special verteile Logik brauchen ("starte beim Root, aber dann schau auch noch in alle m\'f6glichen Root-haften Typen rein").\par
\par
Das hei\'dft, der Tradeoff w\'e4re\line + Schlanke PersistenceRoot Instanzen\par
- zweifache Verkomplizierung von Logik\par
\par
Das dr\'e4ngt die Frage auf: Interessiert es eigentlich irgendwen, wie schlank oder fett die eine PersistenceRoots instanz ist?\par
Hm... das macht die Antwort, glaub ich, klar: Keine Sonderbehandlung, sondern lieber Roots Instanz aufblasen, wie geplant.\par
\par
Hm, gro\'dfes Problem bzgl. Enum Roots und LTM aufgefallen:\par
Wenn es eine aktuellere Version einer Enum gibt, sollen dann nur deren Konstanten als Roots registriert werden und die alten rausfliegen?\par
Aber was ist dann, wenn doch mal wieder die alte Version die aktuell passende w\'fcrde?\par
Dann w\'e4ren alle Root-Mappings von fr\'fcher weg. Man m\'fcsste ein neu -> alt mapping der Konstanten machen und h\'e4tte nur noch die zur Verf\'fcgung, die in beiden Versionen vorkommen.\par
Oder man m\'fcsste alle root Eintr\'e4ge von allen Versionen von enum typen drin lassen. Dann ist aber die Frage: Wann sind die wirklich veraltete? Wie kriegt man sie aus den Roots wieder raus? Oder sammeln sich enums f\'fcr immer root-gesichert an?\par
F\'fcr eine simple stateless enum mag das marginal sein, aber was ist, wenn eine enum mal ein Feld hat und da eine Referenz auf einen riesigen Subgraph drin ist? Dann bleibt der f\'fcr alle Ewigkeit, obwohl man von der Klassendefinition her davon ausgehen k\'f6nnte/w\'fcrde/m\'fcsste, dass die enum Instanz weg ist und das Zeug gel\'f6scht wird.\par
\par
Hm ... beides ist irgendwie ... bl\'f6d.\par
\par
Besonders knifflig w\'e4re: Eine veraltete enum Instanz kann ja durchaus noch von anderen Instanzen referenziert werden, sie ist nur nicht mehr als root registriert (hm, wobei das sp\'e4testens beim Laden eine Exception geben w\'fcrde ...)\par
\par
---\par
... Moment mal, das ist nochmal ein wichtiger Punkt f\'fcr sich:\par
\par
Sagen wir, es gibt drei enum Instanzen\par
MyEnum#A, #B, #C.\par
Alle drei werden referenziert.\par
Nun wird die enum Klasse MyEnum ver\'e4ndert, so dass es nur noch #A und #B gibt.\par
#C gibt es nicht mehr, aber der Datensatz daf\'fcr liegt nach wie vor in der Datenbank und wird referenziert.\par
Damit das beim Laden keine Exception gibt, m\'fcsste es eine explizite "Deleted" Markierung geben und eine entsprechende Registry, in der das Laden einen Lookup rein macht.\par
Aber damit nicht genug:\line Die Instanz #C wird ja auch noch "normal" \'fcber den Objektgraph referenziert. Der GC klappert die Referenzen ab und trifft dabei auch auf C. Und klappert dann braf weiter dessen Referenzen ab.\par
D.h. eigentlich m\'fcsste es f\'fcr den GC eine "deleted instances" Registry geben, die f\'fcr jede Instanz abgeklappert wird und falls die darin registriert ist, werden zumindest ihre Referenzen wiederum nicht mehr weiter abgeklappert.\par
Dann liegt zwar immer noch die gel\'f6schte Instanz datensatzm\'e4\'dfig rum, aber immerhin nur noch garantiert shallow, ohne Referenzen und beim Laden wird sie ja dann durch den Handler ignoriert.\par
\par
Oder ist das Quatsch, weil man sich um "gel\'f6schte" (bzw. "zu l\'f6schende") Instanzen in einem Objektgraph selber k\'fcmmern muss, indem man ausnullt und abspeichert? Hm... Dann m\'fcsste es den Check aber trotzdem geben und der m\'fcsste eine Exception werfen. Wobei eine Exception im Storage Channel Thread beim GC niemandem was hilft. Also doch beim Laden ausnullen? Hm...\par
---\par
\par
Aber zur\'fcck zur vorherigen \'dcberlegung:\par
Eine veraltete enum Instanz kann ja durchaus noch von anderen Instanzen referenziert werden, sie ist nur nicht mehr als root registriert.\par
Der persistente Datensatz k\'f6nnte wieder geladen werden, aber dann ist die Root-Verkn\'fcpfung zur JVM-generierten Instanz weg und es m\'fcsste eine neue, nicht-root, Instanz dynamisch erzeugt werden. Das gibt aber eine Exception ...\par
\par
Also m\'fcsste es doch so sein, dass enum Instanzen nicht \'fcber einen expliziten Root, sondern implizit \'fcber die Aufl\'f6sung \'fcber den Type root-verkn\'fcpft werden?\par
\par
Wobei auch da wieder ein Problem ist:\par
Eine Instanz kann nur eine TypeId haben. N\'e4mlich die der aktuellen enum Version, zu der sie geh\'f6rt.\par
Dann kann die aber nicht in mehreren Types referenziert sein. Immer nur in einem.\par
\par
Also l\'e4uft wohl doch alles auf die simple Variante raus:\par
Es werden nur von der aktuellen Version einer enum Instanzen Root-Verlinkt. Alle \'e4lteren Versionen eines enum Typs haben keine Instanzen bzw. die m\'fcssen bei Bedarf "zur\'fcckgemappt" werden ...\par
Echt knifflig ...\par
\par
\par
Zur\'fcck zum konkreten n\'e4chsten Schritt f\'fcr das Root Handling\par
\par
Vielleicht w\'e4re aber eine Mischung der Ideen gut, damit der TypeHandler nicht live im Betrieb die PersistenceRoot Instanz erweitern muss:\par
- Beim Root Initialisieren werden alle aktuellen Versionen von enum typen festgestellt\par
- F\'fcr diese Typen werden alle existierenden Instanzen (= alle enums) geladen.\par
- alle in der Root Instanz vorhandenen enums werden durchlaufen und mit den aktuellen versionen ihrer Typen abgeglichen und ggf. aktualisiert.\par
- alle nicht gematchten enum Instanzen werden in die Root Instanz f\'fcr ihren Typ via Object[] eingetragen.\par
\par
Allerdings hat das ein Problem: Zur Laufzeit neu abgespeicherte enum instanzen sind nicht root-gesichert. D.h. der GC k\'f6nnte die wegl\'f6schen.\par
Wobei eigentlich irgendwie die Frage ist: Ist es denn \'fcberhaupt relevant, eine enum zu verlieren, die niemand referenziert? Beim n\'e4chsten root initialisieren kann sie ja dann wieder angelegt und abgespeichert werden.\par
\par
Hm, ja, doch, kann einen Unterschied machen:\par
- Enum referenziert einen subgraph\par
- andere Instanz referenziert den subgraph auch\par
- aber niemand referenziert die enum (mehr)\par
- enum wird gel\'f6scht, subgraph aber nicht.\par
- neustart: root synch speichert die enum wieder ab und zwar mit einer neuen, redundanten version des referenzierten Subgraphs.\par
- Nun gibt es den subgraph zweimal mit unterschiedlichen Ident\'e4titen anstatt konsistent nur einmal.\par
\par
Also dann muss der TypeHandler Creator gleich sauber sofort den root Eintrag machen. Alles andere wird irgendwann mal Probleme machen...\par
\par
So umsetzen.\par
\par
Besser gesagt der TypeHandlerManager.\par
Dabei gleich mal #internalEnsureTypeHandler aufr\'e4umen.\par
\par
Jetzt Referenz zum RootResolver reinbauen.\par
\par
Oh Mann, Moment mal:\par
Wenn der TypeHandlerManager die Roots Instanz updaten muss, dann muss der ja eine Referenz zu einem Storer haben.\par
Das passt mir irgendwie gar nicht, dass ein interner Typsystem-Teil auf einmal eine aktiv persistierende Logik werden soll.\par
\par
Eine andere M\'f6glichkeit w\'e4re, dass der Storer das selber macht, inklusive Pr\'fcfung auf Enum Type.\par
Oder, dass er sich erst mal nur den TypeHandler holt und wenn der null ist, dann ensuret er ihn bim typehandler, mit sich selber als storing callback.\par
Aber dann h\'e4ngt halt in der ganzen API ein storing callback drin.\par
Und was ist, wenn der Commit dann nicht gemacht wird? Also d\'fcrfte der Storer sich nicht selbst mitliefern, sondern es m\'fcsste ein extra Storer sein, der dann auch garantiert committet wird.\par
Aber hoffentlich macht das dann mal nicht irgendwelche Reihenfolge Probleme, dass Transaction n+1 vor Transaction n committet wird ... Momentan nicht, aber wer wei\'df.\par
\par
Und: Was ist, wenn ein neuer Typ nicht direkt von einem Storer aus analysiert wird, sondern von einem anderen kontext?\par
Naja gut, man k\'f6nnte im Fall einer enum bei einem \'fcbergebenen null-callback dann eine exception werfen, also den storing callback erzwingen.\par
Andererseits: Typsystem Zeug wird schon schon auch mal aufgerufen, wenn es noch gar keine laufende Storage gibt. Was dann?\par
\par
Folgendes w\'e4re vielleicht eine gute L\'f6sung:\par
Der TypeHandlerManager hat eine Liste an "pendingInstanceSynchEnums".\par
Die ist normal immer leer, aber wenn ein TypeHandler f\'fcr eine neue Enum dazukommt, kommt der da rein.\par
An verschiedenen Stellen in der Library wird gecheckt, ob die leer ist und wenn nicht, dann werden die n\'f6tigen enum Instanzen als neue Root f\'fcr die enum abgespeichert:\par
- Beim anf\'e4nglichen roots synchen (um vorab registrierte TypeHandler abzudecken)\par
- Bei jedem Commit eines storers (um im laufenden Betrieb registrierter TypeHandler abzudecken..\par
\par
Wird ein Commit nicht gemacht, checkt einfach der n\'e4chste Commit.\par
Wird die ganze Storage vor dem n\'e4chsten Commit beendet, macht die n\'e4chste Initialisierung den Check.\par
\par
Das sollte so wasserdicht sein.\par
Knifflig. Nochmal durchdenken ...\par
\par
Das m\'fcsste dann aber zweistufig sein:\par
Roots Instanz updaten und Roots instanz speichern.\par
Oder wird die Roots Instanz gleich beim Handler erzeugen geupdatet? Aber was ist, wenn es zu dem Zeitpunkt (vor dem Start) noch keine Roots instanz gibt? Darum evtl. doch zweistufig...\par
Evtl. d\'fcrfte der TypeHandler die roots dann nicht "hart" on-demand providen lassen, sondern eher peeken: sobald es eine roots instanz gibt, enum konstanten darin updaten, aber nicht von selber ...\par
\par
Dann w\'e4r die Reihenfolge:\par
- Bei Enum Handler Erzeugung pending enum registrieren\par
- Bei Commit auf pending enums checken, falls ja dann roots peeken, falls vorhanden, roots erweitern und als pending roots registrieren und pending enums clearen\par
- Bei Commit auf pending roots pr\'fcfen (storer \'fcbergeben)\par
- Nach Commit pending roots clearen\par
\par
Das sichert auch ab, dass der commit zwar die pending roots veranlasst hat, dieser aber aufgrund eines problems nicht gespeichert hat.\par
Hm. Wobei das Problem daran ist: dann w\'fcrde ein neu eingetragenes Object[] nicht mehr als neu erkannt werden. D.h. der pending Eintrag muss jedes neu dazugekommene bzw. ver\'e4ndert enum-konstanten-Object[] mit registrieren und dem storer explizit setzen.\par
}
 