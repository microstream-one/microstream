{\rtf1\ansi\ansicpg1252\deff0\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\lang7\f0\fs28 Root-Handling Wiedermal\par
(Ticket #J117)\par
2019-12-10\par
\par
\par
Da es f\'fcr ziemlich jeden eine intellektuell un\'fcberwindbare Komplexit\'e4t zu sein scheint, dass zwei widerspr\'fcchliche Anforderungen/Strategien f\'fcr eine Root-Instanz auch zwei unterschiedliche Strategien braucht, ist wieder mal das Thema, ob man das Root-Handling NOCH weiter vereinfachen kann.\par
\par
\b Ziel:\b0\par
\line CustomRoot und DefaultRoot sollten \'fcber den gleichen identifier ("root") registriert werden, damit es da bei Exceptions keine Verwirrung gibt.\par
Und sie sollten nach au\'dfen, API-m\'e4\'dfig (getRoot, setRoot, storeRoot) gleich wirken, so dass die lustigen Leuts eigentlich gar nicht merken, dass es eine unterschiedliche Behandlung gibt, wenn man eine Root Instanz schon in der Initialisierung mitgibt oder erst sp\'e4ter setzt bzw. gettet und castet.\par
Es w\'e4re auch nicht schlecht, eine Root-Instanz nachtr\'e4glich neu setzen zu k\'f6nnen. Wahrscheinlich l\'e4uft das darauf raus, dass die PersistenceRoots Instanz nochmal gespeichert werden muss.\par
Wenn das eh schon n\'f6tig wird, k\'f6nnte man die auch gleich ver\'e4ndern und abspeichern, um DefaultRoots zu setzen. Hm ...\par
\par
Erst mal der aktuelle Stand:\par
\par
\b Definition:\b0\par
\par
\ul CustomRoot:\ulnone\par
Eine Instanz von einem bestimmten Typ, die man der Storage f\'fcr die Initialisierung \'fcbergibt. Typischerweise \'fcber .start(root). Die wird beim initialen Laden automatisch aus den Daten der Datenbank ver\'e4ndert/aktualisiert, so dass die selbstdefinierte Instanz wie auf "magische" Weise die Root-Instanz des persistenten Entitygraphen wird. Und zwar mit spezifischer Typisierung, ohne den EmbeddedStorageManager mit convenience-m\'e4\'dfig nervigen Generics aufblasen zu m\'fcssen.\par
Das ist schon mal technisch und anwendungsdesignm\'e4\'dfig die perfekte L\'f6sung. Alles andere ist nur noch Convenience-Ged\'f6ns f\'fcr ultra-kurze Hello-World-Beispiele und einf\'e4ltige Leute.\par
\par
\ul DefaultRoot:\ulnone\par
Eine programmatisch erzeugte Reference, die bei Fehlen eines CustomRoot als Root-Instanz registriert wird und erst mal auf null zeigt. Die fachliche Root-Instanz kann dann nach der Storage Initialisierung durch setRoot() gesetzt und dann durch storeRoot() gespeichert werden. Beim n\'e4chsten Laden wird die Reference Instanz mit nicht-null Referenz geladen und man hat ebenfalls die Root-Instanz des persistenten Entitygraphen. Der Unterschied zum CustomRoot ist aber: Man muss sich den geladenen fachlichen Root mit getRoot() holen und mangels Typisierung casten. Casten ist immer doof (potenzielle Fehlerquelle), also ist das die schlechtere L\'f6sung. Ein sinnlos hoher Preis daf\'fcr, dass man f\'fcr Hello-World-Beispiele einfach nur ".start()" schreiben braucht und sich vorher keine Root-Instanz designen und instanzieren muss, aber mei.\par
\par
\b Registrierung:\b0\par
\par
Ein CustomRoot wird registriert unter dem Identifier "root". Denn das ist der Normalfall.\par
Ein DefaultRoot wird registriert unter dem Identifier "defaultRoot". Das ist der Sonderfall.\par
\par
Ich hab jetzt tats\'e4chlich die Frage, warum man \'fcberhaupt zwei verschiedene Identifier braucht.\par
Es k\'f6nnte ja unter demselben Identifier ein anderer root instanceSupplier registriert werden und wenn die Klassen nicht passen, muss es sowieso eine Exception geben.\par
War der Grund einfach nur, um auszuschlie\'dfen, dass jemand mal eine Singleton Instanz als CustomRoot registriert, dann auf defaultRoot umstellt und die Instanz dann nicht implizit als DefaultRoot anstatt als CustomRoot verwendet wird?\par
Das k\'f6nnte man auch sauberer l\'f6sen: einen expliziten "DefaultRoot" Typ, der ansonsten ohne Fallunterscheidung verwendet wird und beim Updateversuch gibts dann eine Type-Exception, wie in jedem anderen Fall bei unpassendem Typ auch.\par
Man hat halt dann einen ansonsten sinnlosen Eintrag f\'fcr "DefaultRoot" im TypeDictionary. Aber eigentlich ist das dann eh schon egal.\par
\par
\par
\b Abw\'e4rtskompatibili\'e4t\b0\par
\par
Abw\'e4rtskompatibili\'e4t f\'fcr DefaultRoots wird noch ein Problem, wenn sich da jetzt wieder was \'e4ndert.\par
Das m\'fcsste eine Logik sein, die einen DefaultRoot nach altem Konzept sneaky implizit im neuen Konzept abspeichert. Dann l\'e4sst man das ein paar Versionen lang und dann kann man den Support-Code f\'fcr das alte Konzept rauswerfen.\par
\par
\par
\par
Hm.\par
Eigentlich sollte der Ansatz, die PersistenceRoots halt dann leider doch neu zu speichern, die eierlegende Wollmilchsau-L\'f6sung sein:\par
Der CustomRoot wird unter "root" dort direkt verlinkt und persistiert. Beim Laden wird die \'fcbergebene Instanz bef\'fcllt.\par
DefaultRoot Zwischen-Referenz-Instanz gibts nicht mehr, daf\'fcr wird die dynamisch gesetzte root-Instanz genauso in den PersistenceRoots gesetzt, wie der CustomRoot. Beim Laden wird eine neue Instanz erzeugt. Das ist keine Inkonsistenz, denn es gibt ja keine \'fcbergebene Root-Instanz, die nicht geupdatet werden w\'fcrde. Sondern nix is definiert. Graph wird geladen. Root Instanz wird dynamisch erzeugt. \'dcber getRoot() kann man sie sich holen.\par
Man k\'f6nnte damit sogar aus einer zuvor dynamisch gesetzten  DefaultRoot Instanz beim Laden eine CustomRoot Instanz machen  - bzw, falsch formuliert: Wenn man eine Instanz mit passendem Typ als CustomRoot \'fcbergibt, dann w\'fcrde die korrekt bef\'fcllt/aktualisiert werden, auch wenn der Datensatz zuvor als DefaultRoot gespeichert worden ist.\par
Das w\'e4re ziemlich cool.\par
\par
Und jetzt noch ein weiter gedacht, jetzt muss ich ZJ leider Credits geben:\line Man k\'f6nnte ja standardm\'e4\'dfig von den PersistenceRoots aus eine Zwischen-Referenz-Instanz auf den fachlichen Root f\'fcr BEIDE F\'e4lle machen. Dann m\'fcsste man die PersistenceRoots \'fcberhaupt nicht neu speichern, sondern nur das Zwischending.\par
Knifflig ist aber, dass diese Zwischen-Referenz-Instanz dann einen extra TypeHandler oder zumindest extra Handling Logik br\'e4uchte, die nach einem root-Supplier sucht und bei Erfolg dessen Instanz verwendet.\par
\par
Da muss ich mal rumprobieren ...\par
\par
Das mit der Zwischenreferenz wird aber nicht so einfach, weil nur direkte Root-Eintr\'e4ge per Supplier-Logik aufgel\'f6st werden. Wenn man dort zu einem Runtime-Ding aufl\'f6st, zeigt das einfach auf eine Referenz oder halt nicht.\par
Ne Moment. Unfug. \'dcber den Supplier wird eine bestimmte OID zu einer bestimmten Instanz aufgel\'f6st.\par
Wenn dann f\'fcr diese OID Daten geladen werden, wird die zuvor aufgel\'f6st Instanz geupdatet.\par
Das geht nat\'fcrlich auch mit einer Zwischen-Referenz-Instanz. Genauso l\'e4uft es ja aktuell bei dem DefaultRoot singleton.\par
Ach ne, aber das Problem ist eine Referenz sp\'e4ter:\par
Die explizit vorgegebene CustomRoot Instanz wird dann aber nicht mehr f\'fcr eine bestimmte OID registriert, sondern die w\'fcrde dann einfach durch eine geladene und dynamisch instanzierte Instanz ersetzt.\par
Eben genau wie bei dem DefaultRoot Singleton.\par
\par
Gut, man k\'f6nnte es so l\'f6sen, wie momentan alle Root-Instanzen gel\'f6st werden:\par
Sinnlos eine Instanz erzeugen, aber f\'fcr die ID dann eine andere Instanz registrieren, n\'e4mlich die explizit vorgegebene.\par
\par
Der Handler k\'f6nnte in seinem create() die oid der Referenz aus den binary daten raussuchen und f\'fcr diese oid seine explizte customRoot Instanz registrieren (falls vorhanden).\par
Hm. Das gleiche k\'f6nnte eigentlich der BinaryHandlerPersistenceRootsDefault auch machen ... Muss ich gleich mal als TODO reinschreiben.\par
\par
Der BinaryHandlerPersistenceRootReferenceDefault k\'f6nnte dann die Instanz gleich direkt kennen. W\'e4re ja effektiv ein Singleton f\'fcr eine EmbeddedStorageManager Instanz.\par
Sichergestellt w\'e4re das dadurch, dass er zusammen mit dem BinaryHandlerPersistenceRootsDefault an der gleichen Stelle erzeugt und dann intern registriert werden w\'fcrde.\par
\par
Das wirft aber wieder mal die Frage nach Initialisierungsreihenfolge auf usw. Also kann man PersistenceRootsProvider#provideRoots \'fcberhaupt an dieser Stelle (PersistenceRootsProvider#registerRootsTypeHandlerCreator) schon aufrufen?\par
\par
Recherche:\par
PersistenceRootsProvider#registerRootsTypeHandlerCreator\par
in PersistenceFoundation#ensureTypeHandlerManager\par
\par
PersistenceRootsProvider#provideRoots\par
in PersistenceTypeHandlerManager#internalInitialize\par
also NACH dem ersten\par
Und dort ist eh schon diese verz\'f6gert initialisierte refTypeHandlerManager drin. Also sollte klappen.\par
\par
Aber eigentlich kann mir das eh egal sein. Ich steck die Referenz auf die RootReference einfach in den PersistenceRootResolverProvider direkt rein. So wie dort auch jetzt schon alle m\'f6glichen root identifier drin h\'e4ngen.\par
Das passt schon.\par
\par
\par
\par
Homeoffice:\par
Branches auschecken usw. funktioniert alles auf Anhieb.\par
In Eclipse ist dank Maven wie \'fcblich alles erst mal rot. Also Maven -> update machen.\par
L\'e4sst alle Probleme verschwinden bis auf:\par
Missing artifact one.microstream:persistence.binary.jdk8:jar:02.01.01-MS-GA-SNAPSHOT\par
\par
Install und projekte cleanen usw. bringt nix.\par
Ach, ich hab das Projekt dazu tats\'e4chlich nicht angelegt.\par
Naja. Ist eigentlich egal, fix ich irgendwann mal. Der Rest passt ja. Probleme mit ge\'e4nderten Metadaten-Dateien im Sourcetree erzeugt es auch nicht, also wurscht.\par
Ah: kurz mal "import project" versucht und ging sogar reibungslos.\par
Passt.\par
\par
Ok. Dann gehts jetzt mal los damit, den PersistenceRootResolverProvider umzubauen.\par
Hui, da fliegen tonnenweise Methoden raus f\'fcr die zweispurige alte L\'f6sung ...\par
\par
Hm. Jetzt hab ich die Variante mit dem CustomRootSupplier registrieren rausgeworfen, weil die PersistenceRootReference gleich der Supplier ist.\par
Aber was ist mit dem Fall, dass die Anwendung aus Initialisierungsreihenfolgegr\'fcnde die Rootinstanz erst sp\'e4ter liefern kann...?\par
Dar\'fcber muss ich mal nachdenken ...\par
\par
Also da bau ich doch wieder die Supplier Variante ein.\par
\par
\fs22\par
}
 