{\rtf1\ansi\ansicpg1252\deff0\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\lang7\f0\fs28 Root-Handling Wiedermal\par
(Ticket #J117)\par
2019-12-10\par
\par
\par
Da es f\'fcr ziemlich jeden eine intellektuell un\'fcberwindbare Komplexit\'e4t zu sein scheint, dass zwei widerspr\'fcchliche Anforderungen/Strategien f\'fcr eine Root-Instanz auch zwei unterschiedliche Strategien braucht, ist wieder mal das Thema, ob man das Root-Handling NOCH weiter vereinfachen kann.\par
\par
\b Ziel:\b0\par
\line CustomRoot und DefaultRoot sollten \'fcber den gleichen identifier ("root") registriert werden, damit es da bei Exceptions keine Verwirrung gibt.\par
Und sie sollten nach au\'dfen, API-m\'e4\'dfig (getRoot, setRoot, storeRoot) gleich wirken, so dass die lustigen Leuts eigentlich gar nicht merken, dass es eine unterschiedliche Behandlung gibt, wenn man eine Root Instanz schon in der Initialisierung mitgibt oder erst sp\'e4ter setzt bzw. gettet und castet.\par
Es w\'e4re auch nicht schlecht, eine Root-Instanz nachtr\'e4glich neu setzen zu k\'f6nnen. Wahrscheinlich l\'e4uft das darauf raus, dass die PersistenceRoots Instanz nochmal gespeichert werden muss.\par
Wenn das eh schon n\'f6tig wird, k\'f6nnte man die auch gleich ver\'e4ndern und abspeichern, um DefaultRoots zu setzen. Hm ...\par
\par
Erst mal der aktuelle Stand:\par
\par
\b Definition:\b0\par
\par
\ul CustomRoot:\ulnone\par
Eine Instanz von einem bestimmten Typ, die man der Storage f\'fcr die Initialisierung \'fcbergibt. Typischerweise \'fcber .start(root). Die wird beim initialen Laden automatisch aus den Daten der Datenbank ver\'e4ndert/aktualisiert, so dass die selbstdefinierte Instanz wie auf "magische" Weise die Root-Instanz des persistenten Entitygraphen wird. Und zwar mit spezifischer Typisierung, ohne den EmbeddedStorageManager mit convenience-m\'e4\'dfig nervigen Generics aufblasen zu m\'fcssen.\par
Das ist schon mal technisch und anwendungsdesignm\'e4\'dfig die perfekte L\'f6sung. Alles andere ist nur noch Convenience-Ged\'f6ns f\'fcr ultra-kurze Hello-World-Beispiele und einf\'e4ltige Leute.\par
\par
\ul DefaultRoot:\ulnone\par
Eine programmatisch erzeugte Reference, die bei Fehlen eines CustomRoot als Root-Instanz registriert wird und erst mal auf null zeigt. Die fachliche Root-Instanz kann dann nach der Storage Initialisierung durch setRoot() gesetzt und dann durch storeRoot() gespeichert werden. Beim n\'e4chsten Laden wird die Reference Instanz mit nicht-null Referenz geladen und man hat ebenfalls die Root-Instanz des persistenten Entitygraphen. Der Unterschied zum CustomRoot ist aber: Man muss sich den geladenen fachlichen Root mit getRoot() holen und mangels Typisierung casten. Casten ist immer doof (potenzielle Fehlerquelle), also ist das die schlechtere L\'f6sung. Ein sinnlos hoher Preis daf\'fcr, dass man f\'fcr Hello-World-Beispiele einfach nur ".start()" schreiben braucht und sich vorher keine Root-Instanz designen und instanzieren muss, aber mei.\par
\par
\b Registrierung:\b0\par
\par
Ein CustomRoot wird registriert unter dem Identifier "root". Denn das ist der Normalfall.\par
Ein DefaultRoot wird registriert unter dem Identifier "defaultRoot". Das ist der Sonderfall.\par
\par
Ich hab jetzt tats\'e4chlich die Frage, warum man \'fcberhaupt zwei verschiedene Identifier braucht.\par
Es k\'f6nnte ja unter demselben Identifier ein anderer root instanceSupplier registriert werden und wenn die Klassen nicht passen, muss es sowieso eine Exception geben.\par
War der Grund einfach nur, um auszuschlie\'dfen, dass jemand mal eine Singleton Instanz als CustomRoot registriert, dann auf defaultRoot umstellt und die Instanz dann nicht implizit als DefaultRoot anstatt als CustomRoot verwendet wird?\par
Das k\'f6nnte man auch sauberer l\'f6sen: einen expliziten "DefaultRoot" Typ, der ansonsten ohne Fallunterscheidung verwendet wird und beim Updateversuch gibts dann eine Type-Exception, wie in jedem anderen Fall bei unpassendem Typ auch.\par
Man hat halt dann einen ansonsten sinnlosen Eintrag f\'fcr "DefaultRoot" im TypeDictionary. Aber eigentlich ist das dann eh schon egal.\par
\par
\par
\b Abw\'e4rtskompatibili\'e4t\b0\par
\par
Abw\'e4rtskompatibili\'e4t f\'fcr DefaultRoots wird noch ein Problem, wenn sich da jetzt wieder was \'e4ndert.\par
Das m\'fcsste eine Logik sein, die einen DefaultRoot nach altem Konzept sneaky implizit im neuen Konzept abspeichert. Dann l\'e4sst man das ein paar Versionen lang und dann kann man den Support-Code f\'fcr das alte Konzept rauswerfen.\par
\par
\par
\par
Hm.\par
Eigentlich sollte der Ansatz, die PersistenceRoots halt dann leider doch neu zu speichern, die eierlegende Wollmilchsau-L\'f6sung sein:\par
Der CustomRoot wird unter "root" dort direkt verlinkt und persistiert. Beim Laden wird die \'fcbergebene Instanz bef\'fcllt.\par
DefaultRoot Zwischen-Referenz-Instanz gibts nicht mehr, daf\'fcr wird die dynamisch gesetzte root-Instanz genauso in den PersistenceRoots gesetzt, wie der CustomRoot. Beim Laden wird eine neue Instanz erzeugt. Das ist keine Inkonsistenz, denn es gibt ja keine \'fcbergebene Root-Instanz, die nicht geupdatet werden w\'fcrde. Sondern nix is definiert. Graph wird geladen. Root Instanz wird dynamisch erzeugt. \'dcber getRoot() kann man sie sich holen.\par
Man k\'f6nnte damit sogar aus einer zuvor dynamisch gesetzten  DefaultRoot Instanz beim Laden eine CustomRoot Instanz machen  - bzw, falsch formuliert: Wenn man eine Instanz mit passendem Typ als CustomRoot \'fcbergibt, dann w\'fcrde die korrekt bef\'fcllt/aktualisiert werden, auch wenn der Datensatz zuvor als DefaultRoot gespeichert worden ist.\par
Das w\'e4re ziemlich cool.\par
\par
Und jetzt noch ein weiter gedacht, jetzt muss ich ZJ leider Credits geben:\line Man k\'f6nnte ja standardm\'e4\'dfig von den PersistenceRoots aus eine Zwischen-Referenz-Instanz auf den fachlichen Root f\'fcr BEIDE F\'e4lle machen. Dann m\'fcsste man die PersistenceRoots \'fcberhaupt nicht neu speichern, sondern nur das Zwischending.\par
Knifflig ist aber, dass diese Zwischen-Referenz-Instanz dann einen extra TypeHandler oder zumindest extra Handling Logik br\'e4uchte, die nach einem root-Supplier sucht und bei Erfolg dessen Instanz verwendet.\par
\par
Da muss ich mal rumprobieren ...\par
\par
Das mit der Zwischenreferenz wird aber nicht so einfach, weil nur direkte Root-Eintr\'e4ge per Supplier-Logik aufgel\'f6st werden. Wenn man dort zu einem Runtime-Ding aufl\'f6st, zeigt das einfach auf eine Referenz oder halt nicht.\par
Ne Moment. Unfug. \'dcber den Supplier wird eine bestimmte OID zu einer bestimmten Instanz aufgel\'f6st.\par
Wenn dann f\'fcr diese OID Daten geladen werden, wird die zuvor aufgel\'f6st Instanz geupdatet.\par
Das geht nat\'fcrlich auch mit einer Zwischen-Referenz-Instanz. Genauso l\'e4uft es ja aktuell bei dem DefaultRoot singleton.\par
Ach ne, aber das Problem ist eine Referenz sp\'e4ter:\par
Die explizit vorgegebene CustomRoot Instanz wird dann aber nicht mehr f\'fcr eine bestimmte OID registriert, sondern die w\'fcrde dann einfach durch eine geladene und dynamisch instanzierte Instanz ersetzt.\par
Eben genau wie bei dem DefaultRoot Singleton.\par
\par
Gut, man k\'f6nnte es so l\'f6sen, wie momentan alle Root-Instanzen gel\'f6st werden:\par
Sinnlos eine Instanz erzeugen, aber f\'fcr die ID dann eine andere Instanz registrieren, n\'e4mlich die explizit vorgegebene.\par
\par
Der Handler k\'f6nnte in seinem create() die oid der Referenz aus den binary daten raussuchen und f\'fcr diese oid seine explizte customRoot Instanz registrieren (falls vorhanden).\par
Hm. Das gleiche k\'f6nnte eigentlich der BinaryHandlerPersistenceRootsDefault auch machen ... Muss ich gleich mal als TODO reinschreiben.\par
\par
Der BinaryHandlerPersistenceRootReferenceDefault k\'f6nnte dann die Instanz gleich direkt kennen. W\'e4re ja effektiv ein Singleton f\'fcr eine EmbeddedStorageManager Instanz.\par
Sichergestellt w\'e4re das dadurch, dass er zusammen mit dem BinaryHandlerPersistenceRootsDefault an der gleichen Stelle erzeugt und dann intern registriert werden w\'fcrde.\par
\par
Das wirft aber wieder mal die Frage nach Initialisierungsreihenfolge auf usw. Also kann man PersistenceRootsProvider#provideRoots \'fcberhaupt an dieser Stelle (PersistenceRootsProvider#registerRootsTypeHandlerCreator) schon aufrufen?\par
\par
Recherche:\par
PersistenceRootsProvider#registerRootsTypeHandlerCreator\par
in PersistenceFoundation#ensureTypeHandlerManager\par
\par
PersistenceRootsProvider#provideRoots\par
in PersistenceTypeHandlerManager#internalInitialize\par
also NACH dem ersten\par
Und dort ist eh schon diese verz\'f6gert initialisierte refTypeHandlerManager drin. Also sollte klappen.\par
\par
Aber eigentlich kann mir das eh egal sein. Ich steck die Referenz auf die RootReference einfach in den PersistenceRootResolverProvider direkt rein. So wie dort auch jetzt schon alle m\'f6glichen root identifier drin h\'e4ngen.\par
Das passt schon.\par
\par
\par
\par
Homeoffice:\par
Branches auschecken usw. funktioniert alles auf Anhieb.\par
In Eclipse ist dank Maven wie \'fcblich alles erst mal rot. Also Maven -> update machen.\par
L\'e4sst alle Probleme verschwinden bis auf:\par
Missing artifact one.microstream:persistence.binary.jdk8:jar:02.01.01-MS-GA-SNAPSHOT\par
\par
Install und projekte cleanen usw. bringt nix.\par
Ach, ich hab das Projekt dazu tats\'e4chlich nicht angelegt.\par
Naja. Ist eigentlich egal, fix ich irgendwann mal. Der Rest passt ja. Probleme mit ge\'e4nderten Metadaten-Dateien im Sourcetree erzeugt es auch nicht, also wurscht.\par
Ah: kurz mal "import project" versucht und ging sogar reibungslos.\par
Passt.\par
\par
Ok. Dann gehts jetzt mal los damit, den PersistenceRootResolverProvider umzubauen.\par
Hui, da fliegen tonnenweise Methoden raus f\'fcr die zweispurige alte L\'f6sung ...\par
\par
Hm. Jetzt hab ich die Variante mit dem CustomRootSupplier registrieren rausgeworfen, weil die PersistenceRootReference gleich der Supplier ist.\par
Aber was ist mit dem Fall, dass die Anwendung aus Initialisierungsreihenfolgegr\'fcnde die Rootinstanz erst sp\'e4ter liefern kann...?\par
Dar\'fcber muss ich mal nachdenken ...\par
\par
Also da bau ich doch wieder die Supplier Variante ein.\par
\par
\par
\par
2019-12-12\par
\par
So. Nach 6 Stunden nur Management-Stuff komm ich jetzt, daheim, sogar zum programmieren!\par
\par
Die aktuelle Kniffligkeit ist:\par
Wo und wie konkret soll die PersistenceRootReference Instanz \'fcberall durchgeschleift werden?\par
Und darf die optional sein, damit der BinaryHandler Roots Instanzen laden kann, die die neue Instanz noch nicht haben, obwohl sie eigentlich mandatory sein muss...?\par
Schwierig...\par
\par
Hm, oder ist es so:\par
Die bei der Initialisierung generierte Instanz wird immer zwangsweise reingesetzt, weil die ja auch geupdatet wird.\par
Und die alten Roots Instanzen, die so ein Ding noch nicht haben k\'f6nnen dann den check machen, ob ihr geladenes Root Ding dasselbe ist oder was anderes.\par
Irgendwie so m\'fcsste es gehen ...\par
\par
\par
\par
2019-12-14\par
\par
Jetzt hab ich mal Ruhe, um an dem Thema weiterzumachen ...\par
\par
H\'e4? Wieso ist jetzt das JDK8 Projekt wieder ein Maven Fehler? Das ging doch neulich ...\par
Oh Mann x_x.\par
Und wieder Maven Update und wieder passt es danach. Ich hoff, ich muss jetzt nicht jedes mal ein Maven Update machen, um ohne falsche Fehlermeldung arbeiten zu k\'f6nnen ...\par
\par
Mal den BinaryHandler fertig implementieren, damit der nervige Compilerfehler verschwindet.\par
\par
Ah. Problem:\par
Wenn PersistenceRootReference intern eine supplier Logik hat, kann das potenziell (sogar wahrscheinlich) eine Lambda und das ist nicht persistierbar.\par
Hm. Aber muss es eigentlich gar nicht. Der Supplier ist ja nur ein Hilfsmittel daf\'fcr, falls Anwendungslogik die Root Instanz erst sp\'e4ter oder indirekt liefern kann oder will.\par
Sobald es mal in den store geht, ist die Instanz auf jeden Fall da und nur die muss abgespeichert werden. Also ohne Supplier.\par
Und Laden ist nat\'fcrlich trivial: Instanz laden und in der PersistenceRootReference  Instanz mit einem "() -> " wrappen. Fertig.\par
\par
Wobei aber trotzdem die Frage ist: Macht es denn wirklich Sinn, dass man in Form des Suppliers eine Indirektion registrieren kann?\par
Bei einer simplen Variante wie .start() sicher nicht, weil wenn die Root Instanz w\'e4hrend der Ausf\'fchrung der start Methode verf\'fcgbar ist, dann ist sie das davor auch schon (also ablaufreihenfolgenm\'e4\'dfig. Zeitlich darf es keine Rolle spielen, dann kann man auch gleich mit dem Aufruf der ganzen start Methode warten). Also sinnlos.\par
Gut, wo es schon Sinn machen kann ist:\par
Man konfiguriert sich die Foundation komplett zusammen, aber ruft bei der die create~Manager bzw. start Methode noch nicht auf, weil die Root Instanz noch nicht verf\'fcgbar ist.\par
Erst, wenn der Supplier auch ein brauchbares Ergebnis liefern kann (ablaufm\'e4\'dfig gemeint. NICHT zeitlich.), wird die .start() der fertig konfigurierten Foundation aufgerufen.\par
Daf\'fcr machts Sinnn.\par
Serialisierungsm\'e4\'dfig machts keinen Unterschied, weil eh nur die Instanz direkt gespeichert wird.\par
Also lass ich es so.\par
\par
\par
2019-12-15\par
\par
Bissl weitermachen, damit mal die Compilerfehler raus kommen.\par
\par
Hm. Also sollte BinaryHandler#create gleich die Instanz registrieren? Dann m\'fcsste PersistenceObjectIdResolver erweitert werden bzw. f\'fcr #create durch was erweitertes ersetzt werden ... . Vielleicht w\'e4re eine allgemeine Erweiterung aber besser. Irgendwann braucht man das vielleicht auch mal in #update.\par
Dann muss der BinaryLoader aber den ObjectManager kennen, damit der nicht einfach direkt in die Registry reinregistriert, ohne entsprechende Pr\'fcflogik durch den Manager.\par
Oh, achso: Das ist ja gar nicht das typische "Manager is a Registry" Pattern. Weil die ObjectRegistry fr\'fcher ja der Spezailfall war. Der ObjectManager hat gar keine vorgeschaltete Logik.\par
Dann kann es auch die Registry bleiben ...\par
\par
Das Problem an der Registrierei ist halt:\par
Wenn sich die Rootinstanz typm\'e4\'dfig ge\'e4ndert hat, wird eine "falsche" (eher neue) Instanz f\'fcr die bestehende und immer noch g\'fcltige OID registriert und erst im BinaryHandler gibts dann eine ClassCastException, die wieder keiner checkt.\par
Wenn man nicht registriert, wird beim Laden eine \'fcberfl\'fcssige Instanz aus der Datenbank erzeugt, f\'fcr die bestehende OID registriert und dann kann man die eigentliche Instanz daf\'fcr nicht mehr registrieren. Das w\'e4re dann sogar ein Bug.\par
Also geht eigentlich nur Variante #1...\par
\par
\par
BinaryHandlerPersistenceRootReferenceDefault#create ist eigentlich ganz simpel. Implementiert und ausf\'fchrlichen Kommentar dazugeschrieben.\par
\par
BinaryHandlerPersistenceRootReferenceDefault#update ...\par
Ist eigentlich ein No-Op.\par
Ne, nur dann, wenn es schon eine definierte Instanz gibt.\par
... Oder m\'fcsste die dann validiert werden mit der geladenen?\par
Ne Moment: Gibt's \'fcberhaupt eine geladene? Ne, weil #create ja die definierte Instanz f\'fcr die objectId registriert hat ...\par
Jetzt bin ich verwirrt ... o_O.\fs22\par
}
 