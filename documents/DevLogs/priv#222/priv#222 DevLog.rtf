{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1031{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red165\green165\blue165;}
{\*\generator Riched20 10.0.17763}\viewkind4\uc1 
\pard\sl276\slmult1\f0\fs28\lang7 Orphaned Lazy References after Storage Shutdown\par
priv#222\par
\par
\par
2020-02-10\par
\par
Also die "Bridging" Instanz ist eine WeakReference auf den StorageManager.\par
Und dann braucht die noch einen Identifier f\'fcr die "Datenbank", die sie repr\'e4sentiert.\par
Absichtlich "Datenbank", weil es hier nicht nur um die Storage geht, das Speicherding bzw. Speicher-Ebene, sondern um die Gesamtheit der Datenbasis, inklusive Graph. Darum Database.\par
\par
Dann kann mit dem LRM \'fcber die Lazys iteriert werden und \'fcber den Identifier kann bestimmt werden, ob einer Lazy Reference ein neuer Storage Manager gesetzt wird oder nicht.\par
\par
Hm...\par
Ne, Moment: Das geht extrem viel eleganter, wenn man es objektorientierter angeht:\par
\par
Die "Bridge" IST eine "Database" Instanz. Die hat intern eine WeakReference auf den aktuell verwendeten Storage Manager. Und der ist dann IN der Database einfach austauschbar. Dann haben alle Lazy Refs gleichzeitig und zwangsweise konsistent den neuen Storage Manager.\par
Die Database kann dann noch einen Identifier oder so haben, aber der spielt f\'fcr die Logik keine Rolle mehr, nur noch f\'fcr die Anzeige oder so.\par
\par
Man sollte eine Lazy Reference auch auf eine neue Database umziehen k\'f6nnen. Aber sowas ist dann eine optionale "Spezialoperation". Nichts, was man f\'fcr normalen Betrieb brauchen w\'fcrde.\par
\par
\par
Hm. Eigentlich braucht man f\'fcr "Database" Instanzen dann auch eine \'fcbergeordnete "Databases" Instanz, in der die alle mit ihrem Identifier registriert werden, damit Duplikate/Kollisionen vermieden werden.\par
Eigentlich k\'f6nnte/m\'fcsste/sollte da drin dann auch die ObjectRegistry referenziert werden, weil auch die direkt mit "der ganzen Datenbank" zu tun hat, nicht nur mit der storage ebene.\par
Und bei so einer Kollisionspr\'fcfung k\'f6nnte dann auch gleich gepr\'fcft werden, ob zwei StorageManager dieselbe Storage (Base Directory Path oder so) haben.\par
\par
Achja und da war noch die Sache, dass da in der Lazy Reference mal der PersistenceManager anstatt dem StorageManager gesetzt war. Das schau ich gleich mal noch schnell.\par
\par
loader wird gesetzt in:\par
- Default(3)\par
\cf1\tab x Default(1), aber mit null\par
\tab x New(1), aber mit null\par
\cf0\tab - New(2)\par
\tab\tab - BinaryValueTranslators#wrapWithLazyReference mit PersistenceLoadHandler#getObjectRetriever\par
\cf1\tab x New(3)\par
\tab\tab x MainTestLazyReferenceHandling\par
\cf0 - setLoader\par
\tab - link\par
\tab\tab - BinaryHandlerLazyDefault#store mit PersistenceStoreHandler#getObjectRetriever\par
\tab - BinaryHandlerLazyDefault#updateState mit PersistenceLoadHandler#getObjectRetriever\par
\par
Ah: PersistenceManager hat eine Methode #getEffectivePersister.\par
Die macht coalesce(this.persister, this)\par
Also wenn der PM keinen expliziten Persister kennt, gibt er sich selbst zur\'fcck.\par
Damit \'e4ndert sich die Frage zu: Warum kennt er manchmal keinen expliziten persister?\par
\par
Also PersistenceLoadHandler#getObjectRetriever l\'e4uft \'fcber die #getEffectivePersister.\par
Der explizit gesetzte persister ist der von der Foundation \'fcbergebene.\par
Und EmbeddedStorageFoundation#createEmbeddedStorageManager setzt den ganz am Ende kurz vor dem Zur\'fcckgeben der fertigen ESM Instanz.\par
\par
Der PM wird erzeugt beim StorageConnection erzeugen.\par
Die wird von der ConnectionFoundation erzeugt.\par
EmbeddedStorageConnectionFoundation#createStorageConnection wird nur aufgerufen vom ESM:\par
EmbeddedStorageManager#initialize\par
EmbeddedStorageManager#singletonConnection (on-demand singleton Erzeugung)\par
\par
#initialize wird nur in #start aufgerufen.\par
#singletonConnection  wird von X Methoden aufgerufen, aber alle von denen kommen erst NACH Erzeugung und Start des ESM.\par
\par
Also mal den PersistenceStoreHandler anschauen.\par
Der gibt seinen objectRetriever zur\'fcck.\par
Der wird im Konstruktor gesetzt.\par
Der wird vom StorerCreator aufgerufen.\par
Der wird vom PersistenceManager aufgerufen.\par
Und DER \'fcbergibt dabei einfach "this" anstatt "this.getEffectivePersister()".\par
Da ist der Grund.\par
\par
Schnell fixen: \'fcberall "this.getEffectivePersister()" reinbauen.\par
\par
Mal noch priv#223 erstellen, updaten und wieder schlie\'dfen.\par
\par
Jetzt zur\'fcck zu priv#222.\par
\par
Ah, haha. Eine "Database" in Lazy referenzieren w\'fcrde hei\'dfen, dass die im Base Projekt liegen m\'fcsste, weil dort auch die Lazy liegt.\par
\par
Man k\'f6nnte nat\'fcrlich den Typ Database in Storage machen und den einfach ObjectSwizzling implementieren lassen, dann \'e4ndert sich in Lazy gar nix.\par
Oder ich find eine allgemeine Bezeichnung daf\'fcr, dass das ein Ding Datenbasis-repr\'e4sentierendes Ding ist. Sowas wie EntityDomain oder so.\par
Hm...\par
Oder "ReferenceDomain", weil das ja alles im Package ".reference" liegt. Das w\'e4r nicht schlecht.\par
Achso, aber es muss ja die Methode "Object getObject(long objectId)" geben. Also eher "SwizzlingDomain".\par
Triffts technisch auch besser, weil es ja nicht nur darum geht, einen Bereich von Entities oder Referenzen zu haben, sondern von Entities/Referenzen mit eineindeutig zugeordneten Ids.\par
Nur Entities/Referenzen w\'e4ren ja unter mehreren StorageManagers gleichzeitig verwendbar.\par
Bzw. das "Object" muss schon mit dazu.\par
Hm. Aber dann ist das "Domain" einfach nur ein Zusatz wie ein unn\'f6tiger Balast.\par
Also passt "ObjectSwizzling" wohl doch ganz gut.\par
Das kriegt noch eine "isLive" Methode, dann passt das.\par
Der Rest ist dann in der Database Implementierung in Storage.\par
\par
Also dann ist der Plan:\par
\par
interface Database extends ObjectSwizzling\par
kennt:\par
- StorageManager\par
- PersistenceObjectRegistry\par
- String identifier \'fcber die Foundation. Wenn keiner gesetzt ist, wird der full qualified path des base directory verwendet.\par
\par
\par
Hm... oder sollt ich alles Swizzling-m\'e4\'dfige doch wieder so umbenennen und in ein extra package verschieben?\par
Mach ich mal.\par
\par
Ach, aber das Problem daran ist:\par
Dann m\'fcsste die ObjectRegistry Swizzling Exceptions werfen, die kapiert wieder keiner, usw.\par
Lustig: das k\'f6nnte man mit einem ExceptionThrower interface wegabstrahieren. Dann w\'fcrde das Swizzling Teil Persistence Exceptions werfen.\par
Aber ne, f\'fcr den moment lass ich es mal so, wie es ist.\par
Reverten.\par
H\'e4, seltsame Fehlermeldungen im SourceTree.\par
Mal langsam von vorn. Erst unstagen, dann neues zeug l\'f6schen, dann \'c4nderungen discarden.\par
So gehts. Nur dass halt jetzt die \'c4nderungen f\'fcr priv#223 auch mit drin sind. Mist. Manuell feststellen. Sind ja nur 2 Klassen. Rest discarden und die 2 manuell fixen.\par
So, passt wieder.\par
\par
Jetzt aber sofort die priv#223 \'c4nderungen committen.\par
\par
\par
\par
22:45\par
\par
Weitermachen:\par
\par
interface Databases\par
kennt:\par
- HashTable mit String name als key und Database als value\par
\par
Das wars eigentlich schon.\par
Es muss wahrscheinlich eine static singleton instanz geben, aber der EmbedddedFoundation muss optional eine andere Instanz gesetzt werden k\'f6nnen.\par
\par
\par
Bei jedem Erstellen eines StorageManagers wird dieser in der Databases Instanz der EmbedddedFoundation foundation unter seinem Datenbank-Namen registriert.\par
Wenn es f\'fcr den Namen noch keine Database gibt, wird eine angelegt und fertig.\par
Wenn es schon eine gibt, wird geschaut:\par
Ist der StorageManager darin null (also schon vom GC collectet/gel\'f6scht) worden? Wenn ja, dann wird der neue gesetzt und weiter gehts.\par
Wenn nein, gibt es eine Exception, dass f\'fcr den spezifizierten Database Name bereits ein StorageManager vorhanden ist.\par
\par
Der Name ist defaultm\'e4\'dfig "MicroStream@"[base directory], kann \'fcber die Foundation aber beliebig gesetzt werden.\par
\par
Der StorageManager merkt sich intern die Database Instanz, zu der er geh\'f6rt.\par
Und die wird dann in den LazyReferences als loader gesetzt.\par
\par
Damit w\'e4re das Problem gel\'f6st.\par
Jetzt muss ich es nur noch runterindern.\par
\par
Ah, Henne-Ei-Problem beim Implementieren aufgefallen:\par
Holt sich der StorageManager seinen Identifier von der intern gehaltenen Database oder hat er unabh\'e4ngig davon bzw. "davor" einen eigenen identifier?\par
Wenn er sich den identifier von der Database Instanz holt, kann nicht validiert werden, ob ein SM zu einer existierenden DB passt.\par
Wenn er selber einen hat, ist das eine redundante Referenz, die logik-gesichert immer konsistent zu der in der DB Instanz sein muss.\par
Knifflig.\par
SM und Identifier bei der Registrierung bei Databases getrennt \'fcbergeben erlaubt Fehler (Inkonsistenz) und entkoppelt den Namen vom StorageManager.\par
\par
Und noch ein Henne-Ei-Problem:\par
Der SM kann nicht als initialen Bestandteil (final Feld) eine Database kennen, wenn die erst f\'fcr eine fertig SM Instanz angelegt bzw. bestimmt und aktualisiert wird.\par
Dem SM die DB nachtr\'e4glich setzen k\'f6nnen ist nicht gut, weil man sonst eine Inkonsistenz zu seiner vorherigen erzeugen w\'fcrde. Selbst dort austragen w\'fcrde nichts helfen, weil ja Lazy Refs von der abh\'e4ngen.\par
Gut, aber was ich machen k\'f6nnte ist:\par
Erst mal leere DB Instanz anlegen mit/f\'fcr dem zuk\'fcnftigen identifier des SM, dann damit StorageManager, dann DB Instanz mit dem SM updaten.\par
Das w\'e4re sauber, hat nur einen kleinen Haken: Falls die DB nicht passt, h\'e4tte der SM trotzdem schon eine final Referenz darauf.\par
Aber das kann ja auch validiert werden: Wenn die DB Instanz einen nicht-null SM hat, gibt es einen Fehler, bevor der SM erzeugt wird.\par
Das l\'f6st auch das erste Problem oben.\par
\par
Ok, so bau ich das.\par
\'c4h, morgen.\par
\par
\par
2020-02-11\par
\par
\'dcberlegungen von zwischen den Arbeitszeiten:\par
- Es darf nicht "StorageIdentified" hei\'dfen mit einem nichtssagenden "identifier", sondern es muss "DatabasePart" mit "databaseName" hei\'dfen.\par
- Man muss einen inaktiven StorageManager ersetzen d\'fcrfen. Sonst h\'e4ngt "harte" Programmlogik von dem "weichen" Zustand ab, ob der GC das vorherige Ding schon collectet hat oder nicht.\par
\par
F\'fcr den Defaultnamen braucht der StorageFileProvider irgendwie eine "String locationIdentifier" oder sowas.\par
Einbauen.\par
\par
Foundation erweitern. Inklusive JavaDoc.\par
\par
Achja und nat\'fcrlich die Hauptsache: Die Logik, die das Ding in die Lazy Reference reinsetzt.\par
Ach, dabei gibt es jetzt aber einer Fallunterscheidung zwischen Lazy und zwischen dem Persister fields f\'fcllen:\par
Bisher war das beide Male dieselbe Instanz. Jetzt ist das eine die Database und das andere bleibt der StorageManager.\line Mal schauen, wie das wird.\par
\par
Die \'c4nderung im LoadHandler ist trivial, aber die Referenz durch den Persistence Stack durchzuschleusen zieht sich quer durch, bis zur PersistenceFoundation.\par
Aber macht ja nix. Ist halt nur einiges an Tipperei.\par
\par
Hm, aber knifflige Frage:\par
Darf der objectRetriever genauso null sein wie der persister und dann wird als default der PersistenceManager genommen?\par
Hm. Eigentlich schon. Weil die Storage Verwendung muss halt ihre Database richtig setzen, aber die Serialisierung Verwendung muss da dann den persistenceManager nehmen.\par
Also doch nullable und auch getEffectiveObjectRetriever(), so wie beim Persister.\par
\par
Interessant im Zusammenhang mit Storern:\par
Die brauchen ja eigentlich nur den ObjectRetriever, nicht den Persister.\par
D.h. hier ist es keine zweite Referenz, sondern nur umstellen auf das besser passende.\par
\par
Wobei interessant ist: eigentlich k\'f6nnte/m\'fcsste auch schon das Storen die Persister Felder von Entities setzen, falls vorhanden.\par
Aber beim Storer State ver\'e4ndern find ich erst mal nicht so toll, auch wenn es sich um transient Felder handelt.\par
Aber trotzdem: Wenn man nur null-Felder setzt, kann eine Inkonsistenz reinkommen.\par
Wenn man Felder unabh\'e4ngig vom Inhalt setzt, kann was vom Benutzer-Entwickler gesetztes einfach \'fcberschrieben werden.\par
Beides nicht toll.\par
\par
Hm. Oder m\'fcsste das nicht doch dasselbe Feld sein? D.h. dass solche Persister-verkn\'fcpften Entities eigentlich die Database Instanz gesetzt bekommen, zu der sie geh\'f6ren?\par
Hm. Dann m\'fcsste die nat\'fcrlich Persister implementieren. Aber eigentlich ... sieht das alles sinnvoll f\'fcr die aus.\par
\par
Das w\'fcrde auch das Problem l\'f6sen, dass solche verlinkten Entities dann wieder auf eine storage manager instanz festgenagelt w\'e4ren, auch wenn sie inaktiv ist und dass sie ein memory leak f\'fcr die storage manager w\'e4ren.\par
Also eigentlich genau das gleiche in gr\'fcn wie bei den Lazy refs.\par
Also doch wieder konsolidieren zu einem Fall?\par
Dann \'e4ndert sich halt f\'fcr den User das Feature: von StorageManager zu Database. Aber wieso nicht?\par
\par
Also alles wieder zur\'fcckbauen auf nur Persister.\par
Persister interface in Database.Default implementieren. Einfach nur durchreichen, geht ja schnell.\par
\par
So, fertig. Jetzt testen.\par
\par
Funktioniert auf Anhieb:\par
Storage shutdown'en, Lazy#get wirft exception, dass die Database keinen aktiven Storage Manager hat.\par
Mit vorher neu gestartetem Storage Manager: Keine Exception mehr, sondern geht wieder.\par
\par
Jetzt noch Issue updaten, dann ist das fertig.\par
}
 